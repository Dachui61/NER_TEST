#-*- coding:utf-8 -*-
from paddlenlp import Taskflow
import re
ner = Taskflow("ner",entity_only=True,home_path= "/paddle")
nodes_data = []
links_data = []
# 存储每个章节的title
chapter_ids = []

dic = {
  "概述": {
    "概述": "编程(programming)，可简单理解为，程序员与计算机进行交流的过程。程序员使用计算机语言告诉计算机做什么，怎么做，计算机也将做事的过程和结果反馈给程序员，因此，先从程序员与计算机的交流场景开始，学习编程。",
    "1.1 计算机 ": "顾名思义，计算机就是计算的机器，它通过执行一系列指令来完成特定的计算功能，被执行的一系列指令统称为程序(program)。一台计算机一般会包含众多的物理设备和各种程序，程序在这些物理设备上运行，实现所需要的功能，这些物理设备统称为硬件(hardware)，这些程序统称为软件(software)。冯·诺依曼机是根据图灵机这个计算模型推导出的计算机逻辑结构，不仅指导人们设计制造计算硬件系统，也是程序员编写程序的基础。冯·诺依曼机由存储器、运算器、输入设备、输出设备和控制器五部分组成，冯诺依曼机模型如图 1.1 所示。输入输出内存CPU控  制数据结果图 1.1 冯·诺依曼机模型冯·诺依曼机从功能上描述了计算机的逻辑结构，表明一台计算机应具有 5 大功能部件。存储器也称为内存，其功能为存储程序和数据。运算器也称为(中央)处理器(CPU)，其功能为执行程序中的指令，实现规定的运算。输入设备和输出设备完成输入输出功能，控制器用于协调各个功能部件之间协同工作。经历几十年的发展，“计算机”已发生了根本性的改变，并以各种各样的形态深入到人们的生活和工作，但仍未脱离冯·诺依曼机这个体系结构，打破冯·诺依曼机的制约。内部资料 严禁外传2",
    "1.2 计算机语言 ": "语言是人类创造的工具，它用来表达意思，交流思想，并借助语言保存和传递人类文明的成果，语言是民族的重要特征之一。计算机语言也称为程序设计(编程)语言(programming language)，是程序员与计算机交流沟通的工具，也是程序员之间进行交流沟通的主要工具。计算机刚发明的时候只能理解用 0 和 1 序列表示的机器指令，只有计算机专家能直接用 0 和 1 的序列作为机器指令来编程，编写的程序不仅难以理解，而且效率极低。为了方便专家记忆和编程，用一些符号(助记符)来代替 01 序列表示的机器指令，出现了汇编语言。汇编语言增强了程序的可读性，也提高了编程的效率，但仍然主要用于专家与计算机交流沟通，不能满足广泛使用的发展需要。使用机器指令或汇编语言编写程序，主要是用于程序员与计算机之间的交流，编写出的程序与计算机硬件强关联，只能在特定的计算机上运行。机器指令集及相应的汇编语言称为低级语言。随着计算机的发展，将数学语言和自然语言(英语)中的核心表达特性引入计算机语言，相继诞生了各种各样的高级语言。如将数学中的代数式和函数等核心表达元素引入计算机语言，程序中出现了“a+b”“y=f(x)”等类似数学的计算机表达式，将英语中的 if 句型引入计算机语言，出现了“if (a>b){b=a;}”语句。将数学语言和自然语言(英语)中的核心表达特性引入计算机语言，不仅仅减少了编写程序的工作量，提高了编程效率，更重要的是，可用数学和自然语言中的方法解决实际问题，可用数学语言和自然语言中的表达方式编写程序，这更符合人们的思维方式，更便于程序员之间进行交流沟通。程序语言越低级，则必须对过程描写得越具体，指令也就越接近机器的硬件逻辑。相反，程序语言越高级，就越接近对问题的描述与表达，因而更直观，更容易被人们所理解。高级语言的广泛应用，促使编程人数迅速增加，促进了软件产业突飞猛进的发展。",
    "1.3 为什么选择 C/C++语言 ": "C/C++的发展历程和主要特性决定了 C/C++语言是学习编程的首选语言工具。1970 年，AT&T 公司 Bell 实验室的 D.Ritchie 和 K.Thompson 共同发明了 C 语言，研制C 语言的初衷是用它编写 UNIX 系统程序，C 语言实际上是 UNIX 的“副产品”。C 语言充分结合了汇编语言和高级语言的优点，高效而灵活，又容易移植，所以很受程序设计人员的青睐，成为计算机产业界的宠儿。为此，他们两位获得了 1983 年度的“图灵奖”。1971 年，瑞士联邦技术学院 N.Wirth 教授发明了 Pascal 语言。Pascal 语言语法严谨，层次分明，程序易写，具有很强的可读性，是第一个结构化的编程语言。它一问世就受到广泛欢迎，为此，N.Wirth 教授获得 1984 年度的“图灵奖”。内部资料 严禁外传320 世纪 70 年代中期，Bjame Stroustrup 在剑桥大学计算机中心工作。他使用过 Simula和 ALGOL 语言，实现过低级语言 BCPL，接触过 C 语言，积累了丰富的程序语言经验。1979 年，Bjarme Stroustrup 到了 Bell 实验室，在 C 语言中引 ALGOL 的结构和 Simula 的类，形成了带类的 C(C with classes)。与 C 语言相比，带类的 C 编程更加简单和可靠，运行高效，可移植性更好。1983 年带类的 C 语言被正式命名为 C++。20 世纪 90 年代， C 慢慢淡出， C++逐渐应用，促进了 C++稳步发展。1998 年 ISO/ANSIC++标准正式制定，随后发展更加迅速，使其成为一个标志性的计算机语言。鉴于 C++对现代计算机产业的贡献，1995 年 BYTE 杂志将 Biame Stroustrup 列入“计算机工业 20 个最具影响力的人”。C++对 C 的继承是青出于蓝而胜于蓝，它既可以进行 C 语言鼎盛时期所流行的面向过程的结构化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象程序设计和以模板为特点的泛型程序设计。C++是一种混合型程序设计语言，“混合”体现在可以采用不同的程序设计方法，进行各种目的的编程。“混合”是因为沿革了 C。从本质上说，当今的世界，既有许多规模不大，要求能经济地运行的编程任务，如嵌入式编程，也有越来越多的大规模编程任务，如基于大数据的智能分析系统，因而要求编程语言通用、面广、多样和灵活。“混合”意味着绝不放弃计算机高效运行的实用性特征，而又致力于提高大规模程序的编程质量，提高程序设计语言的问题描述能力。本书选择 C/C++语言作为学习编程的语言工具，主要是因为它反映了计算机语言的发展历史，它的主要特性和表达能力能够支撑我们学习基本的编程原理和方法，也有助于读者自学其他计算机语言。需要特别强调的是，本教材的主要目的不是为了学习 C/C++语言，而是为了学习编程的基本知识、技术和方法，希望能够跳出语言细节而聚焦于程序设计的基本原理和方法，真正为读者深入学习编程打下基础，因此，C/C++语言仅仅作为学习编程的语言工具，主要使用到 C 语言的部分。",
    "1.4 简单程序 ": "下面是一个用 C/C++编程的简单的程序，它的功能非常简单，就是将输入的两个数相加，并输出结果。两数相加示例代码，如例 1.1 所示。【例 1.1】两数相加。#include <iostream>using namespace std;void main(){int a, b, sum;cout << \"请输入两个数:\\n\";cin >> a >> b;sum = a + b;//两个数相加内部资料 严禁外传4cout << \"两数之和: \" << sum << endl;}每个程序都需要一个唯一的入口，在 C/C++语言中，规定了这个入口为 main 函数，程序从 main 函数的第一行语句开始执行。cout 表示标准输出设备(output)，通常为显示器，<<表示输出，\"请输入两个数:\\n\"是在标准输出设备上输出的内容。cin 表示输入设备(input)，通常为键盘，>>表示输入，“cin >>a >>b”的含义为，从输入设备输入两个数到变量 a 和 b。“sum = a+b”的含义为，将 a 和 b 中的两个数相加，结果放到 sum。后面的语句就是输出 sum 中存放的结果。只要具有基本的自然语言和数学基础，很容易理解上面的简单程序，但要计算机理解这个程序，还需要给它配备一个“翻译”，既要将高级语言编写的程序“翻译”成计算机能理解的机器语言。",
    "1.5 编译和连接 ": "使用高级语言编程，能够很好地满足程序员之间进行交流沟通的要求，但也还必须让计算机硬件能够“理解”程序表达的含义，即程序能够在计算机硬件上运行。为了解决这个问题，专门设计了一组程序，先将高级语言编写的程序“翻译”成一系列机器指令，然后在计算机硬件上逐条运行这些机器指令。“翻译”例 1.1 的过程如图 1.2 所示，共分为编译和连接两个步骤。先将源程序文件add.cpp 中的程序“编译”为二进制表示的机器指令序列，并存储到一个目标代码文件 add.obj，然后，将 add.obj 中的代码与系统提供的 cout 和 cin 代码“连接”在一起，生成一个可执行程序文件 add.exe，add.exe 就可以在计算机上运行。源程序文件(source file)存储程序员编写的程序，以文本形式呈现，常常也将源程序文件中存储的内容称为源代码(source code)。目标代码文件(object file)存储“翻译”后的机器指令，常常是一个源程序文件对应一个目标代码文件，也将目标代码文件中存储的内容称为目标代码(object code)。可执行程序文件(executable program file)存储程序的完整目标代码，包括各个目标代码文件中的代码，以及系统提供的目标代码。编译连接程序的过程，如图 1.2 所示。内部资料 严禁外传5//add.cpp#include <iostream>using namespace std;void main(){int a, b, sum;cout << \"请输入两个数:\\n\";cin >> a >> b;sum = a + b;//两个数相加cout << \"两数之和: \" << sum << endl;}//add.obj二进制cout和cin相关的目标代码//add.exe二进制编译连接（Link)源程序文件可执行程序文件目标代码文件图 1.2 编译连接程序的过程C/C++提供了许多标准化库，这些库中包含了程序员可以使用的各种程序代码数。例如，输入和输出库中提供了一些程序代码，利用这些代码，可以向屏幕输出信息，也可以从键盘获取数据。通过编译和连接两个步骤将源程序翻译成可执行的程序，是翻译程序的一种方式，这种方式称为编译型，除了此之外，还有另外一种称为“解释型”的方式。解释型采用“边翻译边执行”的方式，即翻译一条语句就执行这条语句对应的机器代码，一般不会生成一个完整的可执行文件。“解释型”有很多应用场景，如前端程序，脚本语言。程序设计语言发展到现在，无论编译型还是解释型，一般都会提供一个集成开发环境(Integrated Development Environment，IDE)。程序员可以在该环境中完成编辑(edit)、编译(compile)、连接(link、make 或 build)、调试(debug)程序等软件开发工作。",
    "1.6 调试程序 ": "编程是为了解决实际问题，是一件复杂的工作，往往涉及很多方面的事情。首先，在编程前要考虑的是选择一个程序设计语言作为编程的语言工具，并选择一个相应的集成开发环境。使用 C/C++编程的集成开发环境很多，可适合不同的应用场景。本教材选择 Microsoft内部资料 严禁外传6公司的 Visual Studio 2013(简称 VS2013)集成开发环境，仅仅是因为必须选择一个 IDE 而刚好以前使用过它，并不是必需的。建议读者根据自己的兴趣和具体情况，选择一个适合自己的 IDE 编写、调试程序。选择好程序设计语言和集成开发环境后，就可以开始编写、调试程序了。调试程序是一个不断迭代的过程，包括编辑、编译、连接、调试四个步骤，整个流程循环往复，直至编写出所需要的程序。调试程序的一般流程，如图 1.3 所示。编辑源程序文件编译连接编译正确连接正确是是运行结果正确是否否否图 1.3 调试程序的一般流程编辑是指程序员在集成开发环境中编写已设计出的程序，主要目的是将程序的源代码输入到计算机，程序以文本形式呈现，这种程序被称为源程序。源程序一般存放在一个或多个文件中，存放 C++源程序的文件常常以 .cpp(在 Windows 环境中)作为文件扩展名。编译是指将程序员编写的源程序翻译成机器指令，生成目标代码，存放在目标代码文件中，后面简称为目标文件。Windows 环境中的 C++编译器通常以 .obj 作为目标文件的扩展名。目标代码也称为机器代码，是计算机能够识别的指令集合。源程序被编译后生成的目标代码只是一个个独立的程序段，还不能在计算机上运行。连接是指将分散在各个目标文件和标准库中的相关代码整合成一个完整的程序，生成一个可执行文件，可执行文件通常以 .exe 作为文件扩展名。C/C++程序在编译后，通过连接若干个目标文件与若干个库文件而创建可执行程序。库文件是系统提供的程序链接资源，属于集成开发环境的一部分。目标文件与库文件连接的结果是生成计算机可执行的程序。在编译时，需要对源程序进行语法和语义分析，如果没有发现错误，就将源程序翻译为内部资料 严禁外传7目标代码，并生成目标文件，如果发现错误，就终止编译。在连接时，首先检查所需的目标代码是否完整，如果所需要的目标代码都有了，就将这些目标代码整合在一起，生成相应的可执行文件，否则，终止连接，不生成可执行文件。通过编译和连接后生成的可执行文件，可以执行，但并不代表一定能得到预期的结果。确保程序运行能得到预期的结果这个工作还需要程序员来人工完成，这就是调试程序。调试程序的作用是根据程序的运行结果发现并改正程序中的错误(bug)，是一个不断迭代的过程。在编程过程中，调试程序的工作量很大。程序员中流行一种说法，编程的主要工作就是不厌其烦地“抓虫”，即找 bug，调试程序。集成开发环境功能齐全，调试功能很强，程序编好后，可以立刻在 IDE 中调试以获得初步测试结果，然后，可以方便地做成 Beta 版形式，拿到实际环境中进一步测试，最后做成软件发行版。编程是一种能力，具体体现在三个层次，第 1、能够运用数学、自然科学和计算科学与技术中的基本知识和基本原理设计程序，第 2、能够编写并调试程序，第 3、编写的程序能够解决实际问题，投入实际应用。编程能力不能通过传授方式获得，只能在不断的编程训练中逐步培养。初学者，不仅要学习基本的知识和原理，也需要将学习重点聚焦到编程方法上，并不断上机调试。",
    "1.7 本章小结 ": "本章主要介绍了计算机、计算机语言和程序等基本概念，通过一个简单程序介绍了编译和连接的功能和作用，最后介绍了调试程序的一般步骤，让读者对编程有一个基本的了解，为后面学习编程打下基础。",
    "1.8 习  题 ": "1. 计算机的 5 个主要部件是什么？2. 机器语言程序和高级语言程序的区别是什么？3. 编译器有什么作用？4. 什么是源程序？什么是目标程序？5. 你使用的计算机运行的是什么操作系统？6. 什么是链接(link)？7. 在自己的计算机上安装一个适合的 IDE，并调试通过例 1.1 中的程序。内部资料 严禁外传8内部资料 严禁外传9"
  },
  "表达式和数据类型": {
    "表达式和数据类型": "图灵奖得主高德纳(Donald E.Knuth)讲：很多人认为，算术运算只是小孩学的简单玩意儿，用计算器就能做，但事实上，它是一个非常有趣和迷人的研究课题，算术运算构成了计算机各种应用的重要基础。因此，从算术运算开始学习编程，先学习使用表达式描述计算机中的计算，再学习存储和管理数据的基本知识，最后学习编写、调试表达式的基本方法。",
    "2.1 表达式 ": "下面从四则运算开始学习计算机语言中的表达式，学习如何使用一个表达式向计算机描述一个简单的计算。2.1.1 四则运算中的计算四则运算是算术运算中最基础也是最重要的内容。四则运算的计算规则是“先乘除后加减”和“从左到右依次计算”。例如：计算1 × 2 + 4 ÷ 2 + 3 × 51 × 2 + 4 ÷ 2 + 3 × 5 计算1 × 2= 2 + 4 ÷ 2 + 3 × 5 计算4 ÷ 2= 2 + 2 + 3 × 5 计算3 × 5= 2 + 2 + 15 计算2 + 2= 4 + 15 计算4 + 15= 19计算1 × 2 + 4 ÷ 2 + 3 × 5步骤是，计算 1×2 得到 2，计算 4÷2 得到 2，计算 3×5 得到15，计算 2+2 得到 4，计算 4+15 得到 19，最后得到算式的结果 19。算式 1×2+4÷2+3×5的计算步骤，如图 2.1 所示。×122÷422×3515+4+19①②④③⑤图 2.1 算式 1×2+4÷2+3×5 的计算步骤“先乘除后加减”的原则，将加减乘除划分为两个级别，乘除运算为一个级别，加减运算为一个级别，乘除运算的级别高于加减的级别，并规定先计算级别高的运算，再计算内部资料 严禁外传10级别低的运算。按照这种方法划分出的级别简称为运算的优先级。当运算的优先级相同时，应按照“从左到右依次计算”的原则确定运算的计算顺序，先计算算式中左边的运算，再计算右边的运算。这条原则称为运算的结合性。一个运算的结合性，一般是“从左到右”，但也有“从右到左”的情况。从计算角度讲，使用运算的优先级和结合性能唯一确定一个算式的计算顺序。 加法和乘法还具有交换律，使用交换律对算式进行等式变换，可推导出多个相等的算式。如使用加法的交换律对1 × 2 + 4 ÷ 2 + 3 × 5进行变换，可推导出算式4 ÷ 2 + 1 × 2 +3 × 5，其计算步骤如图 2.2 所示。×122÷422×3515+4+19①②④③⑤图 2.2 推导出算式 4÷2+1×2+3×5 的计算步骤使用四则运算的结合律和交换律，可推导出与1 × 2 + 4 ÷ 2 + 3 × 5相等的多个算式，按照这些算式的计算顺序都能计算出正确的结果。建议读者试一下，能推导出多少这样的算式。使用数学方法，一个算式可推导出多个相等的算式，按照每个算式规定的计算顺序都能计算出相同的结果。2.1.2 在计算机中的计算顺序使用计算语言描述四则运算算式，非常简单。因键盘中没有×和÷两个符号，需用*和/分别替换。如算式1 × 2 + 4 ÷ 2 + 3 × 5，可以改写为1  2 + 4/2 + 3  5改写后的算式，可在计算机中运行，称为计算机表达式，简称表达式。表达式在计算机中有两种可能的计算顺序,即有两种可能的计算步骤。如，表达式 1*2+4/2+3*5 有两种可能的计算步骤，如图 2.3 所示。内部资料 严禁外传11*122/422×3515+17+19①②④③⑤*122/422×3515+4+19①②④③⑤a.左边优先                         b.右边优先图 2.3 表达式 1*2+4/2+3*5 的两种计算步骤图 2.3 所示的两种可能的计算步骤，其计算顺序与数学上的计算顺序不同，但每种计算步骤一定能对应与原式相等的一个算式，从而保证了计算结果的正确性。建议读者分别推导出前面两种计算顺序对应的算式。 一个数学算式存在多个正确的计算顺序，计算机只从中选择一种计算顺序进行计算，所选择的计算顺序往往与数学中的计算顺序有所不同。在计算机编程中，不能不考虑计算顺序对计算结果的影响。如计算 10÷3×6，其结果应该为 20，但在计算 10÷3 时，由于除不尽会产生计算误差。如果精度保留到两位小数(计算机中必须指定精度)，计算结果为 19.98，而不是 20。总而言之，计算机在计算算式时，只选择数学算式的一种计算顺序进行计算，而计算结果因精度等原因，可能得不到预期的结果，这就要求程序员在编写表达式时，必须清楚表达式的计算顺序，并保证这个计算顺序能得到预期的结果。2.1.3 表达式的运算序列中学数学中还学习了代数。在代数中使用字母“代”替算式中的“数”，构成了带有字母的算式，这种带有字母的算式被称为代数式。代数的常见应用就是数学公式，需要注意的是，数学公式中的字母，称为变量，代入的数被称为变量的值，数学公式中除了代数式外，一般还包含了等号。如，计算最简单的数学公式 c = a + b，可编写如下代码。unsigned int a = 5, b = 4, c;c = a + b;在计算表达式 c=a+b 之前，需要先将变量 a 和 b 的值存储到内存，然后才能进行计算。表达式 c=a+b 在冯诺依曼机上的计算过程，如图 2.4 所示。内部资料 严禁外传12InputOutputabc549549CPUmemory5  +   4  =  9图 2.4 表达式 c=a+b 在冯诺依曼机上的计算过程表达式 c=a+b 在冯诺依曼机上的计算过程，分为 4 个步骤。 第 1 步、从变量 a 的内存单元中取出值 5 到 CPU； 第 2 步、从变量 b 的内存单元中取出值 4 到 CPU； 第 3 步、CPU 计算 5 加 4 得到值 9； 第 4 步、将值 9 存储到变量 c 的内存单元中。 在冯诺依曼机上计算表达式 c=a+b 时，核心是其中的 4 个计算步骤，因此，可去除了冯·诺依曼机等背景信息，仅仅描述这 4 个计算步骤。表达式 c=a+b 的计算步骤，如图 2.5 所示。图 2.5 更加简洁，也能突出重点，但仍然要按照图 2.4 来理解。a:5+9b:4=c:9图 2.5 表达式 c=a+b 的计算步骤一个表达式描述了在冯·诺依曼机上的一组有顺序的计算步骤，一般将这组计算步骤，称为一个运算序列。程序员用计算机语言描述数学公式时，往往不知道数学公式中变量的值，在画图时可用一个符号来表示程序运行时变量的值。表达式 c=a+b 的运算序列，如图 2.6 所示。a:v1+v3b:v2=c:v3图 2.6 表达式 c=a+b 的运算序列图 2.6 描述了表达式 c=a+b 定义的运算序列，其中用符号表示各变量的值，这种图称为运算序列图。本教材约定，在表示运算序列时都以“v+数字”的形式标注其中的变量值。在进行具体计算时再将这些符号替换为变量的具体值，如图 2.5 所示。计算机表达式描述的是冯诺依曼机上的一个运算序列。 从本质上讲，每个表达式都定义了一个运算序列，也将定义的运算序列称为表达式的语义。除了使用运算序列图来表示一个表达式的语义外，还可用文字描述，如，c=a+b 的语义(运算序列)为：从变量 a 取出值 v1, 从变量 b 取出值 v2, v1 加 v2 得到值 v3，将值 v3 存储到变量 c 的内存，得到变量 c。用运算序列图描述表达式的语义，直观清楚，便于理解，但应用场景有限，另一方内部资料 严禁外传13面，用文字描述表达式的语义，应用范围更广，但比较抽象，因此，建议结合使用。2.1.4 计算表达式的基本方法在实际编程中，程序员的最主要工作之一是编写表达式。编写表达式的基础是将一个数学公式改写为表达式，并保证按照表达式的计算顺序能够得到预期的计算结果。例如：求一个正方形和一个矩形周长之和。 根据求正方形和矩形的周长公式，很容易写出如下数学公式：c=4l+2(a+b)并改写为如下的表达式：c=4*l+2*(a+b)按照数学中的方法，先计算优先级高的运算，再计算优先级低的运算，优先级相同时按照结合性依次计算，其核心思想是在算式中寻找最先计算的运算，但计算机采用的是另一种方式，其核心思想是在表达式中寻找最后计算的运算。在表达式中寻找最后计算的运算时，仍然使用优先级和结合性，但在使用优先级时不是按照从高到低，而是按照从低到高寻找，这与数学计算时的顺序刚好相反。同样，使用结合性时，也是按照结合性相反的顺序寻找。根据编译原理并结合编程场景专门设计了一种计算表达式的图形方法，称为计算顺序图。使用计算顺序图计算表达式，主要包含两个步骤，第 1 步，确定表达式中运算的计算顺序；第 2 步，按照计算顺序依次计算每个运算。1. 确定表达式的运算顺序计算顺序图中包含画水平线和竖线两个操作。水平线的含意是“计算这个表达式”，竖线的含意是“计算这个运算”，水平线到竖线的含意是“要计算这个表达式，先计算这个运算”，竖线到水平线的含意是“要计算这个运算，先计算这个表达式”。这种句式，体现了递归思想，因此，强烈推荐，一边画图一边念这两句话，以逐步培养自己的递归思维。第 1 步：要计算 c=4*l+2*(a+b)，先计算= 先在整个表达式的正下面画一条水平线，表示“要计算 c=4*l+2*(a+b)”，然后在表达式 c=4*l+2*(a+b)中寻找到最后计算的运算=，并在=的正下面画一条与水平线正交的竖线，表示“先计算运算=”。整个表达式 c=4* l +2*(a+b)中最后计算的是运算=，如图 2.7 所示。=是计算机语言中的一个运算，称为赋值运算，其他几个运算的优先级都比它高，因此，它是最后计算的运算。运算=将表达式分成左右两个表达式，左表达式中只有一个变量 c，没有包含运算，不存在寻找运算的问题，右表达式 4*l+2*(a+b)包含了多个运算，需要继续寻找其中最后计算的运算。第 2 步：要计算=，要先计算 4*l+2*(a+b)。 因=下面的竖线已经画了，只需在 4*l+2*(a+b)的正下方画一条水平线，表示“要先计算 4*l+2*(a+b)”。第 3 步：要计算 4*l+2*(a+b)，先计算+ “反向”使用“先乘除后加减”和“从左到右依次计算”两条运算规则，在4*l+2*(a+b)中寻找到最后计算的运算+(从左边数第 1 个)，然后在它的在正下方画一条竖内部资料 严禁外传14线。表达式 4* l +2*(a+b) 中最后计算的是运算+，如图 2.8 所示。运算+将表达式分成左右两个表达式，按照左边优先计算的假设，先在左表达式 4*l 中继续寻找最后计算的运算，然后在右表达式 2*(a+b)中寻找。c  =  4  *  l +  2  *  (a  +  b)图 2.7 c=4*l+2*(a+b)中最后计算的运算=c  =  4  *  l +  2  *  (a  +  b)图 2.8 4*l+2*(a+b) 中最后计算的运算+第 4-5 步：要计算+，先计算 4* l；要计算 4* l，先计算* 按照第 1-3 步中的方法在表达式 4*l 中寻找最后计算的运算*。 第 6 步：为“能够”计算的运算*标注计算顺序号① 按照“要计算这个运算，先计算这个表达式”的逻辑，计算表达式 4*l 中只有运算*，“能够”计算其中的运算*，因此，在运算*的正上方标注其计算顺序号①，如图 2.9 所示。c  =  4  *  l +  2  *  (a  +  b)①图 2.9 标注运算*的计算顺序①c  =  4  *  1  +  2  *  (a  +  b)①②图 2.10 标注运算+的计算顺序②在可计算的运算*上方标注计算顺序号后，沿着寻找路径退回到运算+，“要计算运算+”，还要“先计算表达式2  (a + b)”。第 7-10 步：在 2*(a+b)中寻找最后计算的运算并标注计算顺序 按照寻找最后计算运算的方法，先在 2*(a+b)中寻找到最后计算的运算*，然后在(a+b)中寻找到最后计算的运算+，并标注运算+的计算顺序号②，如图 2.10 所示。其中，括号不是运算，而是构成表达式的符号，其作用是提高运算的优先级，以保证先计算括号内的运算再计算括号外的运算。c  =  4  *  1  +  2  *  (a  +  b)①②③图 2.11 标注运算*的计算顺序③c  =  4  *  1  +  2  *  (a  +  b)①②③④⑤图 2.12 表达式 c=4*l+2*(a+b)中所有运算的计算顺序第 11 步：沿着寻找路径退回到运算*，并标注其计算顺序号③ 2*(a+b)中，因其中的运算+已标注计算顺序号，表示已在前面计算了(a+b)，因此，“能够”计算其中的运算*，在其上方标注计算顺序号③，如图 2.11 所示。第 12-13 步：按照第 11 步的方法，先退回到运算+，并标注其计算顺序号④，然后退回到运算=，并标注其计算顺序号⑤，最终确定了表达式 c=4*l+2*(a+b)中所有运算的计算顺序，如图 2.12 所示。内部资料 严禁外传15经过 13 个步骤，在图 2.12 中标注了表达式 c=4*l+2*(a+b)中所有运算的计算顺序号，确定了所有运算的计算顺序。确定表达式运算顺序的步骤虽然很多，但有大量重复性工作，因此可将其归纳总结为三个主要步骤：第 1，寻找“能够”计算的运算。“反向”使用运算的优先级和结合性，在表达式中寻找最后计算的运算，直到寻找到“能够”计算的运算。第 2，沿着寻找路径逐个“退回”并标注计算顺序号。当寻找到“能够”计算的运算时，标注该运算的计算顺序号,并沿着寻找运算的路径逐个“退回”，继续给“能够”计算的运算标注计算顺序号，直到“退回”到不能计算的运算。第 3、跳到第 1 步继续寻找。当“退回”到不能计算的运算时，跳到第 1 步，从这个运算开始继续寻找能够计算的运算并标注其计算顺序号，直到为表达式中的所有运算都标注了计算顺序号。在画计算顺序图时，需要注意三点: 第 1，水平线一定要与表达式左右对齐，一样长； 第 2，水平线与表达式之间要预留足够空白； 第 3，竖线一定要在运算的正下方。 计算顺序图不仅描述了一个表达式中运算的计算顺序，也能表示出表达式的运算序列。根据图 2.12 所示的计算顺序，可画出表达式 c=4*l+2*(a+b)的运算序列图，如图 2.13所示。*4lv1*2v2v3+v4=c①②④③⑤+ab图 2.13 表达式 c=4*l+2*(a+b)的运算序列图当一个运算将一个表达式分成左右两个表达式时，前面假设了先计算左边的表达式，即采用左边优先的原则。如果采用右边优先的原则，先计算右边的表达式，表达式c=4*l+2*(a+b)的计算顺序，如图 2.14 所示。c  =  4  *  1  +  2  *  (a  +  b)①②③④⑤图 2.14 右边优先的计算顺序在计算机中，表达式有两种不同的计算顺序，但一个编译器只能选择其中一种，不可能同时选用两种。2. 计算表达式的值在计算表达式前，需要先给表达式中的变量指定值。如，给 c=4*l+2*(a+b)的所有变内部资料 严禁外传16量指定值。int l = 2, a = 3, b = 4;在计算顺序图上计算表达式的值，比较简单。具体方法是，按照计算顺序图中标注的计算顺序，根据运算的语义依次计算表达式中的运算，最终计算出表达式的结果。在计算顺序图中，找到计算顺序号为①的运算*，计算 4*l 得到计算结果 8，并标注在计算顺序图。具体步骤为，从变量 l 内存中取出整数2，标注在变量 l 的下面，计算 4*2 得到 8,将结果 8 标在图中该运算下面的右边直角处。运算*(标号为 1)的计算结果，如图 2.15所示。c  =  4  *  l  +  2  *  (a  +  b)①②③④⑤28图 2.15 运算*(标号为 1)的计算结果2214①②③④⑤28347c  =  4  *  l  +  2  *  (a  +  b)c:22图 2.16 表达式 c=4*l+2*(a+b)的求值过程按照图 2.15 中标注的计算顺序，依次执行其他运算，并将计算结果标注在计算顺序图中，最终计算出整个表达式的结果。表达式 c=4*l+2*(a+b)的求值过程，如图 2.16 所示。从本质上讲，计算表达式就是在冯诺依曼机上执行表达式的运算序列，因此，也可在表达式的运算序列图上按照标注的计算顺序，计算其中的运算，并将每个运算的计算结果标注在运算序列图中，最终计算出表达式的值。如，表达式 c=4*l+2*(a+b)在运算序列图上的计算过程，如图 2.17 所示。*4l:2v1:8*2v2:7v3:14+v4:22=c:22②④③⑤+a:3b:4①图 2.17 运算序列图中的求值过程使用计算顺序图和运算序列图都能计算表达式的值。两种方法相比，使用运算序列图人工计算，更能体现表达式在冯诺依曼机上的计算过程，而使用计算顺序图人工计算，更加简洁，效率更高。",
    "2.2 算术运算 ": "在数学中，将世间万物都抽象为数和运算，再讨论其性质，发现其规律，定义推理规则，经过不断发展，最终形成了庞大的数学理论体系。计算机按照数学这个思想，以数和运算为基础，构造了信息世界的高楼大厦。计算机语言不仅提供了算术运算、逻辑运算、关系运算等数学中的常见运算，还提供了很多计算机专用运算，如位运算、地址运算等。在附录 2 中专门提供了 C/C++的《运算表》，其中以运算序列的方式描述了每个运算语义，供读者查阅。也建议初学者经常查阅运算表，理解运算的语义，并熟练掌握常用运算的使用。内部资料 严禁外传17计算机语言一般提供了加(+)、减(-)、乘(*)、除(/)四则运算,除此外，还提供负号、模(%)等其他基本的算术运算，但一般不直接提供乘方、开方等比较复杂的运算。C/C++语言中，常用的算术运算有 5 个，每个算术运算符都有特定的语法语义。算术运算的语法语义，如表 2.1 所示。表 2.1 算术运算的语法语义运算符 名称 结合性 语法 语义或运算序列*乘Multiplication从左到右 exp1*exp2计算exp1得到值v1，计算exp2得到值v2，v1乘以v2得到值v3/除Division从左到右 exp1/exp2计算exp1得到值v1，计算exp2得到值v2，v1除以v2得到值v3%模Modulus从左到右 exp1%exp2计算exp1得到整数类型的值v1，计算exp2得到整数类型的值v2，v1除以v2取余数得到整数类型的值v3+加Addition从左到右 exp1+exp2计算exp1得到值v1，计算exp2得到值v2，v1加v2得到值v3–减Subtraction从左到右 exp1-exp2计算exp1得到值v1，计算exp2得到值v2，v1减v2得到值v3表 2.1 中的算术运算都有两个操作数，称为双目运算。每个运算用一个符号来标识，标识运算的符号被称为运算符。要注意的是，加减运算的运算符与数学中的符号完全相同，但乘除运算的运算符不一样。算术运算也有优先级和结合性，与数学中的优先级和结合性完全相同。在表 2.1 中，按照从高到低的顺序排列，用加粗的表格线区分不同优先级的运算，相邻两条加粗表格线之间的运算有相同的优先级。2.2.1 算术运算的语法和语义算术运算有语法和语义，算术运算的语法规定了使用该运算构成表达式的法则，算术运算的语义规定了数集上的映射规则，即数据的转换规则。在数学中，使用操作数 op 描述了算术运算的语法和语义。如加法运算的语法为“op1+ op2”，其中，op1 和 op2 为操作数；加法运算的语义为，op1 加 op2 得到两数之和，将op1 和 op2 两个数映射到它们的和。数学中加法运算的语义，如图 2.18a 所示计算机语言中的算术运算是使用数学的算术运算定义的，并针对计算机的特点进行了扩展，以便于构造和计算表达式。在语法方面，将数学中的操作数 op，替换为表达式 exp，融入了使用算术运算构造表达式的规则。如加法运算，将其语法“op1+op2”修改为“exp1+exp2”,要求 exp1 的计算结果作为加法的操作数 op1，exp2 的计算结果作为加法的操作数 op2。在构造表达式时使用一个表达式替换其中的操作数，如，可用表达式 a 和 b*2 分别替换 exp1+exp2 中的 exp1和 exp2，构成表达式 a+b*2。在语义方面，增加了计算操作数的步骤，规定先计算得到所需的操作数，然后再按照数学中规定的映射规则进行计算，最后得到算术运算的计算结果。如加法运算，在计算加法之前，增加了计算 exp1 和 exp2 的步骤，其计算序列为，计算 exp1 得到值 v1，计算exp2 得到值 v2，v1 加 v2 得到值 v3。计算机中加法运算的语义，如图 2.18b 所示。内部资料 严禁外传18+ab*2v1v2v3+exp1exp2v1v2v3op1op2+和a.数学中加法运算的语义         b.计算机中加法运算语义             c. 表达式 a+b*2 的语义图 2.18 加法的语义及应用举例根据算术运算的语义，可推导出表达式的运算序列。如，表达式 a+b*2 由表达式 a 和b*2 相加而成，使用 a 和 b*2 分别替换加法语义中的 exp1 和 exp2,得到表达式 a+b*2 的运算序列：计算 a 得到值 v1，计算 b*2 得到值 v2，v1 加 v2 得到值 v3。表达式 a+b*2 的语义,如图 2.18c 所示。一个表达式往往包含多个算术运算，会涉及到多个运算的语法和语义。如，表达式a+b*2 包含加法和乘法两个运算，在计算加法运算前，还需要计算 b*2，需要先执行其运算序列。除了一个是乘法、一个是加法外，乘法的语法和语义与加法完全相同，按照乘法的语法很容易分析出表达式 b*2 的构成，并按照其语义推导出其运算序列：计算 b 得到值v21，v21 乘 2 得到值 v2。将表达式 b*2 的运算序列，插入到如图 2.18c 所示的运算序列，最终得到表达式 a+b*2 的完整运算序列：计算 a 得到值 v1，计算 b 得到值 v21，v21 乘 2得到值 v2，v1 加 v2 得到值 v3。如图 2.19 所示。计算b*2*b:v212+av1v2v3图 2.19  表达式 a+b*2 的完整运算序列2.2.2 编写表达式解决实际问题时，一般先从客观世界中抽象出解决问题的数学模型，然后根据数学模型编写程序。在编程时，首先需要将数学模型中的数学公式改写为计算机表达式。编写表达式的基本思路，如图 2.20 所示。内部资料 严禁外传19客观世界数学公式1数学公式2数学公式3表达式1表达式2表达式3数学模型程序代码数学抽象改写公式图 2.20 编写表达式的基本思路在建立数学模型时，程序员一般以数学公式为粒度思考问题，而计算机只能在运算这个粒度上理解表达式。下面仍然以 c=4*l+2*(a+b)为例，在运算粒度上讨论构造表达式的过程。表达式 c=4*l+2*(a+b)的构成，如图 2.21 所示。可按照“从右到左、从上到下”的顺序，理解其构造过程：变量 a 和 b 相加构成a+b，2 和 a+b 相乘构成 2*(a+b)；4 和 l 相乘构成 4*l；4*l 和 2*(a+b)相加构成4*l+2*(a+b)，最后将 4*l+2*(a+b)的计算结果存到变量 c，构成 c=4*l+2*(a+b)。ab+2*a+b4l*4*l+2*(a+b)c=4*l+2*(a+b)c=4*l+2*(a+b)构造表达式理解表达式计算矩形周长计算正方形周长图 2.21 表达式 c=4*l+2*(a+b)的构成也可按照“从左到右、从上到下”的顺序，理解表达式 c=4*l+2*(a+b)的构造过程：4和 l 相乘构成 4*l；变量 a 和 b 相加构成 a+b，2 和 a+b 相乘构成 2*(a+b)；4*l 和 2*(a+b)相加构成 4*l+2*(a+b)，最后将 4*l+2*(a+b)的计算结果存到变量 c，构成c=4*l+2*(a+b)。与使用计算顺序图计算表达式对照，读者可以发现，上述两种构造过程刚好与“右边优先”和“左边优先”相对应，可以通过表达式的计算顺序反向推出构造表达式的过程，理解编写表达式的真实意图。表达式的构成方法与数学中公式的构成方法完全相同，也是表示同一个运算序列，因此，编写计算表达式的方法很简单，只需先写出数学公式，然后将数学公式改写为表达式。当然这个方法针对的是包含四则运算的比较简单的数学公式。内部资料 严禁外传202.2.3 表达式语句表达式语句是 C/C++中最常用的语句，语法非常简单，只需要在一个表达式后面加个分号“;”，就构成一个表达式语句，其语法如下：exp;其中，exp 是一个表达式，分号(;)是一条语句结束标志，C/C++中的每条语句都必须以分号“;”结束，这与我们平时习惯不同。在平时习惯中，往往用回车换行来表示一句话或一段话结束，需要特别注意。例如：int l = 2;int a = 3;int b = 4;int c;c = 4 * l + 2 * (a + b);上面 5 条语句都是表达式语句，其中，c = 4 * l + 2 * (a + b)是一个表达式，这很好理解，在后面加上分号，构成一个表达式语句。在 C/C++中，定义了丰富的运算，这些运算可以构成实现各种功能的表达式，具有强大的表现能力。但这也导致了一个问题，有很多表达式在形式上与数学算式完全不同，初学者会很不习惯，不过时间长了，自然就习惯了。很多计算机语言将定义变量作为一条语句，但在 C/C++中，定义变量也是运算，因此int l = 2、int a = 3、int b = 4 和 int c 都是一个表达式，在后面加上一个分号，就构成了一条表达式语句。int a = 3 的语义为，在内存中分配 int 规定大小的内存，设置变量名为 a，并用 3 初始化变量 a。int c 的语义为，在内存中分配 int 规定大小的内存，设置变量名为 c，不做初始化。这两个表达式中都只有一个运算，int a = 3 中“=”表示初始化，是定义变量中的操作步骤。",
    "2.3 变量及其运算 ": "数学，顾名思义，就是研究“数”的学科，代数，就是用字母“代”替“数”参与计算。下面，从代数中的字母开始学习编程中的变量，学习计算机存储和管理数据的基本知识和方法。2.3.1 计算机中的变量变量和数据类型既是计算机中的核心概念，也是计算机语言的核心内容，同时也是编程的基础。内部资料 严禁外传211. 变量的概念计算机中的变量来源于数学中的变量，如求一个圆的周长公式 = 2其中，圆的半径决定了周长的大小，给定一个r的数值，就会得到圆的周长，和是可变的，称为变量。又如函数的一般形式 = (, )其中，x,y 是自变量，z 为因变量，都是变量。每个变量都有一个取值范围，x,y 的取值范围称为定义域，z 的取值范围称为值域。从数学中引入了变量的概念，并用计算机中的内存来存储变量的值，形成了计算机变量的概念。计算机变量这个概念不仅包括变量名和变量的值两个数学概念，还包括内存和数据类型两个计算机的专业概念。计算机变量的概念，如图 2.22 所示。计算机内存有众多内存单元(一般以字节为单位)，为了区分这些内存单元，为每一个内存单元指定一个编号()，这些编号称为内存的地址。编号的编码方法有很多，读者可将内存地址简单理解为一个自然数。每个计算机变量对应内存中地址连续的一组存储单元，构成一块内存区域，这块内存区域称为变量的内存。称内存区域在内存中的开始地址为首地址，称内存区域包含的内存单元个数为偏移。通常用首地址和偏移表示一块内存区域在内存中的位置和大小。为了便于计算和存储，必须为每个计算机变量指定一个数据类型。数据类型的作用有两个，第一、指定了计算机变量对应内存区域的大小，即从变量的首地址开始多少个字节，第二，指明这个变量是用于存储自然数、整数还是实数。变量的内存图形象地描述了计算机变量及数据在内存中的状态。为了便于初学者理解，用“长度”替换了“偏移”这个计算机术语。变量名长度数据类型首地址变量值图 2.22 计算机变量的概念16位unsigned short3图 2.23 变量 a 的内存图在定义计算机变量时，必须同时指定一个变量的变量名和数据类型，也可以指定变量的值。如定义一个存储自然数的变量unsigned short a = 3;定义了一个变量 a，数据类型为无符号整数(unsigned short)，内存大小为 16 个二制位，用于存储 0 到 216-1 之间的一个自然数。可用图形表示定义的变量 a，这种图称为变量的内存图。变量 a 的内存图如图 2.23 所示。语句“unsigned short a = 3”中，“=”表示初始化，即给定义的变量指定一个初始值。这条语句的语义为：在内存中为一个变量分配两个字节(16 位)的存储空间，变量取名为 a，并初始化为 3。简单说，就是定义一个 unsigned short 类型的变量 a，并初始化为 3。但需要注意的是，变量 a 的值“3”，是自然数，没有正号(+)。内部资料 严禁外传22下面定义一个存储整数的变量short int b = 3;short int c = -5;定义了 short int 类型的变量 a 和 b，内存大小为 16 个二进制位，可存储-215 到 215-1 之间的一个整数。存储整数的变量内存图，如图 2.24 所示。c16位short int首地址-5b16位short int首地址+3图 2.24 存储整数的变量内存图2. 标识符和关键字程序员需要给使用到的每个变量命名，变量名为通用的说法，专业的说法为“标识符”。标识符是由字母、数字、下画线(_)组成，并且第一个字符必须是字母或下画线，不能为数字。大多数计算机语言会区分大写和小写字母，即将大写和小写视为不同的字母，如C/C++等，但也有些计算机语言不区分大写和小写字母，将大写和小写视为相同的字母。标识符一般分为关键字、预定义标识符和用户标识符。关键字也称系统保留字，是一类特殊的标识符，在计算机语言中有专门的含义，是一个计算机语言的基本符号，决不允许另作他用。预定义标识符是为了程序员使用方便而预先定义的标识符，也指定了特定的含义，最好不要重新定义或另作他用。用户标识符是用户根据自己需要而定义的标识符，可用来命名变量、常量、函数等。程序中使用标识符命名变量、常量、函数，命名的规范性非常重要，会严重影响程序的可读性和可靠性，命名的规范性也能反映出一个程序员的编程素质。在 C++的标准文本 ISO/IEC 14882:1998(E)中，共保留了 63 个关键字，如表 2.2 所示，这些关键字都是英语中的常见单词，很好地体现了其在计算机语言中的含意，提高了程序的可读性。C++ ISO/IEC 14882:1998(E)关键字，如表 2.2 所示。表 2.2  C++ ISO/IEC 14882:1998(E)关键字asm do if return typedefauto double inline short typeidbool dynamic_cast int signed typenamebreak else long sizeof unioncase enum mutable static unsignedcatch explicit namespace static_cast usingchar export new struct virtualclass extern operator switch voidconst false private template volatile内部资料 严禁外传23const_cast float protected this wchar_tcontinue for public throw whiledefault friend register truedelete goto reinterpret_cast try3. 定义变量变量涉及的运算主要有三个，包括定义变量、从变量取值以及将数据存储到变量。 定义变量的基本语法格式为： 数据类型  变量名列表; 其中，分号(;)表示一条语句结束。 给变量命名应采取“见名知意，常用从简”的基本原则。除此之外，还有很多种流行的命名规范可供同学们参考。例如，在银行程序中，需要为余额、存款、取款交易次数和支票号码定义变量。//银行程序变量定义float balance;  //分配float类型规定的4个字节(32位)内存，命名为balancefloat deposit;  //分配float类型规定的4个字节(32位)内存，命名为depositfloat withdraw;  //分配float类型规定的4个字节(32位)内存，命名为withdrawint transaction_count; //分配int类型规定的4个字节(32位)内存，命名为transaction_countint check_number; //分配int类型规定的4个字节(32位)内存，命名为check_number其中，余额、存款和取款都是币值，常用实数表示，依次定义了 balance、deposit 和withdraw 三个 float 类型的实型变量，交易次数和支票号码都用整数表示，依次定义了transaction_count 和 check_number 两个 int 类型的整型变量。定义的银行程序变量，如图 2.25 所示。check_numberint首地址transaction_countint首地址float首地址depositwithdrawfloat首地址balancefloat首地址图 2.25 定义的银行程序变量“//”表示注释，语义为：从“//”开始到本行结束之间的所有字符为注释，其作用是增加程序的可读性。注释是给给程序员阅读的，在编译时会忽略这些信息，因此，如果从源程序中删除注释，不会对程序功能产生任何影响。内部资料 严禁外传24程序的可读性，是判断一个程序质量高低最重要的指标之一，在程序中给语句写注释，是程序员的重要工作之一。可将上面五条语句改写为如下两条语句，其语义完全相同。//银行程序变量定义float balance, deposit, withdraw;int transaction_count, check_number;在语句 float balance，deposit，withdraw 中，用逗号“，”分隔变量名，语义为依次定义balance、deposit 和 withdraw 三个 float 类型的变量。同样，定义了 transaction_count 和 check_number 两个 int 类型的变量。在定义的同时，可以给变量指定一个初始值，称为变量的初始化。例如：unsigned short width = 5;其中，unsigned short 是 unsigned short int 的缩写，表示数据类型。在变量名后用“=”为所定义变量指定初始值 5。完整的语义为：分配两个字节的内存，命名为 width，按照16 位无符号数格式存取数据，并初始化为十进制无符号数 5。变量 width 的内存图，如图 2.26 所示。5unsigned short width图 2.26 变量 width 的内存图在定义时也可以初始化多个变量。 例如：1ong width = 7, length = 7;double area, radius = 23;第 1 条语句 long width=7，length=7 的语义为:分配 4 个字节的内存，按照 32 位补码格式存取数据，命名为 width，并初始化为十进制整数 7；分配 4 个字节的内存，按照 32 位补码格式存取数据，命名为 length，并初始化为十进制整数 7。第 2 条语句 double  area，radius=23 的语义为:分配 double 类型规定长度的内存，按照 double 类型规定的格式存取数据，命名为 area；分配 double 类型规定长度的内存，按照 double 类型规定的格式存取数据，命名为 radius，并初始化为十进制实数 23。2.3.2 赋值运算数学中的代数式包含大量字母，一个代数式规定了一个计算步骤。为了简化计算，一般先采用运算规则化简代数式，然后将每个字母符号对应的数值“代入”字母符号所在的位置，最后计算出代数式的值。如简化一个代数式2a+2b=2(a+b)简化了 2a+2b 代数式，减少了一次乘法运算。如果 a=1、b=2，可将 a、b 的值“代入”2(a+b)，计算 2(1+2)。又如一个函数(, ) = 2 + 3内部资料 严禁外传25计算 f(2,3)的值时，将 2 和 3 分别“代入”2x+3y 中的 x 和 y，计算 2×2+3×3 得到f(2,3)的值 13。需要注意的是，前面两个式子都用了等号“=”，但在 2a+2b=2(a+b)中，“=”表示演算过程中的两个算式相等，而在 f(x,y)=2x+3y 中，“=”表示函数中的映射，二者的含义不同。如，用一个字母 z 表示函数值，可将前面的函数改写为 = 2 + 3“=”的含义为将数对(x,y)的一个值映射到 z 的一个值，在计算时，将 x、y 的值分别代入 2x+3y，然后计算出一个值，这个值就是函数 f 映射到的值。在计算机中，将 = 2 + 3中的字母 x、y、z 都视为变量，分配相应的内存，并假设自变量 x、y 的值已存储到变量的内存。计算机在计算函数值时，先从变量 x、y 中分别取出其值，并按照表达式规定的计算序列计算表达式，然后再将计算结果存储到变量 z 的内存，从而实现了函数 f 的映射。可将上面计算函数值的过程分为两步，第一步，计算表达式(前面已学习)，第二步，将表达式的值映射到函数的因变量。按照这个思路，计算机语言专门设计了一个运算，将一个表达式的值映射到函数的因变量，这个运算就是赋值运算，其运算符号为“=”。数学公式中的等号=是函数映射 ，赋值运算实现了数学中函数映射。 使用‘=’表示赋值运算，是因为赋值运算的使用频率非常高，为了减少程序员的打字工作量，就规定用字母‘=’代表赋值运算，表示数学中的函数映射，而用‘==’代表数学中的相等，表示两个数的比较。这种书写方式已经打破了中学中对算术运算的认知，需要特别注意，决不能将赋值运算符‘=’ 读成“相等”或“等于”。赋值运算符‘=’应读作“赋值”，其含义为映射，或存入 在内存中，存数据和取数据是与变量紧密相关的，是变量隐含的两项基本操作，赋值运算实现了对变量的存取操作。例如：unsigned short  y,x;x = 5; //将自然数5赋值给变量xy = x; //取出变量x中的值，然后再赋值给变量y第1条语句定义了两个变量x和y，第2条语句x = 5的功能为，自然数5赋值给变量x，第3条语句y = x的功能为，取出变量x中的值，然后再赋值给变量y。后面两条语句实现了数学函数x = 5和y = x定义的映射。值得注意的是，变量初始化和赋值运算都使用了符号“=”，在大多数情况下，变量初始化与赋值运算在功能上相同，比如上面的第二条语句。但在个别情况下，其表示的含义完全不同，比如初始化静态变量，因此需要区分初始化与赋值运算。1. 赋值运算的语义赋值运算语法语义，如表 2.3 所示。表 2.3 赋值运算语法语义运算符 名称 结合律 语法 语义或运算序列内部资料 严禁外传26= 赋值运算 从右到左 expL=expR计算 expL 得到变量x，计算 expR 得到值v，将值v转换为变量x的类型规定的存储格式，并存到变量x的内存，得到变量x赋值运算的语法为“expL=expR”，其作用是将表达式 expR 的值存储到 expL 的内存中。赋值运算的语义(或运算序列)为“计算 expL 得到变量 x，计算 expR 得到值 v，将值 v 转换为变量 x 的数据类型规定的存储格式，并存到变量 x 的内存，得到变量 x”。赋值运算=的语义，如图 2.27a 所示，=av:1b:1+1bv:1bb+1av:1=expRvxvxvexpLxa.赋值运算=的语义                   b.表达式 b=a 的语义图 2.27 赋值运算的语义赋值运算规定，左边表达式“expL 的计算结果必须是一个变量 x，赋值运算的运算结果是变量 x，而不是变量 x 中的值 v，需要特别注意。表 2.3 中的语义，采用半形式化的方法描述，以方便借用数学中的“代入”对语义进行变换和简化。例如：short int a = 1, b, c;b = a;  //从变量a的内存中取出值1，再存放到变量b的内存中c = a + b;  //从变量a取出值1，从变量b取值1，1加1得2，将2存入变量c的内存第 2 条语句 b = a 是一条表达式语句，其语义为从变量 a 中取出值 v，将值 v 存储到变量 b 的内存，得到变量 b。程序运行时，将其中的 v 用实际的变量值+1 替换，其实际运行过程为：从变量 a 中读取出值+1，将值+1 存储到变量 b 的内存，得到变量 b。表达式 b=a的语义，如图 2.27b 所示。第 3 条语句 c= a+b 也是表达式语句，其语义是从变量 a 中取出值 v1, 变量 b 取出值v2, v1 加 v2 得到值 v，直接将值 v 存储到变量 c 的内存，得到变量 c。表达式 c= a+b 的语义，如图 2.28 所示。+bv2:1v3:2+1bv:1av1:1+1av:1=ccc+2v3:2c图 2.28 表达式 c= a+b 的语义当一个变量在赋值运算“=”左边时，其代表变量的内存，用于存储数据，对应的变量操作为存操作，称为变量的“左值”；当一个变量在赋值运算“=”右边时，其代表变内部资料 严禁外传27量的值，对应的变量操作为从变量的内存中取值，称为变量的“右值”。2. 复合赋值运算算术运算都有一个计算结果，而这个计算结果常常需要存储到一个变量中。 例如 a=a*2，其语义为从变量 a 中取出值 v1，v1*2 得到值 v2，将 v2 存储到变量 a，这个语义共包括了 3 个步骤。*2v2av1=av2av12a*=a*2将2乘到变量av1*2v1a①②①③a. a=a*2                             b. a*=2图 2.29 复合赋值减少了运算序列程序员在繁重的编程过程中总结出了另一种更加简单的思考方式，即将 2 乘到变量a，将原来的 3 步变成了一步，这种思考方式最终被广泛接受并写进了 C/C++语言的标准，增加了复合赋值运算。复合赋值减少了运算序列，如图 2.29 所示。在赋值运算符‘=’之前加上一个运算符，构成一个复合的运算符，以标识一个复合赋值运算。复合赋值运算语法语义，如表 2.4 所示。表 2.4 复合赋值运算语法语义运算符 名称 结合律 语法 语义或运算序列*=Multiplicationassignment从右到左 expL*=expR计算expL得到数值类型的变量x，计算expR得到数值v，将数值v乘到变量x，得到变量x/=Divisionassignment从右到左 expL/=expR计算expL得到数值类型的变量x，计算expR得到数值v，变量x除以数值v，得到变量x%=Modulusassignment从右到左 expL%=expR计算expL得到整型变量x，计算expR得到整型值v，对变量x按值v取模，得到变量x+=Additionassignment从右到左 expL+=expR计算expL得到数值类型的变量x，计算expR得到数值v1，将数值v1加到变量x，得到变量x–=Subtractionassignment从右到左 expL-=expR计算expL得到数值类型的变量x，计算expR得到数值v，从变量x减去数值v，得到变量x复合赋值运算的优先级和结合性与赋值运算相同，运算的结果是左边的变量。需要注意的是，复合赋值运算是一个整体，在语义上是一步操作而不能分成多步，目的是减少程序员的负担。内部资料 严禁外传28vexpLx+=x+v将vl加到变量av1aexpR图 2.30 复合赋值运算+=的语义复合赋值运算+=的语义，如图 2.30 所示，计算 expL 得到数值类型的变量 x，计算expR 得到数值 v1，将数值 v1 加到变量 x，得到变量 x。",
    "2.4 整型 ": "整型是计算机使用最多的数据类型，没有之一。程序员在编程时需要理解计算机内部存储整数的方法，并保证计算的正确性。计算机中都使用二进制来存储自然数和整数，并使用不同的内部存储形式。自然数使用数学上的自然数记数法，没有符号，全部都是数字，而整数一般采用补码，最高位表示整数的符号，其余位数为数字。2.4.1 理解整数与进制进制是一种记数的方法，日常生活中主要用到十进制，计算机中使用二进制。程序员不仅需要熟悉十进制、二进制，还需要熟悉八进制和十六进制。在X数轴上表示皮亚诺公理定义的整数，X数轴上的每个点唯一对应一个整数，可用不同的进制表示这些整数。整数及其表示方法，如图 2.31所示。 0是X数轴上的一个点，将X数轴分为左右两边，0的后继0’是X数轴上右边的第一个点，0的后继的后继0’’是右边的第二个点，以此类推，用右边的点依次表示所有正整数，同样，0的前继’0是左边的第一个点，0的前继的前继”0是左边的第二个点，以此类推，用左边的点依次表示所有负整数。0’’01234560’0’’’’0’’’0’’’’’0’’’’’’0-3-2-1’’’0’0’’0十进制二进制八进制十六进制011011100101110x2711011331B0123456012345678910111271011 121314789ABCDEF131415161516172010图 2.31 整数及其表示方法在X轴的下面，先用十进制表示了整数，然后分别用二进制、八进制和十六进制表示内部资料 严禁外传29了自然数。自然数包括正整数和0，整数还包括负整数，是两种不同的数集。自然数在记数法上只有数字部分，而整数不仅有数字部分，还在数字部分的前面增加了一个符号(正号常省略)，是两种不同的记数法。整数的十进制记数法的一般形式为±dndn-1…d1d0其中di为0123456789中的一个数字。无论采用十进制还是二进制、八进制或十六进制来表示一个数，数字可能不同，但在坐标上对应的点肯定是相同的，是同一个点。1. 整数字面值编程时，除了使用变量来管理数据外，常常需要直接使用整数。在C/C++中，程序可以录入用十进制、八进制和十六进制数表示的整数，规定用非0数字开头的数字序列表示十进制数，0开头的数字序列表示八进制数，0X或0x开头的数字和ABCDEFabcdef序列表示十六进制数。例如：int a = 23;     //十进制数long int b = 02345;   //八进制数unsigned int c = 0x79fa;     //十六进制数像上面这样的整数字面值将默认为int型整数，即signed int型。如果要表示unsigned int或者long int则可以在整数字面值后面加U或L，大小写都可以，例如：long b = 02345L;    //long intlong c = 235u + 123u;      //unsigned int为了便于读者理解，主要用十进制数来讨论数在计算机中的存储方法。2. 自然数的固定位数表示法为了方便内存管理，节约内存资源，计算机中使用固定位数的二进制数来存放和处理数据场景的需要，常用二进制位数有 8 位、16 位、32 位、64 位。在固定位数中，无论高位的数值是否为 0，都要写出来，这与人们的常识有很大区别。人们在使用十进制数时，如最高位为 0，往往不会写在纸上，例如，我们往往只将 010写成 10。只有在很少的情况下，如写支票时，才被要求在高位写上 0，或作一个标记。固定位数是通过模运算实现的，下面先介绍模(mod)运算。 模(mod)运算定义在自然数集上，两个整数之商的余数就是运算的结果，记为a mod b其中 a，b 为自然数，mod 为运算。运算的结果为除法的余数，也形象地称为求余或者取模。模运算涉及的除法是自然数集上的除法，不是实数集上的除法，16 mod 3 的运算结果是 16 除 3 的余数 1。取余运算和除运算的计算方法，如图 2.32 所示。内部资料 严禁外传30图 2.32 取余运算和除法运算的计算方法模运算能够将任意一个自然数映射到一个固定大小的区间，如，x mod 8 将 x 的值映射到 0 到 7 区间，如图 2.33 所示。这个特点非常重要，它不仅在计算的内部使用，也被广泛应用到实际编程中。0123456-3-2-1x78数的范围-4+1图 2.33 x mod 8 将 x 的值映射到 0 到 7 区间模运算不仅在数学中具有重要地位，而且是计算机的理论基础。 使用固定位数时，为了保证加法、减法和乘法的完备性，都对其计算结果取模，计算公式如下：(x+y) mod 2n(x-y) mod 2n(x×y) mod 2n其中，n 表示的是二进制的位数。 例如(255+1) mod 28=(255+1) mod 256=0 (255+2) mod 28=13. 整数的表示方法整数表示的核心问题是要解决负数的表示。利用图 2.34 所示的特性，容易找到满足(x + y)mod 2 = 0等的两个自然数。如果 x 和 y 都是自然数，且满足0 ≤ x < 2，0 ≤ y < 2，则(x + y)mod 2 = 0成立只有两种情况，一种为(x + y) = 0，另一种为(x + y) = 2。第一种情况，x 和 y 必为 0，不讨论，第二种情况，假设x < ，变形为 = 2  x，因此，可用 x 表示正整数，用2  x表示负 x。当用 8(23)取模时，总共有 8 个自然数，用自然数 0、1、2、3 分别表示正整数 0、1、2、3，用自然数 4、5、6、7 分别表示负整数-4、-3、-2，-1。x mod 23 时用自然数表示整数的方法，如图 2.34 所示。515116/3=516%3=1a/b所得的余数。整数相除得整数计算器结果是5.333333但在整数除法中，小数部分被舍弃！163内部资料 严禁外传310123456-3-2-1x78自然数-4整数+14567图 2.34 用自然数表示整数的方法如图 2.34 所示，用(0,22-1]中的自然数表示正整数，用[22,23-1]中的数表示负整数。 推广到对 2n 取模，用(0,2n-1-1]中的自然数表示正整数，用[2n-1,2n-1]中的自然数表示负整数，对任意固定位数的正整数 x，显然有x+(2n-x)= 2n(x+(2n-x))mod 2n=0则对 2n 取模时求-x 的公式为-x=2n-x按照这种方法，程序员可以使用上面的公式，采用十进制求出任意正整数的负数。 例如：对 28 取模时用(0,127]中的自然数表示正整数，用[128,255]中的数表示负整数。-1=(28-1)自然数=(255) 自然数 -6=(28-6)自然数=(251) 自然数-128=(28-127)自然数=(128) 自然数对 28 取模时，用自然数 255 表示最大的负整数-1，自然数 251 表示整数-6，自然数128 表示最小的整数-128。例如：对 216 取模时用(0, 32767]中的自然数表示正整数，用[32768, 65535]中的数表示负整数。-1=(216-1)自然数=(65535) 自然数 -6=(216-6)自然数=(65530) 自然数-32768=(216-32768)自然数=(32768) 自然数对 216 取模时，用自然数 65535 表示最大的负整数-1，自然数 65530 表示整数-6，自然数 32768 表示最小的整数-32768。上面的示例，使用了十进制表示自然数和整数，实际上，求出任意正整数负数的公式是与进制无关的，可将其推广到 R 进制，对 Rn 取模，求-x 为-x=Rn-x计算出的-x 是一个自然数，因此，在对 Rn 取模的情况下，可以使用加法来进行减法运算，将整数的加法和减法统一为自然数的加法运算，其计算公式为(x-y) mod Rn = ( x+(-y) ) mod Rn计算机按照上述的原理针对二进制设计了补码，并用自然数的加法运算实现了整数的加减法运算。在错误!未找到引用源。节中将专门讨论补码。2.4.2 整数的数据类型客观世界中存在着各种各样的数据，计算机对不同类型的数据采用不同的二进制表示方法。为了区分不同的表示方法，引入了数据类型的概念，用以表示客观世界中的数据与内部资料 严禁外传32二进制之间相互转换的具体方法以及所需的内存大小。在C/C++中， signed和unsigned分别区分的是整数和自然数，signed称为有符号整数，unsigned称为无符号整数。如果没有指定是有符号整数还是无符号整数，则编译器自动默认为有符号整数。整数的常见数据类型，如表2.5所示。按所需内存大小进行分类，整型常用的长度有8位、16位、32位，在C/C++中，分别用char、short int、long int来表示。随着计算机的发展，整型的位长也在增加，如64位、128位等。查阅语言或编译器的手册，可了解具体规定。表 2.5 整数的常见数据类型二进制位数 有符号整数(整数) 无符号整数(自然数)8位 signed char unsigned char16位 signed short int unsigned short int32位 signed long int unsigned long int字长 signed int unsigned int例如unsigned short a = 3;定义了一个变量 a，数据类型为无符号整数(unsigned short int，其中 int 可省略)，用来存储自然数，内存大小为 16 个二进制位，只能存储 0 到 216-1 之间的数。这条语句的功能是定义一个 unsigned short 类型的变量 a，并初始化为 3，其运算序列为，在内存为一个变量分配两个字节(16 位)的存储空间，变量取名为 a，并初始化为 3。16位unsigned short首地址00000000 00000011a图 2.35 无符号整型变量 a 中存储的二进制串a16位unsigned short33unsigned short a3unsigned short a图 2.36 无符号整型变量 a 中存储的自然数计算机在运行程序时，才为变量 a 分配 16 个二进制位长度的内存空间，并将自然数 3转换为二进制串 00000000 00000011，然后存储到分配的内存区域。无符号整型变量 a 中存储的二进制串如图 2.35 所示。为了方便，在变量的内存图中，可用十进制表示变量的值，但需要注意的是，其中的值“3”是自然数，不能有正号(+)。无符号整型变量 a 中存储的自然数，如图 2.36 所示。图 2.36 中，还给出了两种简化的变量内存图，它们表达的意思相同，可根据具体情况选用其中一种。例如short int a = 3;其中，short int 为 signed short int 的简写，signed 单词的意思为带符号。数据类型signed short int 规定使用 16 个二进制位存储整数的补码。存储格式为14 … 10，其中，最高位 s 为符号位，0 表示正数，1 表示负数，0 到 14位14 … 10表示数字，总共 15 位，存储的整数范围为215到215  1。内部资料 严禁外传33+3signed short a a16位signed short首地址00000000 00000011图 2.37 有符号整型变量 a 中存储的补码和整数语句 short int a = 3 定义了一个有符号整型变量 a，并初始化为+3。变量 a 的内存中实际存储的是其补码 00000000 00000011。特别注意，补码的最高位为符号位，0 表示正整数，这与 unsigned short 类型不同。有符号整型变量 a 中存储的补码和整数，如图 2.37 所示。C/C++为整数提供了比较丰富数据类型，以适合不同的场景，但每种数据类型有自己的内部存储格式，可编程观察整数内部存储格式，代码如例 2.1 所示。【例 2.1】整数内部存储格式。#include <iostream>#include <iomanip>using namespace std;void main(){unsigned short us = 65535;signed short ss = -1;long l;l = us; //无符号位，高位补 0cout << \"unsigned long   :\";cout << setw(8) << hex << l << \",\" << setw(8) << dec << l << endl;l = ss; //符号扩展，高位补 1cout << \"signed long   :\";cout << setw(8) << hex << l << \",\" << setw(8) << dec << l << endl;}unsigned short us65535signed short sslong l-1-1\"unsigned long   :\"\",\"\"signed long   :\"\",\"unsignedlong:ffff,65535signedlong:ffffffff,-1_运行中的内存和输出结果包括三个部分，第一部分是右上角的全局数据区，用于存放字符串常量，操作系统在程序运行前会将程序中的\"unsigned long:\"、\",\" 、\"signed long:\"、\",\"等字符串常量存入分配的内存空间中，需要注意的是，这些内存单元不一定是连续的，因此画出的几个内存单元并没有紧挨在一起；第二部分是左边的内存区域，用于存放变量；第三部分是右下角的屏幕区域，用于显示程序的输出结果。内部资料 严禁外传34程序中定义了变量 us 和 ss，变量 ss 的数据类型为有符号短整型(signed short int)，用自然数 216-1 表示整数-1，216-1 刚好就是 65 535，因此两个变量在内存中存储的都是 65 535，对应的二进制就是全 1。例 2.1 程序中的如下代码分别按照十六进制和十进制输出变量的值。cout << \"signed long   :\";cout << setw(8) << hex << l << \",\" << setw(8) << dec << l << endl;其中 setw(8)中的 setw 为 setwidth 的缩写，语义为设置显示宽度，setw(8)的语义为设置显示宽度为 8 个字符。hex 的语义为设置为十六进制，后面以十六进制显示变量 l 的内存中存储的二进制串。dec 的语义为设置为十进制显示。endl 为回车换行。其中输出结果为：unsigned long : ffff, 65535;变量 l 中存储的仍然是十进制数 65535，但内部存储的是“0000 ffff”。从这个显示结果中，充分体会了十六进制的优越性。例 2.1 程序中的如下代码，先将变量 ss 的值赋值给变量 l，然后分别以十六进制和十进制输出变量的值。l = ss; //符号扩展，高位补1cout << \"signed long   :\";cout << setw(8) << hex << l << \",\" << setw(8) << dec << l << endl;变量 ss 和 l 都是有符号整型，但长度不同，需要从 16 位扩展到 32 位，将-1 的内部表示 216-1 转换为 232-1，将 232-1 用二进制表示出来就是 32 个 1。使用符号扩展有符号数的位数，如图 2.38 所示。l32位signed long int首地址11111111 11111111 11111111 11111111图 2.38 使用符号扩展有符号数的位数屏幕上的输出结果为：signedlong:ffffffff,-1_变量 l 中存储的仍然是十进制数-1，但内部存储的是“ffff ffff”。  前面用字母 l 来命名变量，容易与数字 1 混淆，因此，坚决不要使用字母 l 单独命名变量。字长是描述计算机处理能力的最主要指标，它表示计算机处理器(CPU)一次处理数据的二进制位数，如在 32 位机上进行一次 32 位的加法运算，其花费的时间不比进行一次 16 位的加法运算长，也不比进行一次 8 位的加法运算长，因此，为了充分发挥计算机的处理能力，并且保证程序的兼容性，大多数计算机语言提供了通过计算机字长来指定整数位数的功能。在 C/C++的标准文本中，没有规定 int 类型的位数，让编译器按照计算机字长来指定内部资料 严禁外传35int 类型的位数，以提高代码的运行效率，因此，在对整数位数没有具体要求的场景下，强烈推荐使用 int 类型。2.4.3 自增和自减运算自增和自减是程序员非常喜欢的运算，自增和自减运算语法语义，如表 2.6 所示。表 2.6 自增和自减运算语法语义运算符 名称 结合律 语法 语义或运算序列++ 后自增(后++) 从左到右 exp++计算exp得到变量x，将1加到变量x，返回原来的值v-- 后自减(后--) 从左到右 exp--计算exp得到变量x，将变量x减1，返回原来的值v++ 前自增(前++) 从右到左 ++exp 计算exp得到变量x，将1加到变量x，得到变量x-- 前自减(后--) 从右到左 --exp 计算exp得到变量x，变量x减1，得到变量x自增和自减运算区别于其他非赋值运算的地方在于，它的操作对象必须是变量，自增运算后，变量的值增加 1，自减运算后，变量的值减少 1。自增和自减运算有前增量和后增量之分，一是操作数在后操作符在前，俗称前++或前--，另一种是操作数在前操作符在后，俗称后++或后--。前++或前--运算后，得到的是变量，而后++或后--运算后，得到的是变量中原来的值。这两种形式的区别初学者往往会混淆，需要深入掌握。1. 前++和前--在实际编程中，常常要将 1 加(减)到一个变量，如 a+=1。为了在编程时输入更少的字符，计算机语言专门定义了两个运算，分别表示“+=1”和“-=1”，称为前自增和前自减。因在语法上运算符在操作数的前面，因此，俗称前++和前--运算。++expx:vx:v+1vx+1图 2.39  前++的语义前++的语法为++exp，其语义完全等价于“exp+=1”，其优先级非常高，这样不需使用括号来提高其优先级，写出的表达式会更加简洁。前++语义，如图 2.39 所示。前++与前--的语法、语义都非常类似，只是一个是减，一个是加。 下面以前++为例，介绍前++与前--的使用方法。示例代码如例 2.2 所示。 【例 2.2】前++示例。#include <iostream>#include <iomanip>using namespace std;内部资料 严禁外传36void main(){int a = 0, b;b = ++a;//将 1 加到变量 a,得到变量 a;从变量 a 中，取出值 1，赋值给变量 bcout << a << \" , \" << b << endl;++a = 0;  //(++a)的结果为变量 acout << a << endl;b = (a = a + 1); //从变量 a 中取出 0，0+1 得 1，将 1 存到变量 a,得到变量 acout << a << \" , \" << b << endl;}程序的难点在于 b = ++a、++a = 0 和 b = (a = a + 1) 三个表达式语句，其中，表达式 b= ++a 的语义，如图 2.40 所示。++aa:va:v+1va+1=bv+1bb图 2.40 表达式 b = ++a 的语义三个表达式的计算顺序，如图 2.41 所示。①b =    (a =   a + 1)②③intintint b:1a:1++a  = 0int a:2inta:0①②intb =  ++a①②a:1intb:11图 2.41 三个表达式的计算顺序例 2.2 程序的内存状态和输出结果：int a1int b1\",\"\",\"1，101，1_“++a”和 “a = a + 1”的结果完全一样，但“++a”只需要程序员思考一步，而“a = a + 1”需要思考三步，脑力劳动相差三倍，这就是程序员喜爱自增自减的原因。2. 后++和后--前++和前--的运算结果都是变量，变量中存储的是计算后的值，但有时需要使用计算内部资料 严禁外传37前的值进行后面的运算。为了满足这个编程需求，又定义了后++和后--两个运算。++expx:vvvx+1图 2.42 后++的语义在语法上，为了与前++区别，后++规定将运算符放在操作数的后面，即 exp++。在语义上，前面两步“计算 exp 得到变量 x，将 1 加到变量 x”与前++完全相同，但后++“返回原来的值 v”，而不是变量 x。后++的语义，如图 2.44 所示。下面通过示例来演示前++和后++的使用方法，代码如例 2.3 所示。 【例 2.3】前++和后++示例。#include<iostream>using namespace std;void main(){int a = 3, b, c;b = ++a;cout << a << \"   \" << b << endl;c = a++;cout << a << \"   \" << c << endl;}例 2.3 程序的内存状态和输出的结果为：int a5int bint c44\"\"\"\"4454_表达式 b=++a 的语义和计算过程，如图 2.43a 所示，运行 b=++a 后，变量 a 的值为4，变量 b 的值为 4。表达式 c=a++的语义和计算过程，如图 2.43b 所示，运行表达式 c = a++后，变量 b 的值为 4， 变量 c 的值为 4，变量 a 的值为 5。++aa:444+1a+1=c4cc++aa:3a:43+1a+1=b4bba.表达式 b=++a 的语义和计算过程                         b.表达式 c=a++的语义和计算过程图 2.43 表达式 b=++a 和 c=a++的语义和计算过程内部资料 严禁外传38下面通过示例来演示前--和后--的使用方法，代码如例 2.4 所示。 【例 2.4】前--和后--示例。#include<iostream>using namespace std;void main(){int a = 3;int b = --a;cout << a << \"   \" << b << endl;int c = a--;cout << a << \"   \" << c << endl;}例 2.4 程序的内存状态和输出结果为：int a1int bint c22\"\"\"\"2212_赋值和自增自减运算都会改变变量的值，在一个表达式中可以出现多次，可以在一个表达式中多次修改多个变量的值，但这会导致程序的可读性变差，甚至出现语义混乱，因此，建议在一个表达式中最多对一个变量修改一次值，绝不要在一个表达式中多次修改一个变量的值。",
    "2.5 字符型 ": "在计算机中，不仅要进行数的计算，还需要处理大量文字信息。在英文中，构成文字的基本要素为字母，在中文中，构成文字的基本要素为字，构成文字的字母或字，称为字符。计算机要处理文字信息，首先要解决的问题是在计算机中怎样表示和存储构成文字的字符。从本质上讲，计算机中只能存储和处理二进制串，只能存储和处理整数，因此，不能直接存储和处理文字信息中的字符。解决这个问题的方法为，在字符的集合和自然数之间建立一个映射，用一个自然数唯一表示一个字符，；计算机存储和处理这些自然数。一般用表格形式表示字符和自然数之间的映射，就形成一个表示字符与自然数对应关系的表格，称这种表为字符表，也称为字符集。2.5.1 字符集目前的文字有很多种，构成各种文字的字母或字也不一样，这就需要针对不同的文字建立不同的字符集，另一方面，针对同一种文字，也可能有不同编码方法，这样就产生了很多字符集。内部资料 严禁外传39下面只介绍 ASCII 码和国标码两种常用的字符集，读者可自行查阅其他字符集。1. ASCII 码ASCII (American Standard Code for Information Interchange，美国标准信息交换代码)是由美国国家标准学会(American National Standard Institute，ANSI )制定的，是一种标准的单字节字符编码方案，后来它被国际标准化组织(International Organization for Standardization， ISO)定为国际标准，称为 ISO 646 标准。ASCII 码使用 1 个字节 8 比特位对字符进行编码，分为标准 ASCII 码和扩展 ASCII码，标准 ASCII 码的最高位为 0，扩展 ASCII 码的最高位为 1。实际上，这种编码方案主要规定了标准 ASCII 码中的 128 个字符的编号，包括所有的大写和小写字母，数字 0 到9、标点符号，以及常用的特殊控制字符。扩展 ASCII 码用于扩展，用来表示附加的 128个特殊符号字符、外来语字母和图形符号等。目前主要使用标准 ASCII 码，一般不使用扩展 ASCII 码。附录 1 给出了标准 ASCII 码表，总共有 128 个字符。2. 国标码我国国家标准局于 1981 年 5 月颁布了《信息交换用汉字编码字符集——基本集》，代号为 GB2312-80，共对 6763 个汉字和 682 个图形字符进行了编码。编码原则为一个汉字用两个字节表示，前字节的编码称为区码，后字节的编码称为位码，也称为区位码，每个字节只用 7 位码，为了确保与标准 ASCII 码不冲突，将每个字节的最高位设置为 1。国标码结构，如图 2.44 所示。11区码位码图 2.44 国标码结构前面介绍了ASCII码和汉字国标码两种字符集，一个是单字节码，一个是双字节码，是目前常用字符编码的典型代表，汉字国标码使用的是ASCII码的扩展编码空间，一个汉字占用两个字节，与标准ASCII码完全兼容，因此，本教材中讨论字符型时，都采用ASCII码，但程序中也可使用汉字，汉字在内存中占用连续的两字节，每个字符相当于一个字符型变量，换句话说，一个汉字使用两个字符数据表示，占用两个字节。2.5.2 使用字符型字符型专门为存储和处理字符而设计，占用一个字节，实际上存储的是字符的编号，是一个 8 位无符号整数，可以使用整型中学习的方法使用字符型，并对字符型变量中存储的字符进行处理。1. 字符字面量在计算机语言中，字符的表示方法很简单，但为了与数字、运算符和变量名等相区别，一般规定必须用单引号('')将一个字符引起来，如， 'a'表示小写字母 a， 'B'表示大写字母内部资料 严禁外传40B， '9'表示字符 9，而不是数字 9，'+'表示字符+，而不是运算符+。下面通过示例来演示字符型的使用方法，代码如例 2.5 所示。 【例 2.5】字符型示例。#include<iostream>using namespace std;void main(){char a = 'b';     //定义一个字符变量 a，并用字母 b 的 ASCII 码初始化cout << a << \"，ASCII=\" << (int)a << endl;char c = 97;   //定义一个字符变量 b，并用整数 97 初始化cout << c << \"，ASCII=\" << (int)c << endl;}例 2.5 程序的内存状态和输出结果为：char abchar c97\"，ASCII=\"\"，ASCII=\"b，ASCII=98a，ASCII=97_char a = 'b'的语义为，定义一个 char 类型的变量 a，也就是一个 8 位整型变量，然后初始为字符‘b’，即将小写字母 b 的 ASCII 码值 98 存储到变量 a 的内存。char c = 97 中，用整数 97 初始化变量 c，整数 97 刚好是字母 a 的 ASCII 码。cout << a <<\"，ASCII=\" <<(int)a<<endl 中，执行 cout << a 时，因变量的 a 的类型为字符型，cout 从变量 a 中取出整数 98，然后输出 98 在 ASCII 码表中对应的字母 b。执行到cout << (int)a 时，因增加了一个类型转换，cout 将按照 int 类型来输出，输出变量 a 中存储的 ASCII 码值 98。在编写程序时，不仅可以用单引号('')来表示字符，也可以用其 ASCII 码值来表示一个字符。从理论上讲，使用 ASCII 码值可以表示字符集中任意一个字符，但程序员在编写程序时，需要查阅或记住字符的 ASCII 码值，因此，程序员还是喜欢使用单引号表示方式。2. 转义字符控制字符或通信专用字符，也称为不可见字符，其 ASCII 码值为 0～31 及 127，共有33 个。这些字符不能像数字、字母等字符一样在源程序中呈现出来，而是有特定的用途，换句话说，这些字符不能从键盘输入到源程序中单引号的中间。为了解决这个问题，C/C++提供了专门表示这类字符的方法，俗称转义字符(escape character)。用一个特定的字符'\\'来改变可见字符的含义，变成不可见字符。例如，换行符用'\\n'表示键盘中的回车换行(enter 键)这个字符，其中，n 为 newline 的第一个字母，程序员很好记，这就是程序员的偏爱它的原因。常用的 C/C++转义字符，如表 2.7 所示。表 2.7 C/C++转义字符字符形式 整数值 代表符号 字符形式 整数值 代表符号\\a 0x07 响铃bell \\\" 0x22 双引号内部资料 严禁外传41\\b 0x08 退格backspace \\' 0x27 单引号\\t 0x09 水平制表符HT \\? 0x3F 问号\\n 0x0A 换行return \\\\ 0x5C 反斜杠字符\\\\v 0x0B 垂直制表符VT \\ddd 0ddd 1~3位八进制数\\r 0x0D 回车 \\xhh 0xhh 1~2位十六进制数可使用整数运算处理字符类型的数据。如下例程将大写字母 A 转换为小写字母，代码如例 2.6 所示。 【例 2.6】 大小写转换。#include<iostream>using namespace std;void main(){char ch = 'A';ch += 32;cout << '\\n' << ch;}想在输出字母前输出一个空行，但因回车键不能录入到代码，就用了转义字符'\\n'。例 2.6 程序的内存状态和输出结果为：char chaa_",
    "2.6 实数型 ": "前面从自然数、整数出发，重点学习了整型和字符型两种数据类型，下面也从实数开始，学习实数型。与整型相比，实数型是比较复杂的数据类型，但不需要程序员直接管理其中的数据，而由计算机中专门的硬件来处理，因此，使用相对更加简单。2.6.1 浮点数记数法计算机中采用浮点数记数法表示和存储实数。1. 十进制浮点数记数法±0.12 …  × 10±…10内部资料 严禁外传42十进制浮点数记数法来源于实数的科学记数法，其一般形式为±0.12 …  × 10±…10其中，最高位前面为符号，0. 12 … 为小数部分，小数点后 1 位1不能为 0，± … 10为指数部分，d 和 e 为字数 0、1、2、3、4、5、6、7、8 或 9。与实数的科学记数法相比，十进制浮点数记数法要求整数部分全为 0，小数点后第 1 位非 0。根据十进制浮点数记数法，当一个十进制浮点数的符号、小数和指数部分确定后，这个数就确定了，因此，只需存储浮点数的符号、小数和指数。浮点数的存储格式，如图 2.45 所示。±小数部分指数部分图 2.45 浮点数的存储格式其中，指数部分为± … 10，小数部分为12 … 。 例如：19971400000000=+1.99714×1013=+0.199714×1014，该正浮点数存储格式，如图2.46 所示。+199714+14图 2.46 正浮点数存储格式在计算机中，为了方便，一般用 E 或 e 表示 10 的幂，如，+0.199714×1014 表示为0.199714E14。例如，-306.5=-0.3065*103，该负浮点数存储格式，如图 2.47 所示。-3065+3图 2.47 负浮点数存储格式其中，-是符号，指数 3 称为阶或阶码，0.3065 是小数部分，其左右端非 0 数字包起来的最长的数字序列称为有效值(significance)，这里的有效值是 3065。小数部分也称为尾数，如 3065 是尾数。十进制浮点记数法中，一个实数越大，指数就越大，指数的位数也就越多，同样，实数的精度越高，小数的位数就越多，反过来讲，指数的位数越多，能表示的实数就越大，小数的位数越多，能表示实数的精度就越高。2. 二进制浮点数及存储格式计算机内部使用二进制浮点数存储实数，二进制浮点数记数法与十进制浮点数类似，包括符号、小数和指数三部分，一般形式为±0. 12 …  × 2±…10其中，最高位前面为符号，12 … 为小数部分，小数点后 1 位1不能为 0，± … 10为指数部分。a 和 b 为数字 0 或 1。二进制浮点数的存储格式，如图 2.48 所示。内部资料 严禁外传43±b1 b2 bm±an a1a0符号小数指数图 2.48 二进制浮点数的存储格式国际标准 IEEE754 规定了具体二进制浮点数的存储形式，依次为符号、指数和小数三部分，并分别规定了 32 位浮点数和 64 位浮点数中指数和小数的二进制位数。32 位浮点数，符号占 1 位，小数部分占 23 位，指数部分占 8 位，用 32 位二进制位表示一个实数，所表示的实数精度较低，常常称为单精度浮点数，对应 C/C++的 float 类型。64 位浮点数，符号占 1 位，小数部分占 52 位，指数部分占 11 位，用总共 64 位表示一个实数，因所表示的实数精度较高，常常称为双精度浮点数，对应 C/C++中的 double 类型。2.6.2 实数型分类在编程实践中，实数主要用于科学计算，有关浮点数的运算算法比较复杂，时间复杂度也很高，计算机中通常有专门的硬件来处理浮点运算，一般不需要程序员深入理解浮点数在计算机内部存储和运算的机制，只需要重点关注两点，第 1 点，浮点数的大小范围，第 2 点，浮点数的精度。如果一个实数超出了浮点数的大小范围，就会发生溢出，导致不正确的结果，如果精度太小，计算结果的误差会很大，达不到实际要求。C/C++中的实数型，如表 2.8 所示。表 2.8  C/C++中的实数型类型 名称 位数 字节数 范围 有效位数float 单精度浮点数 32 4 ±3.4 × 1038 7位double 双精度浮点数 64 8 ±1.8 × 10308 15位long double 长双精度浮点数 80 10 ±1.2 × 104932 19位2.6.3 实数的字面表示浮点数既可以表示为定点方式(非指数方式)，例如 35.623，也可以表示成科学记数法(指数方式)，例如 0.35623e+02，即 0.35623 乘上 10 的 2 次方。直接写出的浮点数字面值，默认为 double 型，如果要表示成 float 型，则要在浮点数后面加上字母 F 或 f。例如：float f1 = 19.2f;float f2 = 0.192e+02;         //将double数转换为floatdouble d1 = 19.2;double d2 = 0.192e+02f;      //将float数转换为doublelong double ld1 = 19.2L;long double ld2 = 0.192e+02;  //将double数转换为long double内部资料 严禁外传442.6.4 实数型的精度和范围计算机中只能存储实数的近似值，因此，应重点关注实数的精度和大小范围。 下面通过示例来演示实数型的精度及大小范围，代码如例 2.7 所示。【例 2.7】实数型的精度及大小范围。#include<iostream>#include <iomanip>using namespace std;void main(){cout << setprecision(18) << \"Real  :\" << \"12.3456789012345678901E20\" <<endl;float f = 12.3456789012345678901E20;cout << setprecision(18) << \"float :\" << f << endl;double d = 12.3456789012345678901E20;cout << setprecision(18) << \"double:\" << d << endl;}运行中的内存和输出结果：float f12.3456789012345678901E20double d12.3456789012345678901E20\"Real  :\"\"12.3456789012345678901E20\"\"double :\"\"float :\"Real:12.3456789012345678901E20float :1.2345678252014001e+021double:1.2345678901234568e+021_从输出结果可以看出，float 和 double 输出的都是近似值，float 类型的正确位数为 8，说明 float 类型的有效位数不超过 8 位，double 类型的正确位数为 18，说明 double 类型的有效位数不超过 18 位。读者可修改 12.3456789012345678901E20 中的指数，观察各类数型的表示范围。",
    "2.7 算术类型转换 ": "在数学中，运算是定义在一个特定数集上的，与数集及相应的记数法紧密相关，而计算机中是用数据类型区分不同的数据集合，不论变量还是值都有一个特定的数据类型。自然数、整数和实数上都有加减乘除运算，但它们在不同数集上有不同的具体计算方法，在本质上是不同的运算。人具有很高的智力水平，往往会忽略它们之间的差别，但计算机没有这样高的智力水平，只能对相同数据类型的数据进行加减乘除运算。为了对不同数据类型的数据进行加减乘除运算，计算机语言专门设计了一个运算来解决数据类型的相互转换问题，这个运算称为数据类型转换。内部资料 严禁外传452.7.1 整数的数据类型转换数据类型规定了数据在计算机中的内部格式和所需的二进制位数。进行四则运算时，当两个操作数的内部格式和二进制位数相同时，才能直接运算，否则需要先进行数据类型转换。下面以 8 位有符号整数在 16 位机上进行相加为例，讨论数据类型转换。 例如signed char a = 5, b = -4, c;c = a + b;第 1 条语句，在内存中定义了 a、b、c 三个有符号整型变量，每个变量存储一个字符，其中，变量 b 初始化为-4，变量 b 的内存中存储的是-4 的补码 1111 1100。在 16 位机上执行第 2 条语句 c=a+b，包含 4 个步骤。第 1 步，从变量 a 的内存中取出值 0000 0101 到 CPU，并按照符号扩展方式扩展为 00000000 00000101；第 2 步，从变量 b的内存中取出值 1111 1100 到 CPU，并扩展为 11111111 11111100；第 3 步，两个二进制数在 CPU 中相加得到 00000000 00000001；第 4 步，将计算结果的高 8 位 00000000 扔掉(取模运算)而将低 8 位 00000001 存储到变量 c 的内存。在 16 位机上执行 c=a+b 的过程，如图 2.49 所示。InputOutputabc000001011111110000000001000001011111110000000001①②③④CPUmemory00000000 00000101 +  11111111 11111100= 00000000 00000001图 2.49 在 16 位机上执行 c=a+b 的过程在 16 位机上执行 c=a+b 时，先将 8 位整数转换为 16 位整数，然后再按照 16 位整数进行加法运算，最后将计算结果中的低 8 位存储到变量 c。在计算过程中，自动进行了三次数据类型转换。可编写程序，观察计算表达式 c=a+b 过程中各变量的内存存储数据，以及数据类型转换。整数的内部存储数据及数据类型转换代码如例 2.8 所示。【例 2.8】整数的内部存储数据及数据类型转换。#include <iostream>#include <iomanip>using namespace std;//测试整数运算中数据类型的转换void main(){signed short a = -1, b = -5, c;cout << \"a=0x\" << hex << a << \",\" << \"b=0x\" << hex << b << endl;c = a + b;cout << \"a+b=0x\" << hex << a + b << \",\"内部资料 严禁外传46<< \"c=0x\" << hex << c << endl;}例 2.8 程序在 vs 的 32 位编译器下的内存状态和输出结果为：int a-1int bint c-5-6\"a=0x\"\"b=0x\"\"a+b=0x\"\"c=0x\"a=0xffff,b=0xfffba+b=0xfffffffa,c=0xfffa_例 2.8 程序的输出结果中，a=0xffff,b=0xfffb 表明变量 a 和 b 中存储的是 16 位二进制数，a+b=0xfffffffa 表明按照 32 位二进制进行加法运算，但 c=0xfffa 表明将 a+b 的计算结果 0xfffffffa 中的低 16位 0xfffa 存储到变量 c 的内存。每个计算机的字长是衡量计算机处理能力的重要指标，目前主流个人计算机的字长为32 位或 64 位，有些单片机的字长为 8 位或 16 位。不论计算机的字长是多少，每个计算机的字长一定是固定的，即 CPU 每次运算的二进制位都是固定的，不能多，也不能少。字长为 16 位的计算机，每次加法运算都是 16 个二进制位相加，字长为 32 位的计算机，每次加法运算都是 32 个二进制位相加。如果在 16 位机上进行 8 位二进制数的加法，需要先将操作数扩展到 16 位，然后再相加，如果进行 32 位加法，则需要将 32 位拆分为两个 16 位来运算。例 2.8 所示的程序，在不同版本的编译器上编译，会有不同的输出结果，读者可以多试几种编译器，观察其输出结果，分析计算的过程，加深对计算的理解。2.7.2 算术运算的自动类型规则为了方便程序员编程，C/C++等计算机语言都提供自动类型转换功能，自动转换操作数的数据类型以满足运算对数据类型的要求。自动类型转换的一般原则为，位数少的向位数多的转换，有符号向无符号转换，整型向实数转换，以尽量保证信息不丢失，同时兼顾运算的效率。int 是 C/C++中比较特殊的整型，标准中没有具体规定其二进制位数，其二进制位数往往由编译器根据计算机的字长决定。随着计算机制造技术的发展，常用的个人计算机字长都比较长，至少是 32 位，目前常见的编译器也很多是 32 位的，也有些是 64 位的。因此，int 的长度一般都会不少于 32 位，大多数情况下都会将整型数据转换为 int 类型，这样能充分发挥计算机硬件的处理能力。内部资料 严禁外传47unsigned shortintunsigned long intsigned short intsigned long intsigned charunsigned charunsigned intfloatdoublelong double图 2.50 算术运算中数据类型的自动转换规则VS2013 中的 C++编译器，算术运算中数据类型自动转换规则如图 2.50 所示，自动对算术运算中操作数进行数据类型转换。这种数据类型转换对程序员是透明的，是隐性的，初学者往往都感觉不到它的存在，编写表达式时容易出现错误，不能计算出预期结果。例如：int a = 2, b = 4;double d = 4.0;cout << \"a/b= \"<< a / b << \",b/a= \"<< b / a <<\",a/d= \" << a / d << endl;内存状态和输出结果：int a2int bdouble d44.0\"a/b=\"\"b/a=\"\"a/d=\"a/b= 0,b/a= 2,a/d= 0.5_上述代码中，a/b 和 b/a 中的除法运算是整数集上的除法，因除法在整数集上是不完备的，a/b 的结果超出了整数范围，计算机输出不超过 a/b 的最大整数 0。a/d 中，因操作数 d 为 double 类型，计算机将另一外操作数 a 转换为 double 类型,按照实数上的除法进行计算，输出 0.5。网络中传输的数据流，图像、音频等数据，规定每个二进制位的含义，一般都用整型表示，对这类数据，应该使用固定长度的整数，甚至使用无符号的，如 char、short、long，而不应该使用 int 类型。只有进行计数或算术计算时才使用 int 类型，以充分发挥硬件的计算能力，同时提高程序的兼容性。与整型相比，实型是一个更为复杂的数据类型，其中的运算非常复杂，时间复杂度很高，因此，在编程实践中，建议能用整型就用整型，不能用整型才用实型，即优先选用整型。2.7.3 强制数据类型转换C/C++计算机语言提供了数据类型转换运算，为了与类型自动转换区分，常常称为强制内部资料 严禁外传48数据类型转换。类型转换运算()的语法语义，如表 2.9 所示。表 2.9 类型转换运算()的语法语义运算符 名称 结合律 语法 语义或运算序列( ) 类型转换 从右到左  (type) exp计算exp得到值v1，将值v1的类型显式转换成type类型,得到type类型的值v2语法比较简单，在一个表达式的前面加上数据类型并用括号“()”括起来，其语义为将表达式的值转换为指定的数据类型。类型转换的语义，如图 2.51 所示。如，(double)(2+3)，先计算(2+3)得到整型 5，然后再转换为 double 类型的 5.0。值得注意的是，整型 5 和 double 类型的 5.0 虽然在数学上相等，但计算机内部是用不同的二进制串表示的，是不同的两个“值”。(type)expv1(type)v2图 2.51 类型转换的语义数据类型转换只能转换“值”，不能转换“变量”的数据类型，如前面的示例，signed char a = 5,b = -4, c;c = a + b;可以在 c=a+b 前增加类型转换，改写为c = (signed char)((int)a + (int)b);其语义为，从变量 a 中取出 signed char 类型的值 v1，转换为 int 类型的值 v2；从变量b 中取出 signed char 类型的值 v3，转换为 int 类型的值 v4；int 类型的值 v2 加 int 类型的值v4 相加得到 int 类型的值 v5；将 int 类型的值 v5 转换为 signed char 类型的值 v6，存储到signed char 类型的变量 c。数据类型转换的过程，如图 2.52 所示。intintC = ( signed char ) ( ( int )  a  +  ( int )  b )signed charintsigned charsigned char①②③④⑤⑥⑦signed char图 2.52 数据类型转换的过程将 a 和 b 的值代入其语义，运算过程为，从变量 a 中取出 signed char 类型的值 5，转换为 int 类型的值 5；从变量 b 中取出 signed char 类型的值-4，转换为 int 类型的值-4；int类型的值 5 加 int 类型的值-4 相加得到 int 类型的值 1；将 int 类型的值 1 转换为 signed char类型的值 1，存储到 signed char 类型的变量 c。带类型转换的运算序列，如图 2.53 所示。内部资料 严禁外传49av1:+5v2:+5=c:v6:+1v6:+1cv6+bv3:-4v4:-4v5:+1(signed char)(int)(int)v6:+1图 2.53 带类型转换的运算序列数据类型及其转换是程序员不能回避的问题，在编写和理解表达式时要需要特别关注。",
    "2.8 计算表达式的方法 ": "在计算表达式过程中必须考虑数据类型和，在 2.1.4 中计算表达式的基本方法中需要增加数据类型转换，其计算步骤增加到 3 步：第 1 步，确定表达式的运算顺序，第 2 步，标注数据类型，第 3 步，计算表达式的值。例如，带数据类型转换的表达式。char c;int i;unsigned int u;float f;double d,y;y=c * i + f * d + f / u - (i % 2 - d);上面的表达式中的变量涉及几种不同的数据类型，在计算过程中需要在多种数据类型之间进行类型转换。2.8.1 确定表达式的运算顺序依照 2.1.4 中学习的方法，确定表达式 y=c*i+f*d+f/u-(i%2-d)的计算顺序，如图2.54 所示。y = c    *    i    +    f    *    d     +    f    /    u    -    (   i    %    2    -    d   )①②③④⑤⑥⑦⑧⑨图 2.54 表达式 y=c*i+f*d+f/u-(i%2-d)的计算顺序根据表达式 y=c*i+f*d+f/u-(i%2-d)的计算顺序，可推导出其运算序列，如图 2.55 所示。内部资料 严禁外传50v1v2v4v5v3v6v7v8v9v10v112v12v14v13v15v16ycifd**①②fui+③*④*⑥d+⑤-⑦-⑧y-⑨图 2.55 表达式 y=c*i+f*d+f/u-(i%2-d)的运算序列2.8.2 标注数据类型根据运算的语义和算术运算的类型转换规则，按照如图 2.54 所示的计算顺序，依次确定每个运算结果的数据类型，并标注在计算顺序图中，具体标注位置为该运算的左下角。标注数据类型后的计算顺序图，如图 2.56 所示。inty = c    *    i    +    f    *    d     +    f    /    u    -    (   i    %    2    -    d   )①②③④⑤⑥⑦⑧doubleintdoubledoubledoubledoubledoubledouble⑨图 2.56 标注数据类型的计算顺序图如图 2.56 所示，标注了各个运算结果的数据类型，根据标注的数据类型，在如图2.55 所示的运算序列中插入需要增加的类型转换运算，如图 2.57 所示。内部资料 严禁外传51cv1v2t1v4v5+t2v3t3v6③fu*v7v8(double)t4④(double)t5+v9v10⑤iv112*⑥-v12v14(double)t5⑦-⑧dv13v15-v16yyi(int)f*d(double)①*(double)②⑨图 2.57 增加类型转换后的运算序列2.8.3 计算表达式的值在计算表达式 y=c*i + f*d + f / u - (i % 2 - d)前，先使用如下代码给变量赋值。char c = 'A';int i = 1;unsigned int u = 3;float f = 4.5;double d = 0.5;执行这些代码后，变量及其内存状态，如图 2.58 所示。在这些数据上计算表达式的过程，如图 2.59 所示，最终计算的结果为 68.25，并存储在变量 y。‘A’1char cint i34.50.5unsigned int ufloat fdouble d图 2.58 变量及其内存状态inty = c    *    i    +    f    *    d     +    f    /    u    -    (   i    %    2    -    d   )①②③④⑤⑥⑦⑧doubleintdoubledoubledoubledoubledouble10.51.568.7568.2567.252.2565double68.25⑨图 2.59 计算表达式的过程读者也可在如下的数据集上计算表达式 y=c*i + f*d + f / u - (i % 2 - d)，人工执行其运算序列。char c = 'b';int i = 2;unsigned int u = 3;float f = 3.5;double d = 2.0;实际上，很多编译器都存在没有严格实现计算语言标准文本中规定的语义的情况，也内部资料 严禁外传52存在适配硬件的问题，如，尽量将数据的位数调整到计算机的字长，以充分发挥计算机的性能，因此，编写表达式后必须进行调试，只有经过充分调试的程序才能实际使用。在调试表达式时，调试器一般以表达式为粒度执行程序，不能观察到计算表达式的步骤，但可以观察到各个变量的值。可将计算顺序图中的变量值与计算机的实际结果比较，判断出表达式是否编写正确性，并推导出错的计算步骤，再改正表达式。在实际编程中，应编写简洁的表达式，而不能编写非常复杂的表达式，特别不能涉及到大量的数据类型转换。",
    "2.9 字符流和输出格式 ": "输入输出设备是冯·诺依曼机中的逻辑部件，分别承担输入输出的任务。计算机常用的传统输出设备有显示器和打印机，输入设备有键盘，这三个设备成为一个计算机的标配，常常将它们称为标准输入输出设备。显示器、打印机和键盘都属于字符设备。计算机中，使用“字符流”的方式在标准输入输出设备上输入和输出数据。2.9.1 字符流的工作原理字符流，顾名思义，从当前位置流过的字符序列。字符流是一种抽象概念，它将数据视为一个字符序列，这个字符序列从一个固定的位置流过，一般称这个固定位置为当前位置，因此，将从当前位置流过的字符序列称为字符流。字符流的概念，如图 2.60所示。当前位置a b c d 1 2 3a b c d 1 2 3a b c d 1 2 3a b c d 1 2 3a b c d 1 2 3图 2.60 字符流的概念如，在显示器上输出数据时，先将需要输出的数据转换为一个字符序列，然后再按照字符流的方式输出这个字符序列。显示器上的光标就是当前位置，每次都在光标处输出一个字符，相当于字符序列从光标位置流过。为了便于人们阅读，显示器上的字符位置是固定不变的，而通过移动光标实现字符的流动，每显示一个字符就自动将光标向后移动一个位置。自动向后移动光标位置，如图 2.61所示。下一位置a b c d 1 2 3当前位置图 2.61 自动向后移动光标位置内部资料 严禁外传53与字符流相关的运算有两个，第 1 个，从当前位置“提取”字符，第 2 个运算，从当前位置“插入”字符，可通过这个运算实现输入和输出。前学习的 cout 和 cin 都属于字符流。cout 用于输出，也称为输出字符流，简称输出流，主要运算是将需要输出的字符“插入”当前位置。cin 用于输入，也称为输入字符流，简称输入流，主要运算是从字符流的当前位置“提取”字符。使用字符流输出一个数据时，一般不会一个字符一个字符地“插入”到字符流，这样太麻烦，而是每次插入一个数据的所有字符，如，一次插入表示一个整数的所有数字，一次插入表示一个实数的数字和小数点。例如，使用字符流输出一个数据。int a = 123;cout << a;cout << a 中，cout 是一个输出流。执行 cout << a 时，先将变量 a 的值 123 从内存中取出来，转换为字符串“123”，然后将字符串“123”逐个插入到输出流的当前位置，同时系统将输出流中的字符显示到显示器。使用字符流输出数据的过程，如图 2.62 所示。1 2 3当前位置123int a格式控制内存中的数据字符流显示器中的结果逐个显示1 2 3图 2.62 使用字符流输出数据使用字符流输出一个数据，分为两步，第 1 步，从内存中取出数据并按照指定的显示格式转换为字符串，第 2 步，将字符串插入到输出流的当前位置，其中指定显示格式是编程输出数据的主要工作。2.9.2 控制输出单元的格式使用字符流输出数据时，每次输出一个数据，可将一个数据占用的显示区块视为一个单元，并控制这个单元的显示格式。单元的显示格式涉及显示的宽度(字符个数)、对齐方式和填充的字符。单元的显示格式控制方法，如图 2.63 所示。1 2 3宽度1 2 3左对齐右对齐填充图 2.63 单元的显示格式控制方法单元的显示格式控制方法与 Execl 表中单元格的控制方法类似，可以参考 Execl 中的控制方法。在头文件 iomanip 中提供了控制输出格式的多种手段，下面举一个示例介绍控制输出格式的方法，代码如例 2.9 所示。内部资料 严禁外传54【例 2.9】控制输出格式。#include <iostream>#include <iomanip>using namespace std;void main(){cout << cout.fill('*') << setiosflags(ios::left)<< setw(6) << 123 << '|'<< resetiosflags(ios::left)<< setw(10) << 123<<endl<< \"|abc|\"<< hex<<123<<endl;cout << setiosflags(ios::scientific)<< 123.456 << ' '<< resetiosflags(ios::scientific)<< 123.456<< endl;}代码中，cout.fill('*')设置填充字符。setiosflags(ios::left)设置左对齐，resetiosflags(ios::left)清除左对齐，setw(6) 设置宽度，hex 设置了十六进制， setiosflags(ios::scientific)设置科学记数法。例 2.9 在 VS2013 上的输出结果如下：123***|*******123|abc|7b1.234560e+002 123.456_注意，图中左边的部分表示“栈”，由于没有变量，栈空间中没有数据，所以图中左边区域是空白的。控制输出格式涉及大量的计算机语言细节，也与编程环境联系紧密，学习控制输出格式最好的方法是查阅随机文档或查阅标准文本，并针对不同情况在计算机上调试。",
    "2.10 表达式的调试与维护 ": "在程序运行前，编译器首先对表达式进行语法检测，判断是否符合规定的语法，然后将表达式“翻译”成相应的运算序列，最后按照这个运算序列生成表达式的目标代码，并成为可执行程序的一部分。调试表达式的目标有两个，第一、确保表达式符合语法，即语法正确，第二、确保表达式表达的运算序列符合预期，即语义正确或逻辑正确。调试表达式中主要做两件事，第一、发现并改正表达式的语法错误，第二、发现并改正表达式的运算序列错误，即逻辑错误。编译器能很好地发现表达式中的语法错误，但逻辑错误需要程序员来完成，并会消耗内部资料 严禁外传55大量精力。调试表达式逻辑错误的关键是按照 2.8 节中的方法人工计算表达式，并在调试器中对比变量的实际值，以推断表达式的正确性，纠正其中的错误。借助编译器发现代码中的错误，能提高编程的效率，与编译器进行有效交互是调试程序的基础。2.10.1 调试编译错误调试表达式时的常见编译错误有，没有提前定义变量，在表达式后没有加分号(;)，运算符使用错误等。除此之外，还很容易将半角字符输出成全角字符。如void main(){int s, a, b;s = 4 * l + 2 ×(a + b)}编译时会报如下错误：描述 文件 行 列 项目Error 1 error C2065: 'l' : undeclared identifier kkk.cpp 9 1 kkkError 2 error C2146: syntax error : missing ';' before identifier '×(a' kkk.cpp 9 1 kkkError 3 error C2065: '×(a' : undeclared identifier kkk.cpp 9 1 kkkError 4 error C2065: 'b)' : undeclared identifier kkk.cpp 9 1 kkk5 IntelliSense: identifier \"l\" is undefined kkk.cpp 9 10 kkk6 IntelliSense: expected a ';' kkk.cpp 9 16 kkk这些错误都是因为表达式不正确而引起的，表达式应该是 s=4*l+2*(a+b)，后面还要加分号，才能构成表达式语句。另一个原因是，变量 l 没有定义，需要先将其定义。将表达式修改如下：void main(){int s, a, b,l;s = 4 * l + 2 * (a + b);}再编译会报如下错误：描述 文件 行 列 项目Error 1 error C4700: uninitialized local variable 'l' used kkk.cpp 9 1 kkkError 2 error C4700: uninitialized local variable 'a' used kkk.cpp 9 1 kkkError 3 error C4700: uninitialized local variable 'b' used kkk.cpp 9 1 kkk按照表达式的计算顺序，在计算时要使用到三个变量 a、b 和 l 的值，必须在计算前给它们赋值。在程序中，可使用初始化、赋值运算或输入语句给这三个变量赋值。下面的程序就可通过编译。void main(){int s, a=1, b=3,l=3;s = 4 * l + 2 * (a + b);}编译时不仅可以检测到语法错误，还可以检测到简单的逻辑错误。内部资料 严禁外传56从程序中还能发现，字母 l 与数学 1 很难区别，不要单独使用字母 l 作为变量名。2.10.2 整型的溢出数据类型对表达式的计算结果有很重要的影响，在编写和调试表达式时要高度重视，下面以整数来讨论这个问题。计算机中整型最终都是使用固定位数二进制数，有一定的表示范围。常见整型的表示范围，如表 2.10 所示。表 2.10 常见整型的表示范围二进制位数 有符号整数signed 无符号整数unsigned1字节8位char27  27  1(128  127)0  28-1(0…255)2字节16位short int215  215  1(-32,768…32,767)0  216-1(0…65,535)4字节32位long int231  231  1(-2,147,483,648…2,147,483,647))0  28-1(0…4,294,967,295)当数据超过了整型的表示范围时，会导致数据的溢出。下面通过示例来演示整型数据的溢出，代码如例 2.10 所示。【例 2.10】整型数据的溢出。#include <iostream>#include <iomanip>using namespace std;void main(){unsigned short us = 65535;us = us + 1;//溢出cout << \" unsigned short:\";cout << setw(8) << hex << us << \",\" << setw(8) << dec << us << endl;signed short ss = 32767;ss = ss + 1;//溢出cout << \" signed short:\";cout << setw(8) << hex << ss << \",\" << setw(8) << dec << ss << endl;}运行中的内存状态和输出结果：\"unsigned short:\"\",\"\"signed short  :\"\",\"内部资料 严禁外传57signed short us0signed short ss-32768unsignedshort:0,0signedshort:8000,-32768_这与我们的期望一致吗？为什么会得到这样的结果？要回答这些问题，需要清楚，整数是怎样存储在变量中的？变量中存储的是什么？运用 2.4.1 理解整数与进制中的基本知识，能解决这些问题，并建议读者自己去推导演算。2.10.3 整数的重要性整型是计算语言中最重要的数据类型，是理解其他数据类型的基础。从本质上讲，整型中存储的数据就是固定位数的二进制数，即一串01数字，整型的运算是固定位数二进制数的计算，计算机在进行整型运算时，一般都假设程序员在编写程序时已保证其正确性，编译时不再增加检测逻辑的代码，以满足应用的多样性和提高程序运行的效率。换句话讲，程序员必须理解整型的表示原理及运算的逻辑，在编写程序时运用其表示原理及运算的逻辑解决客观世界中的实际问题，并保证其正确性。直接管理整型数据是一个合格程序员不可推卸的责任。 前面专门讨论自然数和整数的记数法及其运算过程，就是为了程序员理解整型的表示原理及运算的逻辑，能够承担这个责任而准备的。在实际编程中，常常用整型表示文字、图像、语音等实际应用中的数据，表示通信、网络、物联网中传输的数据，涉及有符号整数、无符号整数，涉及8位、16位、32位整数，使得整型的应用情况非常复杂，往往需要程序员花费大量的时间和精力，反复做类似的程序调试工作，才能判断是否满足功能要求，满足我们的预期。",
    "2.11 本章小结 ": "本章主要从计算角度学习了表达式和数据类型相关的知识，以及相应的编程方法。 学习了表达式及基本运算，重点学习了算术运算、赋值运算、复合赋值运算和自增自减运算在冯诺依曼机上的语义，深入学习了表达式的计算顺序和运算序列，学习了编写表达式的方法，需要掌握将数学公式改写为计算机表达式的方法，掌握使用计算顺序图人工计算表达式的方法。学习了变量的概念，重点学习了定义变量在冯诺依曼机上的语义。学习了自然数、整数及其记数方法，深入学习了固定位数和负数的方法，学习了整数、字符和实数等基本数据类型，重点学习了其表示原理和存储格式，学习了数据类型转换及其语义，需要掌握使用变量和操纵数据的方法，能够选择适当的数据类型，并掌握使用内存图描述数据的方法。学习了字符流，重点学习了控制输出格式的原理，需要掌握控制输出格式的方法。 学习了调试和维护表达式的基本知识，深入学习了发现逻辑错误的方法，需要掌握使用运算序列图、内存图和计算顺序图调试和维护表达式的方法。内部资料 严禁外传58",
    "2.12 习  题 ": "1. 下面给出了一些数学或物理公式，请根据本章所学内容完成各小问。 等差数列的通项公式： = 1 + (  1) 余弦定理：2 = 2 + 2  2 cos  自由落体距离公式:  = 2/2 并联电阻公式: R = 12/(1 + 2) 1) 只使用四则运算，能否将所有公式改写为表达式？2) 如果能，请写出其表达式，画出上面表达式的计算顺序图，给变量指定一个值并计算表达式。3) 根据上面计算顺序图，画出表达式的运算序列图，并以文字描述其运算序列。2. 按照 2.1.3 和 2.8 节中的方法，使用图和文字描述下列代码在 32 位机上的计算过程、计算步骤和表达式 c=b-a 的计算序列。int  a=10;char b=107,c;c= b-a;要求在计算步骤和计算序列中增加类型转换运算。3. 画出下列实数存储在内存中的逻辑结构 1) 3.141659262) -0.3333333) 17000.33584) -10.946234. 上机编程，定义一个无符号整形变量 x，并初始化为-10，分别以 16 进制和 10 进制输出变量 x。再定义一个有符号整形变量 y，将变量 x 强制转换为有符号整形，再将转换结果赋值给变量 y，分别以 16 进制和 10 进制输出变量 y。观察输出结果，并用 2.4.1节中有关整数表示的知识解释输出结果。5. 读下面的程序，画出表达式的计算顺序图和内存图，并分析运行结果产生的原因。#include <iostream>#include <iomanip>using namespace std;int main(){unsigned short us = 65535;us = us + 1；//溢出cout << \" unsigned short:\";cout << setw(8) << hex << us << \",\" << setw(8) << dec << us << endl;signed short ss = 32767;ss = ss + 1；//溢出cout << \" signed short:\";cout << setw(8) << hex << ss << \",\" << setw(8) << dec << ss << endl;内部资料 严禁外传59return 0;}6. 以下代码中包含了两个表达式，请按要求回答下列问题。unsigned int k;char x =‘A’;double  a = 9.0;int y = 2,z = 1;k = x + a%3  (float)(x + y)%2/zdouble u;int i = 2;float a = 4; =   ,  = + + 1) 分别画出两个表达式的计算顺序图，并计算表达式的值。2) 根据计算顺序图，分别画出表达式的运算序列图。3) 上机调试这两个表达式，并改写代码，以观察计算 u=i--后变量 i、u 中的值，计算a*=++i 后变量 i、a 中的值，并与人工计算结果对比。内部资料 严禁外传60"
  },
  "构造分支": {
    "构造分支": "大千世界，多姿多彩，实际应用中的问题往往非常复杂，一般需要将一个复杂问题分解为多个相对简单的问题，然后再逐个解决这些相对简单的问题。按照数学的观点，先对需要解决的问题进行层层分解，最终将问题分解为一些能够使用数学公式解决的基本问题，然后再将解决基本问题的数学公式组合起来，构成一个数学模型，最后，用这个数学模型去解决实际问题。计算机，顾名思义，就是“计算”的机器。前面学习了使用表达式和数据类型描述数学公式中的计算，后面开始学习将表达式组合起来展现计“算”艺“术”。",
    "3.1 结构化程序设计 ": "结构化程序设计思想来源于小孩玩的积木游戏。在积木游戏中，购买大量小块的积木，小孩将多个小块的积木组成较大的积木块，再将较大的积木块组成更大的积木块，最后搭建出期望的大积木。3.1.1 三种基本结构1966 年，Borhra 和 Jacopini 提出了表示算法的 3 种基本结构：顺序结构、选择结构和循环结构。3 种基本结构流程，如图 3.1 所示。语句语句语句条件是语句否语句条件是否顺序结构分支结构循环结构图 3.1  3 种基本结构流程顺序结构：顺序结构表示程序中的各操作是按照它们在程序中出现的先后顺序执行的。前面学习的运算和表达式，基本上都符合“第 1 步做…，第 2 步做…，第 3 步做...”这种模式，属于顺序结构。顺序结构符合平时的习惯，且便于理解，因此是编程中使用最多的结构，也是编程者最基本的思维模式。内部资料 严禁外传61选择结构：选择结构表示程序的处理步骤出现了分支，它需要根据某一特定的条件选择其中的一个分支执行，适用于“如果…，则…，否则…”这样的思维模式。循环结构：循环结构表示程序反复执行某个或某些操作，直到某条件为假(或为真)时才可终止循环。从程序流程的层面讲，顺序结构是基础，是程序功能的具体载体；选择结构是方向，决定了程序提供哪些功能；循环结构是能力，在本质上决定了程序计算能力的大小。在编程中，符合这 3 种结构之一的程序块相当于一个积木，程序员将小的程序块组成较大的程序块，再将较大的程序块组成更大的程序块，最后编写出期望的程序。结构化程序设计思想尽管简单，但功能强大。理论证明，目前计算机能解决的任何问题，都能用这三种基本结构组成的算法来解决，换句话说，用这三种基本结构可以描述任何一个程序的流程。3.1.2 流程图流程图是描述算法的主要工具之一，能够帮助初学者很好地理解程序，理解程序的执行过程，有利于培养编程的思维方式。业务流程建模符号(BPMN，Business Process Model and Notation)是 OMG 组织(ObjectManagement Group)提出的一个标准，主要目标是提供一组容易理解的符号，这组符号覆盖了业务分析、系统设计到程序的实现整个软件开发过程。BPMN 是一个图形语言，不仅可用于算法描述、程序设计，而且直观，易于理解。BPMN 中定义的图标很多，只选用其中几个基本图标，如表 3.1 所示。有兴趣的读者可以查阅相关标准文档，也可在需求分析时学习。流程图的基本图标及语义，如表 3.1 所示。表 3.1 流程图的基本图标及语义图标名 图标 语义开始用于描述程序或语句块的开始，只能有一个结束用于描述程序或语句的结束，只有能一个处理用于描述程序中的语句或功能，可多个判断用于描述分支，需要标注条件操作流程连接其他图标，线上可标注数据，用于描述程序的流向及其数据流程图的图标非常简单，便于理解，画出的流程图直观形象，并能体现程序的主要特征，是学习程序和编写程序的有力工具。本教材使用上述图标绘制流程图，在各个层次上描述程序。内部资料 严禁外传62",
    "3.2 分支结构及条件 ": "分情况解决问题是一种解决问题的基本方法，其核心思想为，先将需要解决的问题分成不同情况，并针对每种情况提出一个解决方案，在解决实际问题时，满足哪种情况就使用哪个解决方案。数学上的分段函数是描述分情况解决问题的数学工具，分段函数中的条件用于描述问题的不同情况，分段函数中的公式用于描述解决问题的方案。如下面的分段函数：y = {0        ≤ 030 <  ≤ 40120         > 40将一个问题分解成 ≤ 0、0 <  ≤ 40和 > 40三种情况，并针对这三种情况分别对应y=0、y = 3和 y=120 三种解决方案。分段函数的计算流程，如图 3.2 所示。y=3*xtruey=0X<=00<x&&x<=40X>40y=120truetruefalsefalsefalse图 3.2 分段函数的计算流程使用分段函数描述各种情况，先根据不同情况进行复杂问题分解，然后针对每种情况抽象出一个相对简单的数学公式，最后再将这些数学公式组合在一起，构成解决复杂问题的完整数学模型。计算机语言中的逻辑运算和条件运算用于描述问题的不同情况，分支语句用于描述不同情况下问题的解决方案，下面先学习分支语句，以及逻辑运算和条件运算，然后再学习构造分支的方法。3.2.1 if 语句在自然语言中，有两种常见句型可用于分情况讨论。第 1 种，如果…，则…，第 2种，如果…，则…，否则…。在计算机语言中，针对分段函数这种典型场景，借用自然语言中的上述两种句型，设计了 if 语句，用于描述分支结构。内部资料 严禁外传63if 语句的语法为：if (exp)statStatement;或if (exp)statStatement1;elsestatStatement2;其中，exp 为表达式，exp 的结果为真或假，作为执行 statStatement 的条件，一般为关系表达式或逻辑表达式。与分段函数进行对照，exp 对应分段函数中的条件，statStatement 对应分段函数中的数学公式。上述两种语法的语义用如图 3.3 中的流程图所示。在画流程图时，为了与代码中的顺序保持一致，判断的正下方都是 false 分支，需要特别注意。If 语句语义流程，如图 3.3 所示。if...语义if...else...语义exptruefalsestatStatement1statStatement2exptruefalsestatStatement图 3.3 if 语句语义流程前面的分段函数是三个分支，可通过两条 if 语句来描述。if (x <= 0) //expy = 0; //statStatementelse if (0 < x&&x <= 40) //expy = 3 * x; //statStatementelse if (x > 40) //expy = 120; //statStatement上面代码使用了关系运算和逻辑运算，下面学习这两项运算。3.2.2 关系运算关系运算有等于、不等于、大于、小于、大于等于和小于等于，用于比较数据的大小，这些运算都是数学中的定义的，计算机语言只是直接使用了这些运算。关系运算的语法语义，如表 3.2 所示。内部资料 严禁外传64表 3.2 关系运算的语法语义运算符 名称 结合律 语法 语义或运算序列<= 小于等于 从左到右 exp1<=exp2计算exp1得到值v1，计算exp2得到值v2，计算v1<=v2得到bool类型的值>= 大于等于 从左到右 exp1>=exp2计算exp1得到值v1，计算exp2得到值v2，计算v1>=v2得到bool类型的值> 大于 从左到右 exp1>exp2计算exp1得到值v1，计算exp2得到值v2，计算v1>v2得到bool类型的值< 小于 从左到右 exp1<exp2计算exp1得到值v1，计算exp2得到值v2，计算v1<v2得到bool类型的值== 等于 从左到右 exp1==exp2计算exp1得到值v1，计算exp2得到值v2，计算v1==v2得到bool类型的值!= 不等于 从左到右 exp1!=exp2计算exp1得到值v1，计算exp2得到值v2，计算v1!=v2得到bool类型的值关系运算被分成两个优先级，大于、小于、大于等于和小于等于的优先级高于等于和不等于的优先级，关系运算的结果是 bool 类型，只有真 true 和假 false。1. 是否相等运算判断两个数据是否相等的运算有等于(==)和不等于(!=)两个运算，其运算结果是都是bool 类型的值。可编程观察这两个运算得到的结果和数据类型，代码如例 3.1 所示。【例 3.1】比较相等。#include <iostream>#include <iomanip>using namespace std;void main(){cout << \"3 != 2 运算结果: \"<< (3 != 2) << endl<< \"20 == 10 运算结果: \"<< (20 == 10) << endl;cout << boolalpha//显示 ture 或 false<< \"3 != 2 运算结果: \"<< (3 != 2) << endl<< \"20 == 10 运算结果: \"<< (20 == 10) << endl;}例 3.1 程序运行的内存状态和输出结果：内部资料 严禁外传65\"3 != 2 运算结果:\"\"20 == 10 运算结果:\"3 != 2 运算结果: 120 == 10 运算结果: 03 != 2 运算结果: true20 == 10 运算结果: false_2. bool 类型bool 类型只有真假两个值，在 C/C++中分别用 true(真)和 false(假)表示，在计算机内部分别存储为 1 和 0，可以理解为整型派生出的一个数据类型。可编程观察 bool 类型变量的内存大小和值，代码如例 3.2 所示。【例 3.2】bool 类型的值。#include <iostream>#include <iomanip>using namespace std;void main(){bool t = true, f = false, b;int x;cout << \"bool 类型占用字节：\"<< sizeof t //sizeof 运算的功能取变量的大小<< \",true=0x\"<< setw((sizeof t) * 2) << setfill('0') << hex << t<< \",false=0x\"<< setw((sizeof f) * 2) << setfill('0') << hex << f;b = (x = 4);//将整型转换为 bool 型cout << endl << \"bool 类型变量 b 的值：\" << b;}例 3.2 程序运行的内存状态和输出结果：bool t1bool fbool bint x014\"bool类型占用字节：\"\"true=0x\"\"，false=0x\"\"bool类型变量b的值：\"bool 类型占用字节：1,true=0x01,false=0x00bool 类型变量 b 的值：1_第一行输出结果，说明 bool 类型占用 1 字节，true 用 8 位整数的 1 表示，false 用 8 位整数的 0 表示。表达式 b = (x = 4)的语义，如图 3.4 所示，将整数 4 赋值给变量 x，得到变量 x，然后从变量 x 取出 int 类型的值 4，将它转换为 bool 类型的值 true，并存储到 bool 类型的变量b。内部资料 严禁外传66b = (x = 4)boolintx:4true①②图 3.4  b = (x = 4)的语义bool 类型与整型之间转换规则为，0 转换为 false，非 0 转换为 true。初学者在编写程序时容易将等于(==)与赋值(=)运算符混淆，在条件判断中将==误写为赋值=，从而产生错误。例如：x = somevalue;if (x = 0)cout <<\"x is not 0\\n\";表达式 x = 0 中，“=”是赋值运算，计算结果为变量 x，变量 x 的值为整数 0，将整数0 转换为 bool 类型，是假(false)。上述代码中，无论 somevalue 的值是什么，cout 语句都不会被执行。3. 比较大小运算比较数据的大小，有大于(>)、小于(<)、大于等于(>=)和小于等于(<=)四个运算，运算结果都是 bool 类型的值。可编程观察比较大小运算得到的结果和数据类型，代码如例 3.3所示。【例 3.3】比较大小运算。#include <iostream>#include <iomanip>using namespace std;void main(){cout << boolalpha//显示 ture 或 false<< \"1.23 > 1.11 运算结果: \"<< (1.23 > 1.11) << endl<< \"3.1 < 3 运算结果: \"<< (3.1 < 3) << endl<< \"'A'>'a' 运算结果: \"<< ('A'>'a') << endl;}内存状态和输出结果：\"1.23 > 1.11运算结果:\"\"3.1 < 3运算结果:\"\"'A'>'a' 运算结果:\"内部资料 严禁外传671.23 > 1.11 运算结果: true3.1 < 3 运算结果: false'A'>'a' 运算结果: false_前面两行输出结果是实数和整数之间比较大小，相对比较安全，因实数存在精度问题，应避免实数参与相等运算，一般应用于比较运算。最后一行输出结果是比较两字符大小的结果，在计算机中，比较字符大小实际上是比较字符 ASCII 码的大小。3.2.3 逻辑运算逻辑运算有非!、与&&和或||运算，为了与位运算相区别，分别称它们为逻辑非(Logical negation)、逻辑与(Logical AND)和逻辑或(Logical OR)运算。逻辑运算的语法语义，如表 3.3 所示。表 3.3 逻辑运算的语法语义运算符 名称 结合律 语法 语义或运算序列!Logical negation逻辑非从右到左 !exp计算exp得到bool类型的值b，如果b等于true,则返回false，否则返回true&&Logical AND逻辑与从左到右 exp1&&exp2计算exp1得到bool类型的值b1，若b1值为false，exp1&&exp2的结果为false，否则，计算exp2得到bool类型的值b2，计算b1&&b2得到bool值b3，exp1&&exp2的结果为bool值b3||Logical OR逻辑或从左到右 exp1||exp2计算exp1得到bool类型的值b1，若b1值为true，则exp1||exp2的结果为true，否则，计算exp2得到bool类型的值b2，计算b1||b2得到bool值b3， exp1||exp2的结果为bool值b3逻辑非、逻辑与和逻辑或运算有不同的优先级，从高到低依次为逻辑非、逻辑与和逻辑或，其中，所有操作数均为 bool 类型，运算结果也是 bool 类型。逻辑与(&&)和逻辑或(||)规定了操作数的执行顺序，必须从左到右依次计算。1. 逻辑运算的运算规则逻辑非、与、或等逻辑运算的运算规则与数学中的规则相同，计算机中逻辑运算的运算规则，如表 3.4 所示。表 3.4 逻辑运算的运算规则op1/ exp1 op2/exp2 !op1 op1&&op2 op1||op2true true false true truetrue false  false truefalse true true false truefalse false  false false内部资料 严禁外传68其中，op1 和 op2 为运算的操作数，是语法中表达式的结果，如 exp1&&exp2 中，exp1 的计算结果记为 op1，exp2 的计算结果记为 op2。当逻辑与(&&)的两个操作数都为真时，结果才为真，否则为假；与之相反，当逻辑或(||)的两个操作数都为假时，结果才为假，否则为真。2. 逻辑运算的语义逻辑非(！)运算的语义相对简单，有！true==false，!false==true 两个等式。逻辑与(&&)和逻辑或(||)相对复杂一些，下面重点学习这两个运算。逻辑与(&&)的语法为，exp1&&exp2，语义是计算 exp1 得到 bool 类型的值 b1，若 b1值为 true，计算 exp2 得到 bool 类型的值 b2，计算 b1&&b2 得到 bool 值 b3；否则exp1&&exp2 的结果为 false。其中规定了 exp1 和 exp2 的计算顺序，必须从左到右依次计算。exp1&&exp2语义计算exp1计算exp2判断值b1bool类型的值b1truebool类型的值b2falseexp1||exp2语义计算exp1计算exp2判断值b1bool类型的值b1falsebool类型的值b2true图 3.5 逻辑与(&&)与逻辑或(||)的语义逻辑与(&&)和逻辑与(&&)类似，但运算规则不同。逻辑与(&&)与逻辑或(||)的语义，如图 3.5 所示。数学中经常表示一个数的取值区间，如 x 的取值区间为(2,3]，用不等式表示为2 <  ≤3，其中包括了2 < 和x ≤ 3两个不等式，应改写为逻辑表达式 2<x&&x<=3，而不能写成表达式 2<x<=3，是错误的。两个表达式的语义差异，如图 3.6 所示。booltrue①②2 < x <= 3bool2 < x&&x <= 3bool②bool①bool③图 3.6 两个表达式的语义差异逻辑与(&&)和逻辑或(||)的优先级低于关系运算，在同时使用关系运算时一般不用括号()，这样写出的表达式更加简明，符合平时的习惯，但也容易出现错误。内部资料 严禁外传69表达式 2<x&&x<=3 的语义为，计算 2<x 得到 bool 类型的值 b1，若 b1 值为 false，则exp1&&exp2 的结果为 false，否则，计算 x<=3 得到 bool 类型的值 b2，计算 b1&&b2 得到bool 值 b3，exp1&&exp2 的结果为 bool 值 b3。表达式 2<x<=3 的语义为，计算 2<x 得到一个 bool 类型的值 b1；将 bool 类型的值 b1 转换为整型值 t(只可能为 0 或 1)，t<3 得到肯定的 bool 类型的值 true。这个语义不符合数学算式 2<x≤3 的意思。用流程图表示上述两个表达式的语义，更加直观，更容易理解。两个表达式的流程图，如图 3.7 所示。2<x&&x<=3语义2<x<=3语义2<xx<=3判断值b1bool类型的值b1truebool类型的值b2false2<x(int)b1<=3判断值b1bool类型的值b1truetruefalse图 3.7 两个表达式的流程图关系运算和逻辑运算往往结合使用，并且常用在分支和循环语句中，是实现分支和循环流程的基础。例如，温度湿度提示，代码为。int temp = 90, humi = 80;if (temp >= 80 && humi >= 50)cout << \"wow，it's hot！\\n\";if (temp<60 || temp>80)cout << \"the room is uncomfortable.\\n\";通过判断房间的温度和湿度提示舒适程度提示，其中，使用了两个条件表达式判断舒适程度，并给出相应提示。判断舒适程度的条件表达式的计算顺序，如图 3.8 所示。temp >= 80 && humi >= 50boolboolbool①②③boolboolbool①②③temp < 60 || temp > 80图 3.8 判断舒适程度的条件表达式的计算顺序运行上述程序的内存状态和输出结果为：\"wow，it's hot！\"\"the room is uncomfortable.\"内部资料 严禁外传70int temp90int humi80wow，it'shot！the room is uncomfortable._其中，if(temp<60 || temp>80)cout << \"the room is uncomfortable.\\n\";的语义为，如果 temp>=80 && humi>=50 为真，则执行语句 cout <<\"wow，it's hot！\\n\"，输出 wow，it's hot！，否则，就输出结果。温度湿度提示的流程，如图 3.9(a)所示。int temp=90，humi=80temp>=80 && humi>=50temp<60|| temp>80falsetruefalsetruetemp>=80 && humi>=50temp<60|| temp>80cout <<\"wow，it's hot！\\n\"cout <<\"the room is uncomfortable.\\n\"temp>=80humi>=50判断值b1bool类型的值b1truebool类型的值b2falseTemp<60humi>80判断值b1bool类型的值b1falsebool类型的值b2true(a)  温度湿度提示的流程                    (b) 两个条件表达式的语义图 3.9 温度湿度提示的流程及其条件表达式的语义程序的输出结果，由两个条件表达式 temp>=80 && humi>=50 和 temp<60|| temp>80 控制，两个条件表达式的语义如图 3.9(b)所示。编写代码是一项细致的工作，不能将!=写为=！，其语义完全不同，如：if(x != 9)cout << \"x isn't 9\\n\";if(x = !9)cout << \"x isn't 9\\n\";x!=9 中!=是不等于运算，x= !9 中= !是赋值运算和逻辑非运算，其语义为，将整型值 9转换为 bool 类型的 true，取进行逻辑非运算，得到 false；将 false 转换为整型值 0，存储到变量 x。if 语句要求表达式 x= !9 的值必须为 bool 类型，还要将变量 x 的值 0 转换为 bool类型的值 false，因此，不可能执行语句 cout <<\"x isn't 9\\n\"。3. 表达式短路逻辑与(&&)和逻辑或(||)的流程图清楚表明，第 1 个操作数的表达式肯定会被执行，但第 2 个操作数的表达式会根据前一个表达式的结果决定是否执行。换句话说，语法中的第内部资料 严禁外传712 个表达式可能会被执行，也可能不会被执行，这个特点是其他大多数运算不具备的，需要特别注意。例如：int n = 3, m = 6;if (n > 4 && m++ < 10)cout << \"m should not changed.\\n\";cout << \"m=\" << m << endl;代码中使用了一个条件表达式，由于 n > 4 的值为 false，n>4 && m++ <10 中的 m++ <10 不会执行，m 的值只会是 6。程序员要避免使用这类表达式。表达式的短路计算顺序，如图 3.10 所示。boolboolbool①②③n > 4 && m++ < 10int④图 3.10 表达式短路计算顺序运行上述程序的内存状态和输出结果为：int n3int m6\"m=\"m=6_",
    "3.3 构造分支的典型模式 ": "If 语句使用非常灵活，可以构造出很多种分支结构，下面学习单分支、双分支、多分支和嵌套四种典型模式。3.3.1 单分支(if…)单分支，顾名思义只有一个分支，相当于中文的句型“如果…，就…”。 例如，比较变量 a 和 b 的大小，并根据比较结果输出“hello world”，代码为int a = 7, b = 4;if(a > b)cout << \"\\n hello world\";按照 if 语句的语义，先计算表达式 a > b，从变量 a 中取出值 7，从变量 b 中取出值4，判断条件 7>4 为真，则执行 cout << \"\\n hello world\"，在屏幕上输出 hello world。如果定义变量 a 和 b 时，将它们的初值交换一个，判断条件为假，则不会执行 cout << \"\\n hello world\"，不会输出 hello world。输出 Hello world 的流程，如图 3.11 所示。内部资料 严禁外传72int a = 7, b = 4a > bcout << \"\\n hello world\"truefalse图 3.11 输出 Hello world 的流程例如，输出一个字符，如果是’b’，则响铃，代码如例 3.4 所示。 【例 3.4】响铃程序。# include<iostream># include <conio.h>using namespace std;void main(){cout << \"please input the b key to hear a bell.\\n\";char ch = getchar();//从标准输入设备中读取一个字符if (ch == 'b')     //如果是’b’，则响铃cout << '\\a';}上述程序的 main 函数中包含两条表达式语句和一条 if 语句，计算机按照它们在程序中的顺序逐条执行这三条语句，构成一个顺序结构。程序的流程如图 3.12 所示，流程图中非常清楚地表示出了三条语句的执行顺序。响铃程序流程，如图 3.12 所示。cout << \"please input the b key to hear a bell.\\n\"char ch = getchar()ch == 'b'cout << '\\a'truefalse图 3.12 响铃程序流程先执行第 1 行的语句 cout << \"please input the b key to hear a bell.\\n\"，然后执行第 2 行内部资料 严禁外传73语句 char ch = getchar()，最后执行 if 语句。if 语句占用两行，语句 cout << '\\a'是 if 语句的一部分，当输入到变量 ch 中的字符为‘b’时执行。如果将 if 语句写成一行：if (( ch = getchar() )== 'b')  cout << '\\a';其功能不变，但不能增加注释信息“如果是’b’，则响铃”，更不能‘’体现分支结构，因此建议不要写成一行。当在键盘上输入字符 b 和回车键后，会发出声音，屏幕上的结果为：please input the b key to hear a bell. b_再次运行程序，当在键盘上输入字符 1(或非字符 b)和回车键后，如果发出声音，则说明程序编写错了。3.3.2 复合语句和空语句if 语句语法 if (exp) statStatement 中规定，statStatement 只能是一条语句，不能有多条语句，但在实际编程中，常常需要有多条语句，为了解决这个问题，计算机语言提供了复合语句，语法非常简单，用大括号{}将多条语句括起来，将大括号中多条语句在语法上“复合”为一条语句，其语法如下：{statStatement1;statStatement2;......}复合语句也称为块语句，并将复合语句中的语句称为语句块。意思为将一段程序在语法视为一条语句。如：int a = 7, b = 4;if (a > b){cout << \"\\n hello world\";cout << \"\\n我喜欢C++编程！\";}if 语句中使用复合语句，将两个输出语句作为语句块增加到 if 语句，也将语句块的流程嵌入到 if 语句的流程中，其流程如图 3.13(b)所示。内部资料 严禁外传74(a)不加大括号(b)加大括号{}int a = 7, b = 4a > bcout << \"\\n hello world\"truefalsecout << \"\\n我喜欢C++编程！\"int a = 7, b = 4a > bcout << \"\\n hello world\"truefalsecout << \"\\n我喜欢C++编程！\"图 3.13 使用复合语句后 if 语句的流程运行上面的程序，内存状态和输出结果为：int a7int b4\"hello world\"\"我喜欢C++编程\"hello world我喜欢 C++编程！_程序中条件 a > b 为真，顺序执行 if 语句中的两条 cout 语句，上面的结果。 如果在上例中删除大括号，则程序的流程完全不一样，变量 a 和 b 的初值无论是什么，一定会输出“我喜欢 C++编程！”。其流程如图 3.13(a)所示。分号(;) C/C++中，使用分号(;)表示一条语句结束，分号(;)是语句的结束标志。一般情况下，一条语句的最后都有这个结束标志，但也允许前面没有语句而只有单独的一个分号。针对这种情况下，将单独的一个分号也视为一条语句，称为空语句。空语句的语法为一个分号(;)，并且前面不能是一个完整的语句。空语句只有语法上的作用，没有任何实际操作。使用非常简单，但导致容易导致其它语句出现错误，如：int a = 7, b = 4;if (a > b);cout << \"\\n我喜欢C++编程！\";在 if 语句的判断条件后加上分号(;)，编译器会将 if (a > b);视为一条语句，从而导致语句的流程错误。空语句(；)导致的错误流程，流程如图 3.14(b)所示。按照 if 语句的语法“if (exp) statStatement;”，if 语句在语句结束前应该有一条语句，但“if (a > b);”没有语句就结束了。在这种情况下，编译器将分号视为一条语句，这种语句称为空语句。cout << \"\\n 我喜欢 C++编程！\" 被解释为另一条语句，导致了与期望流程不同的流程。内部资料 严禁外传75(b)空语句(a)期望的流程a>btruefalsecout << \"\\n我喜欢C++编程！\"int a = 7, b = 4a>btruefalse;int a = 7, b = 4cout << \"\\n我喜欢C++编程！\"图 3.14 空语句导致的错误流程一条 if 语句只包含了一条语句时，也可以将这条语句视为一条复合语句，加上加大括号，养成习惯后，可避免很多()流程错误，会减少很多 bug。如int a = 7, b = 4;if (a > b){cout << \"\\n我喜欢C++编程！\";}因此，使用单分支编程模式时，建议按照下面的格式写代码：if (判断条件) {语句;......}或if (判断条件){语句;......}按照上述格式写出的代码，与图 3.13 进行比较，它们在结构上非常相似，这有助于理解代码的流程。3.3.3 双分支(if… else…)前面学习了单分支结构，下面学习双分支结构，实现双分支的 if 语句语法如下：if (exp)statStatement1;elsestatStatement2;其语义为，如果 exp 的值为真，则执行 statStatement1，否则，执行 statStatement2。详细执行过程为，计算 exp1，得到 bool 类型的值 v1，如果 v1 为 true，则执行内部资料 严禁外传76statStatement1，否则执行 statStatement2。在下面这个例子中，判断一个数 number 是正数或非正数(等于 0 或小于 0)。只需要检查 number 是否大于 0，因为任何小于或等于 0 的情况都在 else 语句中处理。例如：int number;cin >> number;if (number>0)cout << \"\\n number是正数！\";elsecout << \"\\n nunber等于0或小于0！\";cout << \"\\n结束if\";其中，if 语句的流程是，如果 number>0，则执行 cout << \"\\n number 是正数！\"，否则执行 cout << \"\\n nunber 等于 0 或小于 0！\"。两条输出语句执行且只执行一条。判断是否为正数的程序流程，如图 3.15 所示。number>0\"cout << \"\\n nunber等于0或小于0！\"cout << \"\\n number是正数！int numbercout << \"\\n结束if\"cin >> numberfalsetrue图 3.15 判断是否为正数的程序流程运行程序，输入 23 和回车键，内存状态和输出结果为：int number23\"number是正数！\"\"number小于0或等于0\"\"结束if\"23number 是正数！结束 if_再次运行程序，输入一个负数，如-34，内存状态和输出结果：内部资料 严禁外传77int number-34\"number是正数！\"\"number小于0或等于0\"\"结束if\"-34nunber 等于 0 或小于 0！结束 if_读者可再次运行程序，输入 0 和回车键，观察输出结果，如果和预期不符，则程序一定存在错误。也可以用大括号{}将 if 语句中的两条语句括起来，这样写出的程序健壮性更好。int number;cin >> number;if(number>0) {cout << \"\\n number是正数！\";}else{cout << \"\\n nunber等于0或小于0！\";}cout << \"\\n结束if\";3.3.4 If 嵌套if 语句可以包含语句，当然也可以包含 if 语句，if 语句包含 if 语句，称为 if 语句嵌套。代码框架如下：if(条件){                  //第1个条件if(另一条件){         //这是嵌套的if语句//语句}∥其他语句}例如，编写程序判断一个数的正负。先提示用户输入一个数，如果这个数小于或等于0，则输出这个数；如果大于 0，则当这个数在 0~10 之间时才输出\"并且小于等于 10\"。判断一个数的正负，代码如例 3.5 所示。【例 3.5】判断一个数的正负。#include<iostream>using namespace std;void main(){int number;cout << \"\\n 请输入一个整数：\";cin >> number;if (number>0)//正数{cout << \"\\n 输入的数大于 0\" << endl;内部资料 严禁外传78if (number >= 1 && number <= 10){cout << \"并且小于等于 10\" << endl;}}else{cout << \"\\n 输入的数小于等于 0\" << endl;}}运行例 3.5 程序，输入 0 和回车键，内存状态和输出结果为：int numeber0\"请输入一个整数\"\"并且小于等于10\"\"输入的数小于等于0\"\"输入的数大于0\"输入的数小于等于 0_输入 5 和回车键，内存状态和输出结果为：int numeber5\"请输入一个整数\"\"并且小于等于10\"\"输入的数小于等于0\"\"输入的数大于0\"输入的数大于 0并且小于等于 10_输入 20 和回车键，内存状态和输出结果为:int numeber20\"请输入一个整数\"\"并且小于等于10\"\"输入的数小于等于0\"\"输入的数大于0\"输入的数大于 0_例 3.5 程序的流程，如图 3.16 所示。内部资料 严禁外传79cout << \"\\n请输入一个整数：\"number>0cout << \"\\n输入的数大于0\" << endltruefalsecout << \"\\n输入的数小于等于0\" << endlint numbercin >> numbernumber >= 1 && number <= 10cout << \"\\n输入的数大于0\" << endltruefalse图 3.16 判断一个数正负的流程如图 3.16 所示，if 语句的第一个分支中包含了一条 if 语句，只有一个分支。if 语句的第二个分支中也可包含一条 if 语句。如，根据输入的字符，输出不同的内容。代码如例3.6 所示。【例 3.6】根据输入的字符分情况输出。#include<iostream>#include<conio.h>using namespace std;void main(){cout << \"please input the b key to hear a bell，\\n\";char ch = getchar();if (ch == 'b'){cout << '\\a';}else{if (ch == '\\n')cout << \"what a boring select on..…\\n\";elsecout << \"bye!\\n\";}}例 3.6 程序，等待输入一个字符，如果是 b，则响铃，否则，如果是回车，则输出“what a boring select on..…”，否则，输出“bye!”。上面这句话逻辑不清，也不符合平时的表达习惯，读起来很难受，将它改写成如下代码：内部资料 严禁外传80cout << \"please input the b key to hear a bell，\\n\";char ch = getchar();if (ch == 'b')cout << '\\a';else if (ch == '\\n')cout << \"what a boring select on..…\\n\";elsecout << \"bye!\\n\";将“else if”翻译成“如果”，其语义的逻辑会更清晰，读起来就会更加通顺。如果是b，则响铃，如果是回车，则输出“what a boring select on..…”，否则，输出“bye!”。修改后的流程，如图 3.17 所示。char ch = getchar()ch == '\\n'cout << \"what a boring select on..…\\n\"truefalsecout << \"bye!\\n\"cout << \"please input the b key to hear a bell，\\n\"falsetruech == 'b'cout << '\\a'图 3.17 修改后的流程如图 3.17所示的流程，条件为真时，流向右边，为假时，往下流动。()如果说，表达式来自数学中的公式，那么，计算机语句就来自于语文中的语句，因此，学好了语文就能编写出简洁通顺的代码。3.3.5 多分支 If …else if …else可以通过 if 语句嵌套实现多分支结构，其代码框架如下：if (条件1)内部资料 严禁外传81语句1;else if (条件2)语句2;......else if (条件n)语句n;else语句;其流程简单清晰，依次判断条件是否为真，如果为真，就执行后面的语句并结束，如果所有条件都不满足，则执行最后一条语句。例如，采用多分支模式实现，提示用户输入一个整数，如果这个整数在 1~4 之间，则输出合适的 knick-knack 信息；如果用户输入的数不在这个范围内，则输出一个错误信息。knick-knack 程序代码如例 3.7 所示。【例 3.7】knick-knack 程序。#include<iostream>using namespace std;void main() {int number;cout << \"\\n 请输入一个整数\";cin >> number;cout << \"\\n He played knick-knack\";if (number == 1){                   //输出 knick-knack 信息cout << \"with his thumb. \\n\";}else if (number == 2){cout << \"with my shoe.   \\n\";}else if (number  == 3){cout << \"on his knee.    \\n\";}else if (number == 4){cout << \"at the door.    \\n\";}else{                           //错误检查，其他数字都不合格cout << \"\\n Whoa！He doesn't play knick-knack there！\\n\\n\";}}使用 if-else if-else 多分支模式，逻辑简单清晰，很容易发现程序的错误。如果使用一系列独立的 if 语句，就需要分别检查所有小于 1 和大于 4 的值，编写程序容易出现错误，可读性也非常差。knick-knack 中的多分支流程，如图 3.18 所示。内部资料 严禁外传82cout << \"with my shoe.   \\n\"cout << \"\\n Whoa！He doesn't play knick-knack there！\\n\\n\"cout << \"\\n请输人一个整数\"cout << \"with his thumb. \\n\"int numbercin >> numbercout << \"\\n He played knick-knack\"number == 1number == 2number == 3number == 4cout << \"on his knee.    \\n\"cout << \"at the door.    \\n\"falsetruefalsefalsefalsetruetruetrue图 3.18 knick-knack 多分支流程如图 3.18 所示的流程中，向下分支是“假”， 向右分支是“真”。在编写程序时，如果不能达到这个要求，可使用逻辑运算！调整其分支方向。",
    "3.4 使用 switch 语句 ": "在数学中有一类特殊的函数，将一个范围内的数映射为一个整数，这类函数常常用于定性分析，应用非常广泛。如y =  20 ,y = { 10 ≥ 605 < 60其中，前一个公式是将百分制的课程成绩转换为 5 分制的成绩后一个公式可将百分制的课程成绩转换为等级。常常使用类似上面的公式将课程成绩分成几个等级，然后按照等级评价学习效果或制定学习计划。计算机语言中，除了前面学习的 if 语句外，还提供了 switch 语句用于上述特殊的分支结构。switch 的语法为:switch(exp)内部资料 严禁外传83{case cexp1：语句块1；case cexp2：语句块2；……case cexpn：语句块n；default：语句块n+1；}其中，case后面的表达式都是整型常量表达式，如一个整数、一个字符或一个枚举型的值。switch的语义为:计算exp，得到整型、字符型或枚举型的值v，然后在case的常量表达式中依次查找值v，如果找到，则跳转到该case后面的语句，如果没有找到，则跳转到default后面的语句。Switch语句的流程，如图 3.19所示。语句块2truedefault语句块语句块1v=expv == cexp1v == cexp2v == cexp3v == cexp4语句块4语句块3truetruetruefalsefalsefalsefalse图 3.19 switch 语句的流程在这个流程图中，首先计算了 exp 得到一个值 v，然后再依次与 case 中的常量比较(常量不用计算)，效率比每次计算后再比较高，这也是 switch 的优势。细心的读者可以发现，在大部分情况下，我们只想执行一种情况下的语句块，而switch 的语义显然不满足这个要求，于是，switch 常与转向语句 break 合用，在 switch的语句块中增加 break。举例：输入一个年份，查看该年份所处的世纪有什么著名事件。 需要将年份转化为世纪，其数学公式如下。y =  100+1按照这个公式，可使用 switch 编写程序，代码如例 3.8 所示。 【例 3.8】按照世纪输出著名事件。#include <iostream>内部资料 严禁外传84using namespace std;void main(){int year;cout << \"请输入一个年份:\";cin >> year;//查看该年份所处的世纪有什么著名事件switch (year / 100 + 1)  //exp 是一个表达式{case 15: //常量cout << \"15 世纪：哥伦布环游世界！\\n\";break;case 18:cout << \"18 世纪：费城公约！\\n\";break;case 20:cout << \"20 世纪：人类登月！\\n\";break;default:cout << \"\\n 我不知道这个世纪有什么著名事件。。。\\n\";}}编程的关键是用表达式 year/100+1 表示年份 year 所处的世纪，其次，每个 case 语句块的最后一条语句都是 break，用以跳过后面的 case 语句块。按照世纪输出著名事件流程，如图 3.20 所示。cout << \"18世纪：费城公约！\\n\"cout << \"\\n我不知道这个世纪有什么著名事件...\\n\"cout << \"15世纪：哥伦布环游世界！\\n\"v=year / 100 + 1v == 15v == 18v ==20cout << \"20世纪：人类登月！\\n\"breakbreakbreaktruefalsefalsetruefalsefalsetrue图 3.20 按照世纪输出著名事件流程内部资料 严禁外传85在 switch 中，先计算表达式“year / 100 + 1 ”得到一个值 v，case 后面的都是常量，然后将得到的值 v 依次与这些常量比较，不用再计算表达式“year / 100 + 1 ”，而 if 语句需要多次计算这个表达式，因此，switch 的效率比 if 语句高。",
    "3.5 条件运算 ": "一条 if 语句可以包含多个表达式，但表达式不能包含语句，这是计算机语言的规定。表达式定义的运算序列一般都是顺序执行的，不支持分支流程。为了满足这个应用需要，C/C++提供了一个运算，它可以根据一个条件来判断下一步需要进行哪个运算，这个运算就是条件运算。3.5.1 条件运算的语法语义条件运算是 C/C++中唯一的 3 元运算，运算符为“？”和“：”两个单独的字符，其语法为 exp1 ? exp2 : exp3，用 “？”和“：”将三个操作数隔开，exp1 为条件，根据 exp1 的计算结果，决定计算 exp2 :还是 exp3。条件运算的语义语法，如表 3.5 所示。表 3.5 条件运算的语义语法运算符 名称 结合律 语法 语义或运算序列?  :  Conditional 从右到左 expf ? exp1 : exp2计算expf得到bool值b，若b为true，计算exp1得到变量x1或值v1；若b为false，计算exp2得到变量x2或值v2expftruefalseexp1变量x1或值v1exp2变量x1或值v1图 3.21 条件运算的流程与其他运算相比，条件运算比较特殊，有两个“唯一”，第 1、是唯一一个三目运算，第 2、唯一支持分支流程的运算。条件运算的流程，如图 3.21 所示。如，使用条件运算求两个数的最大值。int a=1, b=2, c;c = (a > b) ? a : b;其中，c = (a > b) ? a : b 是一个表达式，与使用 if 语句相比，代码更加简洁。内部资料 严禁外传863.5.2 条件运算表达式举例字母的大小写转换是常用的功能，用条件运算可以很方便地实现这个功能，下面就以大写字母转换成小写字母为例，学习条件运算。例如：char c = ‘A’;c = c>='A' && c<='Z' ? c+32 : c;上述表达式的功能是将变量 c 中的大写字母转换成小写字母。 表达式包含了赋值运算、条件运算、算术运算和逻辑运算，比较复杂。下面以这个表达式为例，介绍读表达式的完整步骤和方法：第 1 步，查运算表，第 2 步，标注运算的计算顺序，第 3 步，标注数据类型，第 4 步，写出运算序列，第 5 步，表达式求值。1. 查运算表表达式 c = c>='A' && c<='Z' ? c+32 : c 中，包含多个运算，可将这些运算从中找出来，列成一个表，以便后面使用。表达式 c = c>='A' && c<='Z' ? c+32 : c 中的运算，如表 3.6 所示。表 3.6 表达式 c = c>='A' && c<='Z' ? c+32 : c 中的运算运算符名称或运算 结合性 语法 语义或运算序列+ Addition从左到右exp1+exp2计算exp1得到值v1，计算exp2得到值v2，v1加v2得到值v3<=Less than orequal to从左到右exp1<=exp2计算exp1得到值v1，计算exp2得到值v2，如果v1<=v2成立，得到值为True，否则得到值为False>=Greater thanor equal to从左到右exp1>=exp2计算exp1得到值v1，计算exp2得到值v2，如果v1>=v2成立，得到值为True，否则得到值为False&& Logical AND从左到右exp1&&exp2计算exp1得到bool类型的值b1，若b1值为true，计算exp2得到bool类型的值b2，计算b1&&b2得到bool值b3；否则exp1&&exp2的结果为false?  : Conditional从右到左exp1  ? exp2 : exp3计算exp1得到bool值b，若b为true，计算exp2得到变量x1或值v1；若b为false，计算exp3得到变量x2或值v2= Assignment从右到左expL=expR计算 expL 得到变量x，计算 expR 得到值v，将值v转换为变量x的类型规定的存储格式，并存到变量x的内存，得到变量x2. 标注运算的计算顺序按照运算的优先级，表达式 c = c>='A' && c<='Z' ? c+32 : c 中，最后计算的运算是=，倒数第 2 个的运算就是条件运算。条件运算的语义明确规定了，应先计算其中的条件c>='A' && c<='Z'，按照这个规定，在条件 c>='A' && c<='Z'寻找最先计算的运算，找到的内部资料 严禁外传87运算为运算>。寻找最先计算的运算的过程，如图 3.22 所示。c = c >= 'A' && c <= 'Z' ? c + 32 : c①图 3.22 寻找最先计算的运算的过程如图 3.22 所示，在确定计算顺序时，用到了条件运算的语义，要特别注意。 确定了条件 c>='A' && c<='Z'中所有运算的计算顺序后，可依次确定表达式 c+32 和 c中运算的计算顺序。整个条件表达式的计算顺序，如图 3.23 所示。c = c >= 'A' && c <= 'Z' ? c + 32 : c①②③④⑤⑥图 3.23 条件表达式的计算顺序3. 标注数据类型按照表达式 c = c>='A' && c<='Z' ? c+32 : c 的计算顺序，根据附录《运算表》中运算的语义，依次确定每个运算结果的数据类型，并在计算顺序图上标注。标注数据类型后的计算顺序图，如图 3.24 所示。c = c >= 'A' && c <= 'Z' ? c + 32 : c①②③④⑤⑥boolboolboolcharcharcharchar图 3.24 为所有运算标记计算结果的类型如图 3.24 所示，表达式在计算过程中，不需要增加自动类型转换，非常安全。 条件运算和逻辑运算的语义比较复杂，在标注数据类型过程中，可画出表达式的运算序列图，以方便计算表达式的值时使用。条件表达式的运算序列，如图 3.25 所示内部资料 严禁外传88'A'v1>=&&①②=？：c'Z'v3>=cv2v432v6+ccv5v7v8v9cc③④⑤⑥图 3.25 条件表达式的运算序列在如图 3.25 所示的运算序列中，标出了所有的运算步骤，但没有表示出&&和条件运算的语义。在计算表达式时，还需要根据具体的计算结果并结合&&和条件运算的语义，判断第 2 步和第 4 步是否执行。4. 表达式的求值表达式 c = c>='A' && c<='Z' ? c+32 : c 中，包含了条件运算，可分三种不同选择变量 c的值，并计算表达式，以验证其正确性。讨论按照&&和条件运算的语义计算条件表达式的过程。 第一种情况：当 c 为’A’时的计算过程，如图 3.26 所示。c = c >= 'A' && c <= 'Z' ? c + 32 : c①②③④⑤⑥boolboolboolcharcharchartruetruetrue'a''a''a'图 3.26 当 c 为’A’时的计算过程在计算第 3 步&&时，因 c>='A' 结果为 true，按照&& 的语义，计算第 2 步中的c<='Z'。在计算第 5 步条件运算时，因第 3 步的结果为 true，按照条件运算的语义，计算第4 步 c+32 而没有从变量 c 中取值。第二种情况：当 c 为’c’时的计算过程，如图 3.27 所示。c = c >= 'A' && c <= 'Z' ? c + 32 : c①②③④⑤⑥boolboolboolcharcharchartruefalsefalse'c''c'图 3.27 当 c 为’c’时的计算过程内部资料 严禁外传89在计算第 5 步条件运算时，因第 3 步的结果为 false，按照条件运算的语义，没有计算第 4 步 c+32 而从变量 c 中取值。第三种情况：当 c 为’6’时的计算过程，如图 3.28 所示。c = c >= 'A' && c <= 'Z' ? c + 32 : c①②③④⑤⑥boolboolboolcharcharcharfalsefalse'6''6'图 3.28 当 c 为’6’时的计算过程按照&&和条件运算的语义，计算时跳过了第 2、第 4 步。",
    "3.6 I/O 流及其运算 ": "“流”是一个抽象概念，在计算机中的应用非常广泛。用流描述网络中的数据，称为数据流，描述视频、音频数据，称为视频流、音频流，描述文本数据，称为字符流，描述二进制数据，称为二进制数据流。计算机的操作系统预先定义了输入设备、输出设备、错误输出设备和日志输出设备四个标准输入输出设备供程序中使用。缺省情况下，标准输入设备映射到键盘，标准输出设备和标准错误输出设备映射到显示器，标准日志输出设备映射到打印机。四个标准设备都属于字符设备，计算机中，使用“字符流”的方式输入输出数据，详见 2.9 节中的字符流工作原理和控制输出格式的方法。C++在 iostream 头文件中预定义了 cout、cin、cerr 和 clog 四个“流”对象，分别对应计算机的输入设备、输出设备、错误输出设备和日志输出设备四个标准输入输出设备。为 cout、cerr 和 clog 定义了插入运算“<<”，实现输出功能，为 cin 定义了插入运算“>>”，实现输入功能。插入运算的语法语义，如表 3.7 所示。表 3.7 插入运算的语法语义运算符名称或运算 结合性 语法 语义或运算序列<<插入运算Insertionoperator从左到右cout<<exp计算exp，得到T类型的值v，将v1按照T类型和显示格式转换为字符串s，在标准输出设备的当前光标处依次显示s中的字符，光标自动移到下一个位置，返回cout对象>>插入运算Insertionoperator从左到右cin>>exp计算表达式exp得到变量x，按照变量x的数据类型从标准输入设备上读入字符串并转换为相应数据类型的值v1，保存到变量x，得到cin学习cout和cin目的不仅是为了输入输出数据，而且是为了使用流来进行数据交换，如文件流、字符流、二进制流等。内部资料 严禁外传903.6.1 输出数据输出插入的运算符为“<<”，语法为 cout<<exp，语义为，计算 exp，得到 T 类型的值v，将 v 按照 T 类型和显示格式转换为字符串 s，在标准输出设备的当前光标处依次显示 s中的字符，光标自动移到下一个位置，返回 cout 对象。插入运算<<的语义，如图 3.29 所示。输出插入运算是根据字符流工作原理定义的，详见 2.9 节中的字符流工作原理。 与其他运算一样，输出插入运算也有运算结果，只是运算结果为 cout 对象，而不是显示的内容。算术运算的结果是所需的功能，运算结果与功能统一，但输出插入运算的结果与功能分离，运算结果是 cout 对象，功能才是输出一个值的内容。cout<<exp字符串sexpcoutvcout输出到输出字符流按数据类型转换输出格式图 3.29 插入运算<<的语义例如，int x = 3;float y = -7.5;cout <<\"In add(), received \"<< x <<\" and \" << y << endl;其中，使用插入运算实现了输出功能。输出表达式的计算顺序，如图 3.30 所示。①②③④⑤coutcoutcoutcoutcoutcout << \"In add(), received \" << x << \" and \" << y << endl图 3.30 输出表达式的计算顺序执行到该表达式时的内存状态，如图 3.31 所示。3-7.5int xfloat y“In add(),received”图 3.31 执行输出表达式时的内存状态计算机按照如图 3.30 所示的计算顺序，根据插入运算<<的语义逐个执行输出表达式内部资料 严禁外传91中的 5 个运算。执行输出表达式前，屏幕上的输出结果：_计算机屏幕上的光标在左上方，空白处的横线代表光标。 ①运行 cout << “In add(), received ” 输出的是字符串“In add(), received ”，跳过前面的步骤，直接输出字符串。从当前光标处开始，一个一个地输出“In add(), received”中的字符，每显示一个字符光标自动移到下一位置。屏幕上的输出结果：Inadd(),received_②运行 cout<<x 输出的是变量 x，从取变量 x 的值开始执行插入运算<<的语义。首先，从 x 指定的内存单元中取出 int 类型的值 3，并按照 int 类型的缺省显示格式将整数 3 转换为字符串“3”，然后，从光标处开始，在屏幕上显示字符串“3”中的字符，最后返回 cout 对象。屏幕上的输出结果。Inadd(),received3_③运行 cout << “ and ” 逐个显示字符串“ and ”中的字符, 具体步骤同①。在屏幕上输出结果：Inadd(),received3and_④运行 cout << y 输出 int 变量 y 的值，具体步骤同②。屏幕上的输出结果：Inadd(),received3and-7.5_⑤运行 cout << endl endl 是 endline 的缩写，对应 ASCII 码中的“回车”“换行”两个不可见字符，含义为将光标移到下一行的第 1 个位置。屏幕上的输出结果：Inadd(),received3and-7.5_至此，整个表达式执行完毕，屏幕上也输出了 In add(), received 3 and -7.5，光标在下一行的第 1 个位置。3.6.2 输入数据输入插入的运算符为“>>”，语法为 cin>>exp，其语义为，计算表达式 exp 得到变量x，按照变量 x 的数据类型从标准输入设备上读入字符串并转换为相应数据类型的值 v1，保存到变量 x，得到 cin。输入插入运算>>是输入，与输出插入运算<<的功能相反，两都的语义也相反，但它们的运算结果都是一个流。输入插入>>运算的语义，如图 3.32 所示。内部资料 严禁外传92cin>>expT类型的值vcinexp变量类型T输入字符流cin存入变量a按数据类型转换变量a从字符流中提取字符字符串s图 3.32 输入插入>>运算的语义如图 3.32 所示，与输出插入运算相比，计算表达式 exp 得到变量 x，而不是一个值；其核心内容是“按照变量 x 的数据类型从标准输入设备上读入字符串并转换为相应数据类型的值 v1，保存到变量 x”，从键盘读入用户输入的字符串，并按照“字符流”的方式转换为相应数据类型的值 v1，然后保存到变量 x，最后的结果为输入流的对象 cin。例如，输出一个整数到一个变量 a，然后输出变量 a 的值。代码如例 3.9 所示。 【例 3.9】输入一个整数并输出#include <iostream>#include <iomanip>using namespace std;void main(){//输入整数int a;cin >> a;cout << a << \",0x\" << hex << a << endl;}程序运行到cin >> a时，等待用户输入数据。用户在键盘输入“123”，此时屏幕上结果为：123_此时，计算机还没有将用户输入的字符串“123”送给程序，字符串还在计算机的缓冲区。当用户再输入一个回车，计算机才将输入的字符串以字符流的形式送给程序。输入一个整数的字符流，如图 3.33 所示，这时，字符流中的当前位置为第 1 个数字“1”。当前位置123int a逐个提取数字,并转换为int内存中的数据输入字符流1 2 3 图 3.33 输入一个整数的字符流变量 a 是 int 类型，按照整数的记数法内部资料 严禁外传93±dndn-1…d1d0只能包含符号和数字，因此，cin 从字符流中提取第 1 个字符 1，是数字，并将当前位置移到第 2 个字符 2；继续提取第 2 个字符 2，是数字，并将当前位置移到第 3 个字符 3；继续提取第 3 个字符 3，是数字，并将当前位置移到第 4 个字符回车；继续提取第 4 个字符，不是数字或符号，结束从字符流中提取字符。cin 从字符流中提取到字符串“123”，然后将字符串“123”转换为整数 123，存储到变量a 的内存。后面的输出语句，将变量 a 中的值取出来，显示在屏幕上。内存状态和输出结果为：int a123\"0x\"123123,0x7b_读者可分别输入“123”(其中表示空格)、“12.3”和“12b3”，观察程序的输入输出情况以理解 cin 的工作原理。例如：输入实数float b;cin >> b;cout << dec << b << \",\" << scientific << b << endl;运行时输入“2.33333333333”，内存状态和输出结果为：float b2.33333333333\",\"2.333333333332.33333,2.333333e+000_常用的实数记数法为：±dndn-1…d1d0.d1d2…dm其中，di、di 为 0123456789 中的一个数字。按照这种实数的记数法，一个实数可包含符号、数字和小数点。cin 从输入字符流中提取字符时，遇到符号、数字和小数点以外的字符，就结束提取。其过程为，cin 从“2.33333333333”中读取一个字符‘2’，是数字，读取一个字符‘.’，是实数中的小数点，读取一个字符‘3’，是数字，直到读取一个字符‘’，不是实数中的符号，结束读取字符，得到一个字符串“2.33333333333”，然后将它转换为 float 数2.333333，存储到变量 b。将“2.33333333333”转换为 float 数 2.333333 时，因实数存在精度问题，在转换时将超出 float 有效位数的部分扔掉了，只保留了 7 位有效数字(也可能是 6 位有效数字)。读者可输入“+23.45”、“-12.34”等带符号的实数，也可将变量 b 的数据类型改为内部资料 严禁外传94double，再运行程序，观察输入输出情况，理解输入流的工作原理。实数的科学记数法，其格式如下 ：±0.12 …  × 10±…10可输入“-34.56e+4”等科学记数法的实数，观察输入输出情况，理解输入流的工作原理。例如：输入多个数。int x;double d;cout << \"输入：\"<<endl;cin >> x >> d;cout << \"输出：\" << endl;cout << x << \",\" << d << \",\" << setprecision(18) << d;其中，表达式 cin >> x >> d 的计算顺序，如图 3.34 所示，读者可自己写出其语义并画出程序的内存图。cin >> x >> d输入流 cin①②输入流cin图 3.34 表达式 cin >> x >> d 的计算顺序第一次运行时，内存状态和输入输出：int x1double d1.1234567890123457890\"输入：\"\"输出：\"\",\"\",\"输入：11.12345678901234567890输出：1,1.12346,1.1234567890123457_执行 cin >> x 时，用户输入第一个回车后，计算机将回车送给 cin，cin 判断接收到的是回车，扔掉，继续等待；用户输入“1”后，计算机将“1”送给 cin，cin 从“1”读入数字 1，再读入回车，判断出不是数字或符号，就将读到的字符’1’，转换为整数 1，并转换为二进制存储到整型变量 x 的内存。最后，返回 cin，跳转去执行 cin >> d。执行 cin >> d 时，cin 接收到前面未处理的回车，判断后扔掉，继续等待；用户输入“1.12345678901234567890”后，计算机将其送给 cin，最终，cin 将其转换实数存储到变量 d。输入过程中字符流的三个状态，如图 3.35 所示内部资料 严禁外传95初始位置1  1 . 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 执行cin >> x后的位置1  1 . 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 执行cin >> d后的位置1  1 . 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 图 3.35 输入过程中字符流的三个状态第二次运行时，内存状态和输入输出为：int x1double d1.123456\"输入：\"\"输出：\"\",\"\",\"1 1.234561,1.23456,1.2345600000000001_上面两次运行程序，一次用回车‘’分隔两个数，一次用空格‘’分隔两个数，都能得到预期结果。读者可以输入“12,23.8”、“23a456”等使用其他字符分隔数字，观察运行时变量的值，理解输入流的工作原理。输出流的基本特征是，每次输入一个字符，字符在光标处显示，然后光标就自动移到下一个位置，输入流的基本特征是，每次从当前位置读取一个字符，并将当前位置自动后移一个位置。不管是输出流还是输入流，都有个“当前位置”的概念，每输出或读取一个字符，“当前位置”都会自动移到下一个位置，这种处理方式中的字符如水一样不断从人的面前(当前位置)流过，所以形象地称为“流”。“流”是编程中非常重要的模式，应用广泛，读者可通过学习输入流，培养“流”这种思维模式。",
    "3.7 分支的调试与维护 ": "分支是由分支语句实现的，应从两个层次进行调试，第一、调试分支语句的流程，判断流程是否正确，第二、判断语句中包含的表达式是否正确。前面学习了调试表达式的方法，下面重点介绍调试程序流程的方法。3.7.1 代码格式的重要性代码格式的书写规范性是对编写程序的基本要求，也是调试程序的基础，初学者一般意识不到它的重要意义。目前的编程环境一般都提供了自动规范代码格式的功能，如在 VS2013 编程环境中编辑代码时，会自动调整代码的格式。如果出现语法错误，会给出错误提示，代码格式也会内部资料 严禁外传96乱。如例 3.7 knick-knack 程序中的代码格式，借助了 VS2013 编程环境，能反映如图 3.18所示的多分支结构。借助编程环境纠正代码中的语言细节错误，并规范代码的结构，是一个好的方法。 按照规范书写程序，在输入代码时就能发现很多语法错误，能缩短调试的时间，提高调试的效率。代码书写规范是程序员的基本功，也能体现程序员的基本素质。3.7.2 调试分支的逻辑错误调试分支的主要目标是确保每种情况都是正确的，基本方法是每种情况选择一组数据，分别在这些数据组上执行程序，通过调试器观察程序执行流程及变量的值，对比人工执行流程和表达式的计算结果，判断程序是否正确。如例 3.7 中的程序，总共分了 5 种情况，需要为 number 分别选择 1、2、3、4 四个值，加上一个其他的值，至少执行程序 5 次。每次执行程序时，判断每次输入的数是否按照预期的流程执行，是否得到期望的输出结果。如果执行流程不符合预期，一般都会人工计算条件表达式，并比较计算机中变量的值，确定 bug 的位置，再修改程序。在跟踪调试分支代码时，总希望能从代码的结构中直接读出代码的流程，因此，要求在设计分支流程时，提前考虑，按照流程写出的代码结构能否体现的分支流程。例如：从键盘输入一年份，判断该年份是否为闰年，并将结果打印在屏幕上。 根据以往的知识知道：如果某年能被 4 整除并且不能被 100 整除，该年能被 400 整除，则该年为闰年。很可能设计出两个非常类似的流程，其功能相同，流程结构也相同，但它们的判断条件互为“否定”，分支上真假值刚好相反。两个流程，如图 3.36 和图 3.37 所示。编写代码时会发现，按照图 3.36 所示的流程，适合使用 if 嵌套模式描述，写出的代码结构与流程的结构相差太大，从代码中很难发现有 4 个分支，导致设计测试用例困难，增加了调试代码的难度和工作量。而图 3.37 所示的流程，每个向下的分支都是“假”，适合使用多分支模式。使用多分支模式判断是否为闰年，如例 3.10 所示。【例 3.10】 使用多分支模式判断是否为闰年。#include <iostream>using namespace std;//该程序从键盘输入一年份，判断该年份是否为//闰年，并将结果打印在屏幕上//程序编号：void main(){int year;  //定义整型变量 yearcout << \"请输入年份:\";cin >> year; //从键盘年份if (year % 4 != 0)cout << year << \" is not leap.\" << endl;内部资料 严禁外传97else if (year % 100 != 0)cout << year << \" is leap.\" << endl;else if (year % 400 != 0)cout << year << \" is not leap.\" << endl;elsecout << year << \" is leap.\" << endl;}在调试程序时，直接从代码中就可很容易判断有 4 种情况，在调试程序时，为每种情况选择一个具体的年份，覆盖每条分支，如为 year 分别选择 2007、2000、1900 和 2020 四个值，然后分别执行程序 4 次，并判断每次输入的数是否按照预期的流程执行，是否得到期望的输出结果。如果不符合预期，说明程序存在 bug，需要重新修改程序，再运行调试程序，直到得到执行预期的流程并得到结果。Year%4==0输出不是闰年输入yearYear%100==0Year%400==0truetrue输出是闰年true输出是闰年输出不是闰年falsefalsefalse图 3.36 求闰年的流程图 1Year%4!=0输出不是闰年输入yearYear%100!=0Year%400!=0falsefalse输出是闰年false输出是闰年输出不是闰年truetruetrue图 3.37 求闰年的流程图 2调试程序时，输入的数据集称为测试用例，设计出的测试用例对调试的工作量和调试质量有很大影响，因此，调试程序的关键是设计测试用例，调试分支程序的基本方法称为“分支覆盖”，即设计出的测试用例刚好覆盖每条分支。在调试程序时，可采用单步跟踪方式观察程序的执行流程，并观察变量中的值，以判断执行流程是否符合预期，中间结果是否正确，最后通过观察程序的输出结果判断程序是否正确。还可使用下面的条件表达式判断是否为闰年。(year % 4 == 0 && year % 100 != 0) || year % 400 == 0使用条件表达式编写的代码比较短，但需要对条件表达式进行深入分析才能设计出测试用例，增加了调试的难度。内部资料 严禁外传98",
    "3.8 本章小结 ": "本章主要学习了构造分支结构的方法和分支程序的 4 种典型编程模式，学习了使用I/O 流实现输入输出方法，学习使用流程图描述程序流程的方法。学习了构造分支结构的基本知识和原理，重点学习单分支、双分支、嵌套和多分支 4种典型编程模式，学习了 if 语句和 switch 语句，需要掌握使用分段函数构造分支结构的方法，能够从分支程序的 4 种典型编程模式中选择适当的编程模式，掌握使用分支语句描述分析结构的方法。学习了关系运算、逻辑运算和条件运算，深入学习了使用关系运算和逻辑运算描述分支条件的方法，学习了使用条件运算描述分支结构的方法，需要掌握使用计算顺序图计算关系表达式和逻辑运算表达式的方法。学习了输入流和输出流的工作方式，学习了 I/O 流及两个插入运算，学习了使用 I/O流实现输入输出的方法，为今后学习文件流、字符串打下基础。学习使用流程图描述程序流程的方法，需要掌握使用流程图描述顺序结构和分支结构的方法。学习了调试和维护分支程序的基本知识和基本方法，深入学习了通过分支流程发现逻辑错误的方法，需要学会通过流程图调试程序。",
    "3.9 习  题 ": "1. 读程序并完成各问题。# include<iostream># include<conio.h>using namespace std;int main(){cout << \"please input the b key to hear a bell，\\n\";char ch = getchar();if (ch == 'b'){cout << '\\a';}else {if (ch == '\\n')cout << \"what a boring select on..…\\n\";elsecout << \"bye!\\n\";}}1) 程序运行时，分别从键盘输入 a、b、回车键，写出运行结果。2) 将程序中的 ch == 'b'替换为 ch = 'b'，程序运行时，分别从键盘输入 a、b、回车键，写出运行结果。3) 画出程序的流程图。内部资料 严禁外传992. 结合 ASCII 码表编写程序，实现输入一个字符并判断输入的字符是否是英文字母(包含大小写)。3. 编程实现输入三个整数，输出其中的最大值。先用 IF 语句，再用条件运算编程实现4. 编程实现输入一个整数，判断其是否能被 2，5 整除，并输出以下信息: 1) 能被 2 整除2) 能被 5 整除3) 能被 2 和 5 同时整除5. 编程实现输入一个整数，判断其是否能被 4，25 整除。6. 编程实现输入一个百分制的整数成绩，输出相应的五分制成绩，90 分以上为“A”，80至 89 分为“B”，70 至 79 分为“C”，60 至 69 分为“D”，60 分以下为“E”。7. 编写程序求一元二次方程ax2 + bx + c = 0的根，并调试通过。内部资料 严禁外传100"
  },
  "构造循环": {
    "构造循环": "在大数据智能化时代，越来越多的重复性脑力劳动岗位被计算机取代，为人们做创造性强的工作提供了更多时间。计算机特别擅长做重复性工作，而循环是重复性工作的基础，也是强大计算能力的源泉，因此，构造循环在编程中具有非常重要的作用。",
    "4.1 从顺序到循环 ": "前面学习了表达式，学习了将数学公式改写为表达式的方法，但由于计算机语言只提供数学中基本的运算，没有提供在这些基本运算上定义的相对复杂的运算，因此，大量的数学公式不能直接用表达式表示出来，需要编程来实现，其中有很大部分需要用到循环结构。在中学学习的开方、求对数等算术运算或初等函数，求和、求平均值等统计公式，在高等数学中学习的极限、微分、积分等，例如：、√2、log  、 sin  、 ∑ =1、limx→∞ () 、 ∫ ()这些相对复杂的数学运算都有明确的数学计算公式，但计算机语言没有设计这类复杂的数学运算，需要编程实现。这些数学运算可构建很多复杂的数学公式，用于解决科学研究问题或工程应用问题，例如：∑ =1( + ) = ∑ () =0() = 0 + ∑ ( cos +  sin  )∞=1解决实际问题的数学公式可能非常复杂，但都是由数学中的数学运算构成的。下面学习使用计算机语言描述相对复杂的数学运算，使用这些复杂数学运算解决实际问题的基本方法。4.1.1 数列求和问题目前，人工智能的应用进入了一个新阶段，很多专家认为，统计是人工智能的重要基础，下面我们以统计学中最基本的数列求和为例开始学习构造循环结构的方法。如果有一个数列{an}1，2，… ，，… ，则数列中前 n 个数的和 Sn 为1 + 2 +  +  +  + 记为内部资料 严禁外传101∑ =1当 n 从 1 开始增加到 m 时，Sn 也构成如下数列{Sn}1，2， … ，，… ，数列的表示方法主要有两种，第 1 种，通项公式法，用通项公式来表示数列中的每一个数 ai，第 2 种，列举法，顾名思义，就是列出数列中的数。有些数列的数之间有规律，如等差数列、等比数列，可以用通项公式表示数列中的每个数，但有些数列的数之间没有规律，就可以用列举法表示数列中的数。数学中有大量具有通项公式法的数列，它们在科学研究和工程计算中有非常重要的作用。我们先从自然数这种最简单的数列开始，讨论这类数列的求和问题。自然数 1、2、3、…，构成一个无限数列，求前 n 项之和 Sn 的公式为 = 1 + 2 + 3 +  + n这个公式很重要，为了后面表述方便，我们将它称为累加和公式，简称累加和。 如果在编写程序时已经知道 n 的值，而 n 的值又比较小时，很容易写出求和的算式，如S5 = 1 + 2 + 3 + 4 + 5编程时直接将上面的算式改写为计算机表达式，就能求出 S5 的值。 但当 n 非常大，或者编程时不知道 n 的值时，这个方法就不适用了，需要使用其他的方法。自然数构成一个等差数列，可以使用数学中的等差数列求和公式计算 Sn 的值。 = 1 + 2 + 3 +  + n=(1 + )2× 根据等差数列求和公式，可编写程序计算自然数的前 n 个数之和 Sn，代码如例 4.1 所示。【例 4.1】等差数列求和。#include <iostream>using namespace std;void main(){int n;double s;cin >> n;s = (1 + n) / 2.0 * n;cout << s << endl;}使用等差数列和等比数列的求和公式可以编程计算数列的和，如果没有类似的求和公式，如何编程计算数列的和？数学归纳法提供了解决数列求和问题的基本思路和方法。内部资料 严禁外传1024.1.2 数学归纳法中的递推数学归纳法(Mathematical Induction, MI)是一种数学证明方法，通常被用于证明某个给定命题在整个(或者局部)自然数范围内成立。在中学数学中，比较地系统地学习了数学归纳法。通过如下两步，能证明命题在自然数范围内都成立。I  证明 n = 1 时命题成立。 Ⅱ  假设 n=k 时命题成立，那么证明 =  + 1时命题也成立。 数学归纳法与其他证明方法完全不同，它属于构造式证明方法。数学归纳法的第 I 条是基础，证明了 n = 1 时命题成立，然后使用第Ⅱ条证明 n = 2 时命题成立，并将 k 增加1，变成 3，再使用第Ⅱ条证明 n = 3 时命题成立，以此类推，最终证明命题在自然数(n>1)范围内都成立。数学归纳法的构造证明过程，如图 4.1 所示。I.证明当n= 1时命题成立假设n=k时命题成立证明n=k+1时命题也成立k=1k+1k增加1II.假设n=k时命题成立，那么证明n=k+1时命题也成立图 4.1 数学归纳法的构造证明过程数学归纳法的构造证明过程中，无限次重复使用第Ⅱ条，构成一个无限循环，违反了“在有限时间内必须完成计算”的算法原则，但可在无限循环中增加一个结束条件。数学归纳法的算法式证明过程如图 4.2 所示。证明当k= 1时命题成立k=?证明k+1时命题也成立1k增加1n<nk+1I.证明当n= 1时命题成立II.假设n=k时命题成立，那么证明n=k+1时命题也成立图 4.2 数学归纳法的算法式证明过程如图 4.2 所示的算法式证明中，使用 k 来控制循环，并将 n 的值作为判断循环是否结束的依据，能够证明命题在[1,n]范围内成立。为了便于理解，将图 4.2 顺时针旋转 90 度，并用流程图描述其证明过程，算法式证明流程，如图 4.3(a)所示。将数学归纳法中的“命题”视为数学公式，用“计算”替换图 4.3(a)中的“证明”，得到递推计算流程，如图 4.3(b)所示，其中包含 4 个计算步骤。图 4.3(b)所示的递推计算流程中包含 4 个步骤： 第 1 步，根据数学归纳法的第 I 条，先计算 k=1 时的值； 第 2 步，判断 k 是否小于 n，如果 k 小于 n，则跳转到第 3 步，否则，已经计算出 n 时内部资料 严禁外传103的值，结束计算。第 3 步，根据数学归纳法的第Ⅱ条，通过 k 时的值计算 k+1 时的值； 第 4 步，k 增加 1，跳转到第 2 步继续计算。 在计算过程中，不断重复第 2 步到第 4 步，每重复一次 k 的值就增加 1，k 的值沿着 x坐标轴向前推进，所以这种构造方法被形象地称为递推，其中，“递”代表重复、循环，“推”指方向，每次重复都向前推进一点。k增加1k<n真假I.证明当k= 1时命题成立II.假设k时命题成立，证明k+1时命题也成立(a).算法式证明流程k增加1k<n真假I.计算k= 1时的值II.通过k时的值计算k+1时的值(b).递推计算流程图 4.3 数学归纳法中的递推证明和递推计算按照如图 4.3B 所示的递推计算流程，每次循环都能计算出一个值，显然，所有计算出的值构成了一个数列{}，其中，为第 k 次计算出的值。按照上面的讨论，递推计算就是在数列上进行计算，递推计算中的核心计算问题也从怎样“通过 k 时的值计算 k+1 时的值”转换为怎样“通过计算+1”。数学归纳法是循环结构的理论基础，数学归纳法中的递推是构造循环的基本方法。 下面以两个示例学习使用递推构造循环的方法。",
    "4.2 使用递推构造循环 ": "下面以累加和、调和级数为例，学习使用递推构造循环的基本方法。4.2.1 累加和按照累加和的数学定义，累加和本身就是对自然数构成的数列{i}进行求和，计算结果自然构成数列{Sk}0，1，2，… ，，… ，内部资料 严禁外传104其中，0 = 0，其他元素的通项公式为 = 1 + 2 + 3 +  + k = ∑ =1通项公式是用数列{i}中的元素计算出数列{Sn}中的元素，对通项公式做如下变换 = ∑ =1= ∑ 1=1+  = 1 + 得到通过数列{Sk}中前一个元素 Sk-1 计算后一个元素 Sk 的公式 = 1 + 这个公式被称为数列{Sk}的递推公式。 如图 4.3B 所示的递推计算流程中，通过 k 时的值计算 k+1 时的值，当 k=n-1 时，已经计算出计算 n 时的值，但数列{Sk}的递推公式中，通过 sk-1 计算 sk，当 k=n-1 时，只计算出 sn-1，没有计算出 sn，因此，需要调整如图 4.3B 所示的递推计算流程中的循环条件，将循环条件修改为“k≤n”，增加一次循环。调整后的递推计算流程，如图 4.4A 所示。在图 4.4A 所示的递推计算流程中，用计算第 1 个元素 s0 的公式和递推公式 =1 + 替换相应的内容，得到构造计算累加和的递推算法流程，如图 4.4B 所示。A.递推计算流程B.计算累加和的递推算法流程k增加1k≤n真假I.计算k= 1时的值II.通过k-1时的值计算k时的值具体化为具体化为C.计算累加和的程序流程k=k+1k<=n真假int s=0,k=1,n=5s=s+kk增加1k≤n真假S0=0,k=1Sk=Sk-1+k图 4.4 构造计算累加和的递推算法流程按照如图 4.4B 所示的计算累加和的递推算法流程计算 S5，总共循环了 5 次。计算 S5的过程，如表 4.1 所示。表 4.1 计算 S5 的过程初始 第1次循环 第2次循环 第3次循环 第4次循环 第5次循环 第6次循环下标k 1 1 2 3 4 5 6Sk 0 1 3 6 10 15如表 4.1 所示的计算过程中，进入循环前，先将 S0 设置为 0，然后进入循环，按照递推公式 Sk= Sk-1+k 依次计算 S1= S0+1、S2= S1+2、S3= S2+3、S4= S3+4、S5= S4+5，每次循环后对 k 增加 1，当 k=5 时，计算出 S5，当 k=6 时，退出循环，没有计算出 S6。内部资料 严禁外传105每次循环都使用递推公式 Sk= Sk-1+k 计算 Sk，但在计算时，只使用到 Sk-1 和 k 的值，因此，可定义变量 s 储存计算出的 Sk，并将递推公式 Sk= Sk-1+k 转换为表达式 s=s+k。将递推公式改写为表达式非常简单，原理是用一个变量存储数列的当前计算元素，用一个变量存储数列的下标，目的是去掉递推公式中的下标。在如图 4.4B 所示的算法流程图中，将递推公式替换为表达式，并增加定义变量、选择数据类型等计算机语言方面的细节内容，可设计出计算累加和的程序流程，如图 4.4C所示。按照如图 4.4C 所示的计算累加和的程序流程编写程序，代码如例 4.2 所示。【例 4.2】计算累加和程序。#include <iostream>using namespace std;void main(){int s = 0, k = 1, n;cin >> n;while (k <= n){s = s + k;k++;}cout << s;}输入输出结果：515_程序运行过程和结果与数学上的完全相同，也请读者自己调试程序。如输入 10 时，记录 i 和 s 值的变化，并与数学上的计算过程和结果对比。例程 4-2 中将递推公式 Sk= Sk-1+k 改写为表达式 s = s + k，但有有经验的程序更喜欢使用表达式 s += k 描述递推公式 Sk= Sk-1+k，如果再去掉例程 4-2 中输入输出语句等非核心代码，计算累加和的代码可简化为：int s = 0, k = 1, n=10;while (k <=n){s += k ;k++;}计算累加和的代码只有几条语句，很简单，但编写程序的思路非常重要。其编程思路为，根据数学归纳法中递推思想，使用数列上推导出一个递推公式，并用递推公式构造一个循环。内部资料 严禁外传1064.2.2 调和级数累加和是计算自然数列的前 n 项的和，而调和级数是计算数列{1}的前 n 项的和，其计算公式为() = 1 + 12+ 13+  + 1 = ∑ 1=1对公式进行推导() = ∑ 1 = ∑ 1 + 11=1=1= (  1) + 1变形得到其递推公式 = 1 + 1按照计算累加和的思路，参照图 4.4 可设计出计算调和级数的程序流程，如图 4.5 所示。s += 1.0/ii <= n是否cin >> nfloat s = 0;int  i = 1, n;cout << si++图 4.5 计算调和级数的程序流程按照如图 4.5 所示的流程，可编写计算调和级数的程序，代码如例 4.3 所示。 【例 4.3】计算调和级数。#include <iostream>using namespace std;void main(){float s = 0;//进行累加时，需要设置为 0int i = 1, n;cin >> n;内部资料 严禁外传107while (i <= n){s += 1.0 / i;//是实数 1.0 不是整数 1i++;cout << s << endl;}cout << s;}从编程方法上讲，编写计算调和级数的程序与编写累加和程序在本质上是一样的，都是使用递推计算一个数列的前 n 项之和，区别仅仅在于，一个是自然数构成的数列，一个是 1/n 构成的数列。因此，使用递推能够计算任意一个数列的连续 n 项之和。数列求和问题可以简化为累加和，然后再将求累加和的方法推广到级数的计算。4.2.3 while 语句数学归纳法中的递推有两个要点：一是构造一个循环；二是这个循环要向前推进。计算机语言设计了一些语句，专门用于描述计算过程中的循环，这种语句称为循环语句。while 语句是一条循环语句，可直接用于描述递推中的循环结构，其语法和语义清晰。 while 语句的语法为：while (exp)statStatement;   //语句其中，exp 是一个表达式，规定其计算结果应为 bool 类型，称为循环条件，statStatement是一条语句，很多时候为复合语句，称为循环体，当循环体中含有多条语句时，要用大括号将循环体中的语句括起来，否则编译器仅默认循环体的第一行语句为循环体。while 语句的语义，如图 4.6 所示。计算表达式 exp 得到 bool 类型的值 v1，如果值 v1为真为假(fasle)，则结束 while 语句，如果值 v1 为真(true)，则执行语句 statStatement。语句 statStatement 执行结束后，继续计算并判断表达式 exp 的值，直到表达式 exp 的值为假。statStatementexp真假图 4.6 while 语句的语义while 语句首先计算循环条件，再根据计算结果，判断是执行循环体还是退出循环。while 语句有两个特点，第 1，循环条件至少计算一次；第 2、必须在有限次循环后退出，内部资料 严禁外传108不能无限循环。例 4.2 和例 4.3 的代码中，都使用 while 语句描述递推计算流程，但也可以使用 while语句描述重复性的事情，如，将 hello world 在屏幕上输出 50 遍，使用 while 语句可很容易编程出程序，代码如例 4.4 所示。【例 4.4】打印 50 遍 hello world。#include <iostream>using namespace std;void main(){int count = 0;           //设置初始条件，不可缺少while (count < 50)   //循环条件用于判断是否结束循环{cout << \"\\n hello world\";count++;  //修改循环计数}}例 4.4 的代码中，循环了 50 次，每次循环 count 增加 1 并输出一行 hello world，将总共在屏幕上输出 50 遍行 hello world。例 4.4 中，只有递推计算中的“递推”，没有递推计算中的“计算”，功能非常简单，没有解决什么实际问题，但其中的代码包含了使用“递推”构造循环的三个要点：初始条件、循环条件和循环计数。初始条件和循环条件用于控制循环的进入和退出，循环计数用于控制循环中的“递推”，可通过改变初始条件、循环条件、循环计数构造出各种各样循环流程。递推计算中的“递推”用于构造循环流程，递推计算中的“计算”用于实现程序功能。循环语句只是描述循环结构的工具，关键是掌握构造循环的方法。4.2.4 逗号运算在前面求数列的累加和示例中，使用递推公式si = si1 + i构造了计算数列 s 中各个数的计算序列。s0，s1 = s0 + 1，s2 = s1 + 2，s3 = s2 + 3， … ，sn = sn1 + n在上述计算序列中，用逗号(,)分隔算序列中的计算，并以从左到右的次序计算其中的计算。C/C++语言也提供逗号运算(,)，语法为“exp1，exp2”，是一个二目运算，语义为，先计算 exp1，再计算 exp2，运算的计算结果为右边表达式 exp2 的计算结果。结合性为从左到右，优先级是所有运算中最低的。逗号运算语法语义，如表 4.2 所示。表 4.2 逗号运算语法语义运算符 名称 结合律 语法 语义或运算序列， Comma 从左到右 exp1，exp2先计算exp1得到变量x1或值v1，再计算exp2得到变量x2或值v2，最后的计算结果为变量x2或值v2内部资料 严禁外传109例如：交换两个变量 a 和 b 的值，可用如下的代码。int a = 1, b = 2, t;t = a, a = b, b = t;其中，表达式“t = a, a = b, b = t”被视为一个整体，实现两个变量 a 和 b 值的交换，其语义为，从变量 a 中取出值，赋值给中间变量 t，然后将变量 b 的值赋值给变量 a，最后将中间变量 t 中的值赋值给变量 b。如果不用中间变量，写成“a = b, b = a”，其语义为，将变量b 的值赋值给变量 a，再将变量 a 的值赋值给变量 b。当执行“将变量 b 的值赋值给变量a”时，变量 a 的值已经被覆盖了，所以交换两个变量的值必须使用一个中间变量，而且次序必须正确。如果将“t = a, a = b, b = t”改写为“t = a;a = b; b = t”，构成三个表达式语句，实现的功能完全不变，但违反了一行不能超过一条语句的规范，因此，不能放在一行上，需要用三行，这样很难将它们视为一个整体。",
    "4.3 循环变量模式 ": "计算累加和程序非常简单，有点编程经验的程序员不用思考就能编写出来，但前面花了大量篇幅讨论其编程方法，有什么意义？计算累加和程序具有两个特点，第 1、在数列上进行递推计算，第 2、通过数列的下标来控制循环。将具有上述两个特点的循环结构称为循环变量模式。循环变量模式是最基本循环结构，也是最常用的循环模式。4.3.1 循环变量模式的流程框架递推计算是解决复杂计算问题的重要方法，递推计算中包含“递推”和“计算”。“递推”用于构造循环流程，是递推计算中的基础，相对稳定，而“计算”用于实现程序功能，与解决的实际问题紧密相关，千变万化。针对递推计算的上述特点，将“递推”和“计算”分开考虑，一方面专注于“递推”构造循环的方法，另一方面专注于解决实际问题。循环变量模式是在编写实践中总结出来的，主要解决实际应用中的构造循环问题，包含算法流程框架、程序流程框架和代码框架。算法流程框架和程序流程框架刻画循环流程及主要步骤。算法流程框架从算法角度描述循环流程中主要步骤，主要使用数学公式等数学语言，程序流程框架从程序角度描述循环流程中主要步骤，加入了相关的计算机知识，主要使用计算机中的术语。一般使用流程图描述循环变量模式的流程框架，如图 4.7 所示。代码框架使用计算机语言描述程序流程框架，更加接近于最终编写的程序。内部资料 严禁外传110开始值结束值步长s1,s2,…,sk-1,  sk,…,sn-1,sn向前递推k=1k=n调整到下一个元素下标k<=n真假计算s1递推公式A 算法流程框架B 数列C 程序流程框架循环变量+=步长循环变量<=结束值真假int 循环变量= 开始值循环体计算第1个s图 4.7 循环变量模式的流程框架如图 4.7A 所示的算法流程框架描述了递推计算的循环流程及其中的 4 个主要步骤，如图 4.7B 所示的数列{Sk}描述了递推计算中的数据，两者构成了一个完整的递推计算算法。如图 4.7C 所示的程序流程框架包含 5 个主要步骤，增加了一个循环变量，强调了使用这个循环变量来控制循环。第 1 步、计算数列{s}的第 1 元素 第 2 步、将数列元素的下标定义为循环变量并赋初始值 第 3 步、判断是否为数列中的最后一个元素 第 4 步、在循环体中使用递推公式计算数列的下一个元素 第 5 步、对循环变量增加一个步长，并返回第 3 步继续计算。 循环变量模式通过循环变量的初始值和结束值控制循环的次数，在循环开始前需要设置循环变量初值，每次循环时循环变量都要增加一个步长，为下次循环做准备。循环变量用于标识数列中的数，其数据类型一般为整数，初始值标识数列中的第 1 个数，结束值标识最后的数，每次循环后循环变量的值增加一个固定值，这个固定值称为步长，其含意是每走一步的长度。4.3.2 循环变量模式的代码框架按照图 4.7C 描述的程序流程框架，使用 while 语句可写出循环变量模式流程的代码框架。//计算数列的第1元素//int 循环变量=开始值while (循环变量<=结束值){//递推公式//循环变量+=步长内部资料 严禁外传111}在实际编程中，有经验的程序员一般都会根据图 4.7B 所描述的算法流程框架，“套用”上面的代码框架直接写出程序。如，计算公式：∑ =参考累加和程序，“套用”循环变量模式的流程图，并写出如下程序。int m=3, n=10;//从m累加到nint s = 0;int i = m;while ( i<= n){s += i;i++;}cout << s;与累加和程序相比，主要将循环变量 i 的初值修改为 m。 有经验的程序员头脑中仍然按图 4.7 描述的思维过程进行推导，只是省略了画出图4.7A 和图 4.7C 所示的流程图，因此，建议初学者不要省略其中的步骤，这样有利于提高自己的编程能力。看得到的是代码填空，看不到的是别人的思维过程。4.3.3 数列求积问题数列{an}的累乘积公式为∏ =1当数列为自然数时，就是阶乘 n!。! = 1 × 2 × 3 × … ×  = ∏ =1根据上面的公式，推导出递推公式! = ∏ =1=  × ∏ 1=1=  × (  1)!根据递推公式，设计出累乘的算法流程，并根据算法流程设计出其程序流程，如图4.8 所示。如图 4.8A 所示的算法流程中，使用数学公式描述递推计算的步骤，如图 4.8B 所示的程序流程中，使用计算机表达式描述。需要注意的是，循环变量 s 的初始值是 1，而不是内部资料 严禁外传1120。i=i+1i≤n真假i=1Si=Si-1×iS1=1i++i<=n真假int  i=1,ns*=iint s=1A.算法流程B.程序流程图 4.8 累乘的算法流程和程序流程根据如图 4.8 所示的流程，可编写出累乘积程序，如例 4.5 所示。 【例 4.5】累乘积程序。#include <iostream>using namespace std;void main(){int s = 1, i = 1, n;cin >> n;while (i <= n){s *= i;i++;}cout << s;}与累加和相比，计算累乘积的流程和程序只修改了个地方两点地方。第 1、变量 s 的初始值是 1，而不是 0，第 2、递推公式 s*=i 中是乘法，而不是加法+。掌握了上述特点后，可以将计算累加和的代码直接修改为计算累乘积的代码，从而省略了前面的分析步骤，以提高编程效率。在实际编程中，很多程序员也是这样做的，但需要说明的是，非常熟悉程序流程的情况下才能直接修改代码。看得见的是修改代码，看不见的是调整程序流程。 求阶乘的方法也可以推广到求数列的积。具体方法也是用数列的通项公式(或数)替换递推公式 s*=i 中的变量 i，其他不变。内部资料 严禁外传113",
    "4.4 嵌套循环编程模式 ": "嵌套循环编程模式也是构造循环的常用模式，其主要思路是分别构造多个循环，然后再采用嵌套的方式将构造的循环组合起来，形成一个完整的流程。如计算阶乘的累加和1 + 2! + 3! +  n!将公式变形为s = ∑ ∏ ==其中包含数列上求和与求积两个数学运算。令 = ∏ =1将其代入求和公式得到s = ∑ =上述两个公式分别构造了{ti}和{sk}两个数列，其中，sk 是数列{ti}上的和。 按照循环变量模式中的方法，在构造的两个数列上分别推导出递推公式，分别设计它们的流程，然后将计算 t 流程嵌套到计算 s 的流程中，构成一个嵌套的循环流程，如图 4.9所示。嵌入j=j+1j<=i真假计算tj = j× tj-11i=i+1i<=k真假计算s1si =  si-1+ ti计算 ti图 4.9 嵌套的循环流程内部资料 严禁外传114如图 4.9 所示，将求积的流程替换求和中的“计算 ti”，可得到计算阶乘累加和的完整流程。在嵌套流程时，有两个关键点，一是嵌套的位置，二是变量的值。递推公式 si =si-1+ti决定了求积的流程嵌套到求和的流程，嵌套位置在递推公式的前面；递推公式中的下标决定了计算数列中哪项，下标很重要，因此，在流程图中直接使用数学公式来表示。设计出流程后，可按照“自顶向下，逐步求精”的方法编写程序。  第 1 步，按照“自顶向下”，先写出求和的代码。int i = 1, s = 0;int k = 10;while (i <= k) {//计算tis += t;i++;}其中，注释“//计算 ti”相当于占位符，以便插入其代码。第 2 步，按照“逐步求精”的方法，在嵌套位置处写出求积的代码。int i = 1, s = 0;int k = 10;while (i <= k) {//计算tiint j = 1, t = 1;while (j <= i) {t *= j;j++;}s += t;i++;}最后，增加输入输出、#include 等语言方面的细节，编程出计算阶乘的累加和的程序，代码如例 4.6 所示。【例 4.6】计算阶乘的累加和。#include <iostream>using namespace std;int main(){//计算阶乘的累加和int i = 1, s = 0;int k = 10;while (i <= k){//求阶乘 i!int j = 1, t = 1;while (j <= i){t *= j;//阶乘递推公式j++;内部资料 严禁外传115}s += t;//累加递推公式i++;}cout << s;}例 4.6 程序中，一条循环语句包含了另一条完整的循环语句。 “自顶向下，逐步求精”是结构化程序设计的基本方法，在构造多重循环时，应按照从外到内的顺序构造循环和编写代码。这与平时的“自底向上”思路刚好相反，需要在编程中不断培养。",
    "4.5 循环语句 ": "在递推计算中，有两个时间点可判断循环结束，第 1 个时间点，在本次递推计算前判断递推是否结束，这就是前一节讨论的循环框架中采用的方式，第 2 个时间点，在本次递推计算后立即判断递推是否结束。从逻辑上讲，在两个时间点判断递推是否结束，其作用完全相同，但在具体实现上有一定区别，应用场景也有所不同，属于循环的两种不同形式。在本次计算前判断循环是否结束，称为当型循环。本次计算后立即判断循环是否结束，称为直到型循环。前面学习的 while 语句是当型循环，下面学习直到型循环 do…while 语句。为了方便编程，计算机语言还提供了 for 语句以及跳转语句。4.5.1 do...while 语句计算机语言提供了称为do-while的循环结构，用于描述直到型循环，以实现“先执行后判断”的逻辑。do…while语句的语法为：do{//循环体statStatement;    //语句} while (exp);  //注意，有语句结束符 “;”其中，exp 是一个表达式，规定其计算结果应为 bool 类型，称为循环条件，statStatement 是一条语句，很多时候为复合语句。do…while语句的语义为： 先执行语句 statStatement，再计算 exp 得到 bool 类型的值 v，如果 v 为 true(真),则返回执行语句 statStatement，否则 v 为 false(假)，跳出循环，执行后面的语句。do…while 语义，如图 4.10 所示。内部资料 严禁外传116statStatementexp假真图 4.10 do…while 的语义do…while 符合“先执行判断”的逻辑，因此至少执行一次循环中的语句statStatement。而 while 语句可能不会执行循环中的语句 statStatement。假真循环体循环准备下一次循环准备循环条件图 4.11 直到型循环的流程框架从原理上讲，当型循环和直到型循环是一样的，因此，构造循环的方法非常类似。使用直到型循环时，仍然通过 4 个步骤构造循环，前两步与前面学习的当型循环完全相同，但在第 3 步构造流程时，需要将循环判断调整到本次计算后进行，并在第 4 步中也对代码进行相应调整。直到型循环的流程框架，如图 4.11 所示。直到型循环适合“先做事后判断”的应景场景。 例如，从键盘读入一串数字，要做的事情是读入一个字符，再判断其是否为数字，符合“先做事再判断”的逻辑，适合使用 do…while 语句，代码如例 4.7 所示。【例 4.7】从键盘读入一串数字。#include <iostream>using namespace std;void main(){char c;  //循环准备int num = 0; //字符位置do{c = getchar();//要做的事情：读入一个字符cout << c; //处理这个字符，今后可扩展num++; //字符位置向后移动} while (c >= '0' && c <= '9');//判断是否为数字内部资料 严禁外传117num--;  //多读了一个字符，退回一个字符cout << endl << num;}程序中的 getchar()函数是 C/C++的标准函数，其功能为从标准输入流中读取一个字符，能够读入包括空格、回车、tab 等特殊字符。为了理解例 4.7 的流程，可在调试器单步执行程序，先根据执行步骤画出程序的流程图，并用代码中的表达式描述其中的步骤，然后参考代码中的注释调整流程图中的步骤及其描述，最后设计出从键盘读入一串数字的流程图，如图 4.12 所示。假真读入一个字符读入位置调整到下一个位置是不为数学处理这个字符退回一个位置假真c = getchar()int num = 0;num++c>='0' && c<='9'cout << cnum--cout << endl << numchar c;图 4.12 从键盘读入一串数字的流程例 4.7 程序的输入输出结果为：123456b78123456b6getchar()函数从标准输入流中读入字符，如果输入流没有字符，getchar()函数会处于等待状态，等待用户输入字符。用户输入“123456b78”，这些字符仍然存储在键盘缓存区，当用户输入回车之后，操作系统才将“123456b78”和回车以字符流的方式送给程序，其输入字符流，如图 4.13 所示。程序调用 getchar 函数，从输入字符流中依次读入一个字符，当读入字符 b 时，退出循环。退出循环时，字符流中的当前位置是字符 7，多读了一个字符 b，因此，需要退回一个字符，执行 num--。内部资料 严禁外传1181 2 3 4 4 5 b 7 8当前位置getchar()图 4.13 输入字符流4.5.2 for 语句for 语句是计算机语言提供的一种循环语句，其语法为：for (exp1; exp2; exp3){  //exp1,2,3为表达式//循环体statStatement;    //语句}for 语句语义，如 图 4.14 所示。计算表达式 exp1，计算表达式 exp2 并判断它的值，如果为 false，则退出循环，否则执行语句 statStatement，计算表达式 exp3，计算表达式 exp2 并判断它的值，直到表达式 exp2 的值为 false。exp3exp2真假exp1statStatement图 4.14  for 语句的语义循环变量+=步长循环变量<=结束值真假int 循环变量= 开始值循环体计算第1个s图 4.15 循环变量模式将 for 语句的语义与如图 4.15 所示的循环变量模式流程框架比较，两者非常类似，for 语句好像是专门为循环变量模式设计的(实际上就是专门为此设计的)，因此，使用 for语句描述循环变量模式的程序是一个很适合的选择。如，使用 for 语句描述计算累加和的流程，很容易就能编写出计算累加和的程序，代码如例 4.8 所示。【例 4.8】使用 for 语句计算累加和。#include <iostream>using namespace std;int main(){int s = 0, n;cin >> n;内部资料 严禁外传119for (int i = 1; i <= n; i++)s += i;cout << s << endl;}读者可使用 for 语句描述累乘积、阶乘累加和的流程图，编写出程序。 for 语句的语法较为灵活，语法中的 3 个表达式 exp1、exp2、exp3 都可以省略，也可将 statStatemen 省略为一个空语句。while、 do-whlie 和 for 语句是计算机语言中常用的循环语句，while 语句描述的逻辑是“先判断后做事”，而 do-whlie 描述的逻辑“先做事后判断”，两者的先后顺序刚好相反，可根据应用场景中存在的逻辑，选择使用 while 还是 do-whlie 语句，但先判断相对安全一些，因此，建议优先使用 while 语句。使用 for 语句编写的程序代码相对较短，受到初学者或经验较少的程序员喜爱，但因其逻辑相对复杂，逻辑不够简明，写出的程序代码可读性较差，但用于循环变量模式的场景，反而逻辑清晰，也很符合平时的思维习惯。4.5.3 转向语句为了增加编程的灵活性，计算机语言中还提供了转向语句，主要有 goto、break、continue 语句。这些语句可在比较特殊的情况下使用。1. goto 语句goto 语句，顾名思义，就是跳转，其语法为//...goto label;//...label://...其中，“label:”称为标号，表示程序代码的一个位置，goto 语句的语义为，跳转到label 这个位置继续执行。goto 语句的语法简单，语义明确，也好理解，但这条语句被认为是违反结构化程序设计思想的罪魁祸首，在编程中一般不会使用，但可以帮助我们理解后面两条跳转语句的语义。2. break 语句break语句只能用在while，do..while，for等循环语句和switch(3.4节介绍)语句中，其语法为break;其语义是，中断循环语句或switch语句的执行。在嵌套循环时中断直接包含它的循环语句。下面以while语句为例，说明break的语义。while (exp1){// ...while (exp2){//...内部资料 严禁外传120break; //goto  breakLabel//...}breakLabel: //break中断后跳到这里//...}break 语句等价于 goto breakLabel，即，跳转到 breakLabel 这个位置，继续执行breakLabel 后面的语句。3. continue 语句continue 语句只能用在循环语句中，作用为结束本次循环，即跳过循环体中尚未执行的语句，接着进入下一次循环。例如，下面的代码输出100~200中不能被3整除的数：for (int n = 100; n <= 200; n++){if (n % 3 == 0)continue;cout << n << endl;//..…continueLabel:}continue语句等价于goto continueLabel，即，跳转到continueLabel的位置，继续执行continueLabel后面的语句。continue 语句和 break 语句的区别是，continue 语句只结束本次循环，而不是终止整个循环的执行。而 break 语句则是终止整个循环，跳转到下一条语句。continue 与 break 语句在 for 和 while 语句中跳转流程，如图 4.16 所示。内部资料 严禁外传121循环体循环体while语句for语句exp真假breakcontinueexp3exp2真假exp1breakcontinue图 4.16 continue 与 break 语句在 for 和 while 语句中跳转流程从图 4.16 中，也会发现 for 语句语义比较复杂，容易出现逻辑不清晰的情况。 例如：下面程序会跳过 n++，出现死循环。int n = 100;while (n <= 200){if (n % 3 == 0)continue;//goto continueLabelcout << n << endl;//..…n++;continueLabel:}goto 语句，实际上是计算机的一条机器指令，主要由编译器使用，因它不符合结构化程序设计思想，程序员在实际应用中一般不要使用它。使用 continue 和 break 语句编程，会导致程序的语义变得更加复杂，影响程序的可读性，如果没有理由，就不要使用。",
    "4.6 应用举例 ": "开发软件的一般步骤为：先对复杂问题进行分解，找出其中的关键问题，并建立相应的数学模型，然后根据数学模型设计相应的软件模型，最后编程实现设计的软件模型。内部资料 严禁外传122下面，就从经典的数学问题开始学习编写解决实际问题的程序。4.6.1 计算阶乘的累加和4.4 节使用了嵌套的方式计算阶乘的累加和，下面使用另一种方式实现。阶乘的累加和涉及累加和累乘，有较强的代表性。应用循环变量模式编程的主要工作是针对具体的问题构造数列，并设计数列的递推公式，然后，套用循环变量模式的流程，并写出相应代码。一般步骤为：第 1 步、构造数列 第 2 步、设计递推公式 第 3 步、套用循环变量模式流程 第 4 步、套用循环变量模式的代码 阶乘的累加和可表示为1! + 2! +  + (k  1)! + k! +  + n!第 1 步、构造数列。 按照 n 的取值来构造数列 {s}1, 2, … 1, , … , 1, 其通项公式为s = ∑ !=1第 2 步、设计递推公式。 通项公式比较复杂，为了设计出递推公式，做如下变换s = ∑ !=1= (  1)! ×  + ∑ !1=1= s1 + (  1)! × 令1 = (  1)!，得到数列{sk}的递推公式s = s1 + 1 × 当 k 从 1 递增到 n 时, 1 = (  1)!作为通项公式定义了一个数列{tk}，其递推公式为tk = tk1 × k将数列{tk}的递推公式再代入数列{Sk}的递推公式，得s = s1 + 在上面的推导过程中，总共构造了两个数列{sk}和{tk}，它们的递推公式分别为tk = tk1 × k，s = s1 + 内部资料 严禁外传123将数列{tk}的递推公式再代入数列{Sk}的递推公式，决定了两递推公式计算的先后顺序，数列{tk}的递推公式在前，数列{sk}的递推公式在后，不能交换。在解决复杂问题时，常常需要构建多个数列，并经过多次数学推导才能找到其递推公式。递推公式往往不是一个简单的数学公式，而是由多个公式组成的一个计算序列。第 3 步、套用循环变量模式的流程。 数列{sk}中第 1 个数的下标作为循环变量的初始值，最后 1 个数的下标作为结束值，并套用数学归纳法的递推计算流程，设计出计算阶乘累加和的算法流程，如图 4.17A 所示。在用流程图表示出算法后，用 s 和 t 两个变量分别存储{sk}和{tk}数列中的数，增加定义变量的语句，用加法的元数 0 初始化变量 s，用乘法的元数 1 初始化变量 t，增加相应的输入和输出，最后将所有数学公式改写为表达式，设计出计算阶乘累加和的程序流程，如图 4.17B 所示的。k=k+1k≤n真假k= 1tk=tk-1×ksk=sk-1+tkk+=1k<=n真假int k= 1,s=0,t=1,nt*=k,s+=tcin>>nA.算法流程                                 B.程序流程图 4.17 计算阶乘累加和的程序流程如果不能把所有的数学公式改写为表达式，说明前面推导的递推公式不正确，需要重新推导。另外，将数学公式改写为表达式，是合格程序员必须具备的技能，这个技能包括两点：第 1、判断一个数学公式能否改写为表达式的能力，第 2、将一个数学公式改写为表达式的能力。培养这个技能是第 2 章的主要任务之一，如果读者在这方面还没有信心，请再学习第 2 章的内容，并按照要求进行训练。第 4 步、套用循环变量模式的代码。 按照如图 4.17B 所示的程序流程图，可使用 while 语句写出计算阶乘累加和的程序，代码如例 4.9 所示。【例 4.9】使用 while 语句计算阶乘累加和。#include <iostream>内部资料 严禁外传124using namespace std;void main(){int k = 1, s = 0, t = 1, n;cin >> n;cout << \"k\" << \"\\t\" << \"t\" << \"\\t\" << \"s\" << endl;while (k <= n){t *= k;//阶乘s += t;//累加cout << k << \"\\t\" << t << \"\\t\" << s << endl;k++;}cout << s;}上面的代码没有多少行，结构也非常简洁，但用到了比较复杂的数学推导，编程难度不小，如果不熟悉累加和与累乘积的编写方法，很难理解这个程序的编程思路，更不要说自己编写了。运行程序，输入输出结果：5k       t       s1       1       12       2       33       6       94       24      335       120     153153采用循环变量模式编程，总共四个步骤。后面两个步骤为套用流程和代码，比较简单，只需多加练习就能掌握，但前两个步骤，需要针对具体问题抽象出数列，并推导出递推公式，涉及抽象和推理，相对比较困难，因此，建议读者复习相关的数学知识，并对照数学公式理解程序运行过程，理解递推公式在递推计算中的作用和功能。4.6.2 程序的运行效率4.4 节和 4.6.1 节分别使用了嵌套和非嵌套两种方式计算阶乘的累加和，两个程序的运行时间差别很大。读者可以参照教材中的程序，分别输出这两种方法的运行时间。运行时会发现，随着 n 的增加，它们相差的时间会越来越。程序运行时间与循环次数紧密相关，可以说，循环次数决定了程序的运行时间。随着n 的增加，非嵌套方式的循环次数为 n，嵌套方式的循环次数为 n×(n+1)/2。阶乘累加和的循环次数，如表 4.2 所示。内部资料 严禁外传125表 4.3 阶乘累加和的循环次数循环次数 n=10时 n=100时  n=500时  n=1000时非嵌套 10 100 500 1000嵌套 55 5050 125250 500500当 n 为 100 万时，两者的运行时间相差近 100/2 万倍，当 n 为 10 亿时，两者的运行时间相差近 10/2 亿倍，从中可以分析出影响运行时间的最主要因素(没有之一)就是循环次数，因此，在计算机中一般用 n 的多少次方来估计程序的运行时间，并用下面的形式表示O(na)其中，n 表示循环次数，a 表示 n 的次方，O(na)表示约等于，这个表示方法的含义是，运行时间约等于 n 的 a 次方。在 O(na)中的 n 和 a 往往与程序的复杂性相关，因此，将 O(na)称为时间复杂度。 上面的几个示例中，累加和、累乘积的时间复杂度为 O(n)，程序的时间复杂度低。采用嵌套方式的阶乘累加和程序，它的时间复杂度为 O(n2)，而非嵌套方式程序的时间复杂度为 O(n)，采用嵌套方式比采用非嵌套方式慢很多，可以说，采用嵌套方式的程序，是一个非常差的程序，而采用非嵌套方式的程序是一个非常好的程序。在满足功能的前提下，可选择效率比较高的算法。4.6.3 计算 ln2前面以累乘积、累加和为例，详细讨论了在数列上使用递推构造循环的方法，这个方法是编程实现数学中很多复杂运算的基础，如求和、求极限等。在初等数学中，有一个等于ln 2的级数1  12+ 13 14+  = ln 2用这个级数求ln 2近似值。读者可思考，为什么求的是近似值，而不求精确值， 精确值不是更好吗？第 1 步 分解出数列 可将这个级数视为一个数列{}的和，从中寻找规律，找到数列{}的通项公式为 = (1)+1 1发现规律，找到数列{}的通项公式，这点很重要，通项公式是后面计算的基础，如果找不到通项公式，就表示不出数列{}中前 k 个数的和。用数列{}的通项公式表示数列{}中前 k 个数的和： = ∑(1)+1 1=1当 k 从 1 到∞时，构成以上述公式为通项公式的数列 s，当 k→∞时，sk→ln2，即内部资料 严禁外传126ln 2 = lim→∞∑(1)+1 1=1现在已构造出一个数列{}，计算机可从1开始计算，但不能计算无穷次，需要一个结束条件。显然，数列{}中的数是实数，实数就有精度的问题，在计算时需要满足一定的精度。在数学中，提供了估算精度的方法，其基本思路是用一个无穷小量来估算。ln 2 = ∑(1)+1 1=1+ lim→∞∑ (1)+1 1=+1= ∑(1)+1 1=1+ ()其中, o(n)为一个无穷小量，当 n 足够大时，ln 2 ≈ ∑(1)+1 1=1这时的计算误差为 o(n)。可通过估计 o(n)的大小来估计计算的精度，估计 o(n)的方法有很多种，其中最简单的方法是使用第 n 项的绝对值来估计。如选择数列{}的第 n 项的绝对值来估计计算精度，即|| = |(1)+1 1| = 1当||小于一个很小的数时，就结束循环。如果计算精度想达到小数点后 5 位，可将循环的结束条件设置为|| = 1 ≤ 105使用上面的公式作循环结束的条件，我们只知道循环次数越多精度越高，但并不知道会循环多少次，甚至不知道计算结果的精度达到多少位，能否达到精确到小数点后 5 位的要求。这些问题需要通过严格的数学推导来回答，通过工程实践来验证。第 2 步 设计递推公式 将 k+1 代入数列 S 的通项公式，并进行变换，推导出数列 s 的递推公式。+1 = ∑(1)+1 1+1=1= (1)+21 + 1+ ∑(1)+1 1=1= (1)+21 + 1+ 但其中有一个幂运算(1)+2，需要将它化简为四则运算。令 = (1)+1， 构造数列{}，其递推公式为+1 = (1) × (1)+1 = (1) × 内部资料 严禁外传127代入数列{}的递推公式，得到+1 = (1) × 1 + 1+ 最终推导出如下两个递推公式+1 = (1) × +1 = +11 + 1+ 在上面的递推公式中，仅包含四则运算，实际上就是数列上的求和与求积，也就是前面花很大篇幅讨论的累乘积与累加和。第 3 步 设计算法流程 按照递推计算的思想，设计出计算 ln2 的算法流程，如图 4.18 所示。在图 4.18 中，先计算当 k=1 时的阶乘1，即1 =1；再假设已计算出 sk，使用其两个递推公式计算 sk+1，经过不断递推(循环)，直到不满足循环条件 1/(k+1)<10-5 为止，并将最终计算出的 sk 作为 ln2 的近似值。循环条件没有直接判断循环变量 k 的次数，而是使用了一个包含循环变量 k 的条件表达式来控制循环。与循环变量模式不同，使用一个条件表达式来判断是否结束循环时，常常没有办法预测出具体循环次数。本示例中，多循环几次或少循环几次，对计算结果没有多少影响，而循环变量模式中，对循环次数的要求非常高，不能多一次，也不能少一次。k=k+11/(k+1)>10-5真假计算s1计算tk+1 计算sk+1图 4.18 计算 ln2 的算法流程k=k+11/(k+1)>10-5真假double s = 1s+=t/(k+1)t*= -1int t=1,k=1图 4.19 计算 ln2 的程序流程第 4 步 编写程序 图 4.18 所示的计算 ln2 的算法流程，将其中的 3 个数学变量改为 3 个计算机中的变内部资料 严禁外传128量，并为这 3 个计算机变量选择适当的数据类型，然后将递推公式改写为表达式，最终设计出计算 ln2 的程序流程图，如图 4.19 所示。图 4.19 中，变量 s 表示数列{}中的元素，存储 ln2 的一个近似值，考虑到精度问题，选用了 double 类型。k 表示数列的一个下标，t 表示 ai 的符号，因此，这个变量都设置为 int 类型。按照图 4.19 中的流程，使用 while 语句写出计算 ln2 程序，代码如例 4.10 所示。 【例 4.10】计算 ln2。#include <iostream>using namespace std;void main(){double s = 1;int k = 1, t = 1;while (1.0 / (k + 1) > 1e-5){t *= -1;s += t / (double)(k + 1);k++;}cout << s << endl;system(\"pause\");}需要注意的是，在计算 1/(k+1)时，必须使用数据类型转换运算将 int 转换为 double 类型，否则，计算出的结果会是一个整数，无论循环多少次都不能达到精度要求。使用级数进行科学计算和工程计算，是一种常用的方法。前面学习了使用级数计算 ln2的一种方法，但计算一个级数的方法可能有多种方法。如，对计算 ln2 的级数进行不同的分解，就会有不同的计算思路，有不同的程序代码。ln 2 = 1  12+ 13 14+  = (1 + 13+ 15+  )  (12+ 14+ 16+  )分解为两个级数之差，先分别计算这两个级数的值，再相减。ln 2 = 1  12+ 13 14+  = (1  12) + (13 14) + 从级数中分解数列，其通项公式为(1i1i + 1)其中，i=1,3,5, … 读者可按照上述不同的分解思路进行编程练习，此处不再详细讨论。 再进一步深入思考，在高等数学中，使用极限的思想定义积分、微分、导数，因此，用求极限的方法能够计算积分、微分和导数，但构造出的数列必须收敛，并且数列的收敛速度越快，循环次数越少，计算效率越高。内部资料 严禁外传1294.6.4 判断素数前面主要讨论使用递推计算构造循环、编写程序的方法，但实际应用中的很多计算问题，只需要循环，但设计不出递推公式，也没有明显的递推过程。在编程实践中，针对上述的情况产生了一个更通用的循环模式，提出了通用循环模式的流程框架，如图 4.20 所示。为下次计算做准备计算未结束真假为计算做准备做一次计算下一次循环准备循环条件真假循环准备循环体A 算法流程框架B 程序流程框架图 4.20 通用循环模式的流程框架通用循环模式是对循环变量模式的一般化，应用范围更广泛。 下面以判断素数和图形输出为例，讨论通用循环流程框架的使用方法。 一个正整数，如果只有 1 和它本身两个因数，则称为素数或质数。有 “几何之父”(father of geometry) 美誉的古希腊数学家欧几里得 (Euclid) 在《几何原本》 (Elements) 中陈述并证明了素数有无穷多个。密码是计算机安全的基石，而找到一个足够大的素数对提高密码的安全性有至关重要的作用。前面给出的素数定义比较抽象，人能够理解，但计算机不能理解，需要换成计算机能理解的语言。可用数学的方法描述为，给定一个正整数 n，用[2,n-1]中的整数依次去除整数 n，如果有一个余数为 0，则整数 n 不是素数，如果都不能整除，则是素数。2nxi0123456789 1011121314图 4.21 [2,n-1]中的整数构成一个数列按照数学的描述，可将[2,n-1]中的整数视为一个数列，如图 4.21 所示，很容易在这个内部资料 严禁外传130数列上构造一个循环，设计出判断素数的流程，如图 4.22 所示。i++i<n真假int i= 2,flag=1cin>>n;n%i !=0真假Flag=0图 4.22 判断素数的流程其中，用一个变量 flag 表示是否为素数。使用 for 语句描述如图 4.22 流程，并增加输出等语句，编写出判断一个正整数是否为素数的程序，代码如例 4.11 所示。【例 4.11】判断一个正整数是否为素数。#include <iostream>using namespace std;void main(){//输入int n;cout << \"please input a number:\\n\";cin >> n;//处理bool flag = true;for (int i = 2; i < n; i++){ //找 n 的因数if (n%i == 0){flag = false;break;}}//输出cout << n << (flag ? \"是素数\" : \"不是素数\");}内部资料 严禁外传131程序分为输入、处理和输出，结构清晰，逻辑简洁，变量 flag 在其中起了很大作用。 上面的程序循环次数约为 n，时间复杂度为 O(n)，当给定的 n 很大时，运算量也很大，能否改进一下算法，使计算量明显减少？该程序最直接按照其数学定义编写的。只要稍微思考一下，就会排除两种情况，第1、偶数肯定不是素数，第 2、[√, n-1]中不可能有 n 的因素，范围可缩小到[2, √]。按照上面的思路，可优化判断素数的程序，代码如例 4.12 所示。【例 4.12】判断素数的优化程序。#include <iostream>#include <math.h>using namespace std;void main() {//输入int n;cout << \"please input a number:\\n\";cin >> n;//处理bool flag = true;if (n % 2 == 0)flag = false;else{for (int i = 2; i < sqrt(n); i++){ //找 n 的因数if (n%i == 0){flag = false;break;}}} //输出cout << n << (flag ? \"是素数\" : \"不是素数\");}在 for 语句的循环条件 i < sqrt(n)中，sqrt()是标准函数，它的功能是求平方根。优化后的程序的时间复杂度为O(√2)，有明显提高，这是因为优化后的程序明显缩小了判断素数的范围。优化前后的判断范围比较，如图 4.23 所示。i=2x0123456789 1011121314i+=1ni+=1图 4.23 优化前后的判断范围比较按照 for 语句的语义，每次循环都要调用 sqrt()函数求 n 的平方根，sqrt()的时间复杂度比较高，很多编译器会优化，将它移到循环之前，先调用一次 sqrt()函数求出 n 的平方根，内部资料 严禁外传132并存储到一个临时变量，循环中直接使用这个变量而不再重新计算。使用嵌套循环编程模式，可编写在一个范围内查找素数的程序，代码如例 4.13 所示。 【例 4.13】在一个范围内查找素数。#include <iostream>#include <math.h>using namespace std;void main(){//输入long a, b;cout << \"请输入范围:\\n\";cin >> a >> b;cout << \"从 \" << a << \" 到 \" << b << \" 范围内的素数有:\\n\";//处理int sqrtm;bool flag;if (a % 2 == 0)    //若为偶数，则增 1a++;for (int n = a; n <= b; n += 2){   //步长为 2sqrtm = sqrt(n);//处理flag = true;for (int i = 2; i < sqrtm; i++){ //找 n 的因数if (n%i == 0){flag = false;break;}}//输出if (flag)cout << \",\" << n;}}例 4.13 中，在 a 到 b 范围内逐个判断其中的奇数是否为素数，判断过程如图 4.24 所示。因为偶数不是素数，循环步长为 2，但循环前要先判明第一个数是否为偶数。n=abx0123456789 1011121314n+=2图 4.24 从 a 到 b 逐个判断是否为素数程序员也可采用上面介绍的方法优化程序，但通过编程技巧来优化程序效果比较有限，更重要的是从方法上优化，效果才更加明显。例 4.13 程序，查找一个范围内素数，做了很多重复的判断，效率不高，读者可查阅资料，找到效率更高的算法。内部资料 严禁外传1334.6.5 输出图形图形由点、线、面构成，在输出图形时，一般要使用到几何代数中的基本知识。如，输出如图 4.25 所示的等腰三角形。1 2 3 4 5 6 7 8 91*2**3**4**8765 * * * * * * * * *图 4.25 输出等腰三角形如图 4.25 所示，屏幕上的图形是由平面中的点构成，可将屏幕视为一个平面，并使用直角坐标系表示其中每个点的位置。为了方便，将屏幕的左上角作为直角坐标系的圆点，x轴方向仍然从左到右，但 y 轴方向与数学中常见的方向相反，设置为从上到下。这样，可用坐标(x,y)标识屏幕上的每点，其中，坐标(x,y)中的 x 和 y 是自然数，通常将 x 称为屏幕上的列，将 y 称为屏幕上的行。等腰三角形由三条直线围成，可通过直线方程判断每点是否在直线上。直线方程的一般形式为y=kx+b如果等腰三角形的高为 n 行数，可将等腰三角形的顶点(n,1)、(1,n) 、(2n-1, n)代入直线方程的一般形式，分别求出三条直线的方程y=ny=x-n+1 y=-x+n+1在方程中，等号=表示相等，因此，将这三条直线的方程作为判断一个点是否在等腰三角形上的条件，其表达式为y == n || y == x - (n-1) || y == -x + n+1在显示一个图形时，可构造一个双重循环逐个输出屏幕上每个点(x,y)的符号。按照“自顶向下，逐步求精”的方法，先在行(y)上从 1 到 n 构造外循环，然后在列(x)上从 1 到2 * n - 1 构造内循环，遍历屏幕上的点。在屏幕上遍历点的思路，如图 4.26 所示。内部资料 严禁外传134yx1 2 3 4 5 6 7 8 91*2**3**4**8765 * * * * * * * * *图 4.26 在屏幕上遍历点的思路x++x <= 2 * n - 1真假x= 1输出y行x列的一字符y++y≤n真假y= 1图 4.27 屏幕上输出点的流程按照在屏幕上遍历点的思路，并将是否等腰三角形上作为控制每个点上输出符号的条件，设计出输出等腰三角形的流程，如图 4.27 所示。按照如图 4.27 所示的流程，将是否在等腰三角形上作为条件，控制每个点上的输出符号，编写出输出等腰三角形的程序，代码如例 4.14 所示。【例 4.14】 输出等腰三角形。#include <iostream>using namespace std;void main(){int n;char ch;cin >> n >> ch;//输出所有行for (int y = 1; y <= n; y++){//输出一行中的所有列for (int x = 1; x <= 2 * n - 1; x++){//输出每列中的一字符if (y == n || y == x - (n - 1) || y == -x + n + 1)cout << ch;elsecout << ' ';}cout << endl;内部资料 严禁外传135}}如果要填充三角形，可将三条直线的方程改为不等式方程组，y≤ny≥x-n+1y≥-x+n+1其中，y≤n 表示三角形在直线 y=n 的上方，y≥x-n+1 表示三角形在直线 y=x-n+1 的下方，y≥-x+n+1 表示三角形在直线 y=-x+n+1 的下方。三条张围成的范围可用如下表达式判断(y <= n) && (y >= x - (n - 1)) && (y >= -x + n + 1)参照如图 4.27 所示的流程，使用上述条件控制每个点上的输出符号，编写出输出填充等腰三角形的程序，代码如例 4.15 所示。【例 4.15】 输出填充等腰三角形。#include <iostream>using namespace std;void main(){int n = 6;char ch = '*';cin >> n >> ch;//输出所有行for (int y = 1; y <= n; y++){//输出一行中的所有列for (int x = 1; x <= 2 * n - 1; x++){//输出每列中的一字符if ((y <= n) && (y >= x - (n - 1)) && (y >= -x + n + 1))cout << ch;elsecout << ' ';}cout << endl;}}例 4.15 程序输出实心等腰三角形，如图 4.28 所示内部资料 严禁外传1361 2 3 4 5 6 7 8 91*2* * *3* * * * *4* * * * * * *8765 * * * * * * * * *9图 4.28 实心等腰三角形",
    "4.7 循环的调试与维护 ": "按照一般人想法，调试循环好像很简单，编写好程序后直接运行程序，如果能得到正确的计算结果，就可认为程序没有问题。但实际上，很多时候不能事先知道所谓的正确结果，即使知道了正确结果，如果与程序的运行结果不同，也要去查找出错的原因。因此，调试循环的目标是保证程序的循环流程与设计时完全相同，基本方法是比较两者的流程及每次循环的计算结果，调试循环的要点有三点，第一、进入循环是否正确，是否为第一次循环做好了准备，第二，每次循环的递推过程是否正确，是否能为下次循环做好准备，第三、退出循环是否正确，是否循环了预期次数，并能得到所期望的结果。4.7.1 调试循环的基本方法以累乘积为例讨论调试循环代码的基本方法。int n=100;int s =1, k = 1;while (k <=n){s *= k ;k++;}cout << s;调试程序的基本方法是人工运行程序，比较算法和计算机的运行过程，判断两者是否一致。实际应用中，循环次数往往很大，人工难以完成所有的循环，因此，将调试的重点集中在进入循环、递推计算和退出循环三个环节。调试循环的三个关键环节，如图 4.29 所示。x01234100k=1k++进入循环递推计算退出循环99101图 4.29 调试循环的三个关键环节内部资料 严禁外传1371. 检查进入循环和递推计算首先，检查循环准备。应检查进入循环前相关变量的值，以判断是否为循环做好准备。如调试累乘积代码时，进入循环和递推计算前的变量状态，如图 4.30 所示。其次，人工执行前三次循环。在前三次循环人工执行时，关注两点，第 1、第 1 次循环时，循环变量 k 的初始值及其增加值是否正确，累乘变量 s 的初始值和计算结果是否正确，第 2、第 2 次、第 3 次循环是否符合递推计算预期。第三，推测递推计算是否正确。重点检查 s *= k 和 k++构成的计算序列与递推公式的计算过程是否相同。如果执行了前三次循环后，仍然不能推断递推计算的正确性，就多执行几次循环，直到能推断为止。在调试器中调试程序时，要不断与算法比较，也要与计算机的运行结果比较，以判断算法的正确性和代码的正确性。10int n1int s1int k1,  2,  3,    4,      5,       61,  2,  6,  24,  120,  720图 4.30 进入循环和递推计算10int n1int s1int k1,2,3,…,99,100,1011,2,6,…,xx,xxx图 4.31 最后 3 次循环及退时的内存出状态有经验的程序员，一般经过 3 次循环就能发现递推或退出循环时的错误，因此，建议进入循环时至少人工运行 3 次，退出循环时也人工运行至少 3 次。2. 检查最后三次循环通过观察最后三次循环的情况，判断退出循环是否正确。主要思路是，观察最后三次循环的执行流程及内存状态，判断循环次数是否符合预期，退出后变量状态是否符合预期。如调试累乘积代码中，最后 3 次循环及退出时的变量值，如图 4.31 所示。需要重点检查循环条件 k <=n，观察循环变量 k 为 99、100、101 时的运行情况，判断 100 是否累乘到变量 s，累加是否正确，当 k=101 时，能否退出循环，是否累乘到变量 s。读者可以思考，如果 n 的值为 1000 时，需不需要人工计算 100 次？会来会发生溢出？如果循环次数不可预知，如 4.6.3 中计算 ln2 的程序，怎样判断循环正确？在实际应用中，调试所有循环，工作量巨大，也没有必要，甚至不可能完成，这时就只能依靠程序员逻辑思维能和编程经验来推断递推计算的正确性。4.7.2 维护循环代码程序是按照代码的语义运行的，代码的结构是否简洁，语句的语义是否清晰，对调试程序的工作量和难度都有很大影响，因此，编写循环代码时需要选择适合的循环语句，以提高代码质量。内部资料 严禁外传138while、do ... while 和 for 三种循环语句都有自己适合的应用场景。如 for 语句，代码简洁但语义不够清晰，适合用于描述循环变量模式，一般不用于非循环变量模式；do ... while 语句先执行循环体再进行条件判断，使用时要特别当心；While 语句语义清晰、明确，使用场景广泛，但代码不够简洁，循环变量模式中就尽量使用 for 语句。循环条件的作用是控制循环，循环语句中的条件表达应专注于控制循环，应尽量简单，一般不要承担循环体中的功能。在循环中使用了 break 或 continue 语句时，退出情况就会变得复杂，明显增加调试的难度和工作量，尽量不要使用。代码简洁是评价程序代码质量的重要指标。 在设计程序时，主要采用“自顶向下，逐步求精”的思想，而调试程序时，更多用到“自底向上”的思维模式，以验证设计的程序是否正确。前面分表达式、分支和循环三种情况讨论了调试程序的基本方法，但在实际编程过程中，这三种情况总是交织在一起的，特别是分支和循环混合后，会导致调试程序的工作量成级数增长，因此，高效地调试程序是对合格程序员最基本的要求，调试程序也是一个程序员的基本能力。按照分而治之的思想，综合运用各种调试程序的基本方法，经过长期艰苦的训练，才能不断培养调试程序的能力。不断重复是人生的常态，但正因为常见，反而使我们没有意识到人生中的“重复”，没有意识到重复总有结束的时候，就像学生需要不断听课，不断读书，不断做练习，周而复始，这使得许多同学感觉生活太过平淡，反而没有意识到不断学习的重要性，到毕业时后悔莫及。",
    "4.8 本章小结 ": "本章主要学习了构造循环的基本知识和基本原理，学习了按照递推思想构造循环的步骤和方法，深入学习了循环的两种基本模式，最后学习了调试和维护循环程序的步骤和方法。从数学归纳法中引入了递推的概念，学习了构造循环的基本知识和基本原理，深入学习使用递推构造循环的方法，举例说明了构造数列和设计递推公式的思路，需要掌握使用递推公式构造循环的步骤和方法。学习了 while 语句、for 语句和 do while 等循环语句语法与语义，以及相关的计算机语言知识，需要掌握使用循环语句描述循环结构的方法。学习了循环变量模式和嵌套循环模式，深入学习了循环变量模式的流程框架和代码框架，举例说明了使用循环变量模式描述循环的方法，举例说明了嵌套循环模式，需要掌握使用这两种编程模式编写循环结构程序的步骤和方法。学习了循环结构的通用流程框架，举例说明直接通过计算构造循环的编程步骤和方法。学习了调试循环的基本方法，介绍了维护循环代码的基本知识。内部资料 严禁外传139",
    "4.9 习  题 ": "1. 使用 for 语句改写 4.3.1 和 4.3.3 节中的程序，并上机调试通过。2. 请编程打印下面 3 个图案中的一个。** ** * ** * * ** * * * * * *** * ** * * * **** ** * *******要求用户输入一个符号和行数(1~20 之间)。如果用户输入无效行数，则发出信息并询问用户是否想重新输入。如果获得肯定回答，则让用户重新输入符号和行数，否则，退出程序。 3. 编写一个程序，依次输入一系列正整数，如果遇到的整数为 0，则不再输入整数，然后输出已输入数中的最大整数，再输出其余整数中的最大整数。4. 输入一个不超过 109 的正整数，从低位到高位输出各个位上的数，最后输出它的位数。例如输入 12735，输出 53721 和位数是 5。5. 如果一个正整数 a 是某一个整数 b 的平方，那么这个正整数 a 叫作完全平方数。零也可称为完全平方数。 (1)写出通过递推方式求 200 以内的完全平方数的程序。 (2)写出只使用加法求完全平方数的程序。6. 水仙花数(daffodil) 若 3 位数 ABC 满足 ABC=AC+BC+CC，则称其为水仙花数(daffodil)。例如153=13+53+33，所以 153 是水仙花数。编写程序，输出 100~999 中的所有水仙花数。7. 子序列的和(subsequence)输入两个正整数n<m<106，输出12 +1(+1)2 +  +12，保留5位小数。8. 排序组合是概率的基础，请编程实现下面的排列组合公式。 =!(  )!  =!(  )! × !9. 级数在工程实践中有很重要的作用，请编程计算下面的级数。11 × 2 +12 × 3 +  +1(  1) × 11 + 17 + 149 … + (17)1 + 13 + 15 + 17 + 12  11  14 + 17  110 +  + (1)13  210. 使用下面的级数编写程序求π的近似值，有效位保留后小数点后 7 位。1  13+ 15 17+  = 4内部资料 严禁外传140内部资料 严禁外传141"
  },
  "函数": {
    "函数": "随着计算机应用的深入，计算机能够解决的实际问题越来越复杂，程序也越来越长，常见的程序一般都有成千上万行代码，如操作系统这类程序，会达到几百万行甚至上千万行的代码，怎样组织和管理程序就成为非常重要的问题。数学中的函数提供了解决这个问题的基本思路和方法，可按照函数的思想组织和管理程序，编写更大的程序。",
    "5.1 数学函数与黑盒思维 ": "函数在数学中是一种对应关系，是从非空数集 A 到非空数集 B 的对应，其定义为： 设 A 是一个非空集合，B 是非空数集，若对 A 中的每个 x，B 中存在唯一的一个元素 y与之对应，则称对应关系是 A 上的一个函数，记作y=f(x)其中 x 称为自变量，y 称为因变量，习惯上也说 y 是 x 的函数。 实际上，函数 f 定义了从非空数集 A 到非空数集 B 的一种函数映射关系，如图 5.1 所示。x1x2x4x3x5x6y1y2y3y4y5…………集合A:定义域fy6y7集合B图 5.1 函数映射关系除了 y=f (x)的形式外，还可以用图形方式表示函数，函数的图形表示，如图 5.2 所示。fxy图 5.2 函数的图形表示如图 5.2 所示，函数 f 将 x 的值映射 y 的值。箭头方向表示映射方向，这与平时从左到右的生活习惯非常符合，非常直观，很容易理解。函数的更一般的形式为内部资料 严禁外传142 = (1, 2, … , )函数 f 将多个数映射到一个数，有多个自变量，其图形表示，如图 5.3 所示。fx1,x2,…,xny图 5.3 多自变量的函数多对多这种对应关系在计算机中很重要，但为什么要把它排除在函数以外呢？为了搞清楚这个问题，需讨论函数的计算。求梯形面积的公式 =  + 2如果一个梯形上底为 2，下底为 4，高为 5，先按照表达式中讨论的方法，将它们分别代入公式，再进行四则运算，得到梯形的面积 15。 =  + 2 = 2 + 42× 5 = 15可将梯形面积的公式理解为一个函数 f，函数 f 是从向量(a,b,h)构成的集合到实数集的映射，是多对一映射，即：(, , ) =  + 2在计算梯形面积过程中，先将上底 2、下底 4、高 5 分别代入函数，即: = (2,4,5)然后再根据梯形面积公式计算函数 f 的值，即(2,4,5) =  + 2 = 2 + 42× 5 = 15最后得到梯形的面积 15。f (2,4,5)=15使用梯形面积的公式会不会计算出多个值呢？从来没有过，这是常识。所以，将多对一或一对一类型的映射定义为函数，是为了保证计算的唯一性。如果将函数视为“处理”，那么，代入函数自变量的值就是处理的“输入”，函数值就是处理的“输出”，这就是计算机中最基础的“输入——处理——输出”模型。“输入处理输出”模型，如图 5.4 所示。处理输入输出图 5.4“输入处理输出”模型f2,4,515图 5.5  函数 f 的一次计算按照“输入——处理——输出”模型，有助于从计算的角度重新理解函数的作用。如，可将 f (2,4,5)=15 理解为函数 f 的一次计算，这次计算的输入为 2、4、5 三个数，输出为 15，如图 5.5 所示。内部资料 严禁外传143计算机中“输入——处理——输出”模型，非常简单但很重要，是理解“计算”的基础。下面以求两个梯形的面积之和为例，讨论其在计算中的作用和意义。如果一个梯形上底为 2，下底为 4，高为 5，另一个梯形上底为 3，下底为 7，高为 2，用函数将这两个梯形的面积之和表示为f (2,4,5)+ f (3,7,2)可用“输入——处理——输出”模型分别表示 f (2,4,5)和 f (3,7,2)，并将加法运算视为一个函数，也用“输入——处理——输出”模型表示出来，然后，按照计算的顺序将它们串在一起，构成一个描述 f (2,4,5)+ f (3,7,2)计算步骤的图形，如图 5.6 所示f2,4,515f3,7,210+25图 5.6  f (2,4,5)+ f (3,7,2)的计算步骤图 5.6 中，将梯形面积公式 f (a,b,h)视为一个整体，没有包含求 f (a,b,h)的具体计算步骤。使用梯形面积公式的运算序列图分别描述 f (2,4,5)和 f (3,7,2)的计算过程，并增加到如图 5.6 所示的计算步骤中，分两个层次描述 f (2,4,5)+ f (3,7,2)的计算步骤，如图 5.7 所示。+246/3*155+3710/5*102+2522图 5.7 分两个层次描述 f (2,4,5)+ f (3,7,2)的计算步骤图 5.6 中，将梯形面积公式 f (a,b,h)被视为一个整体，就像一个黑盒子一样，不关心梯形面积公式 f (a,b,h)的计算步骤，这种处理问题的思维方式被称为黑盒思维，并将图 5.6 中的 f (a,b,h) 称为黑盒，与黑盒相对，将图 5.7 中的 f (a,b,h) 称为白盒。为了加深对黑盒和白盒理解，将 f (a,b,h)从图中提出出来单独进行比较，如图 5.8 所示。显然，黑盒比白盒简单得多。+a:2b:46/3*s:15h:52f2,4,515黑盒白盒图 5.8 黑盒与白盒的比较内部资料 严禁外传144黑盒思维是一种重要的思维方式，能够降低了处理一件事情的复杂程度。 如，将计算两个梯形的面积视为两件事。第一件事，怎样计算两个梯形的面积，将关注重点放在“两个”上，只需考虑将两个图形面积相加，即 f (2,4,5)+ f (3,7,2)=15+10=25。第二件事，怎样计算梯形的面积，将关注重点放在“梯形”上，只需考虑使用梯形面积公式计算一个梯形的面积。做的两件事情，明显比原来的一件事情简单很多，特别是第一件事中将 f (2,4,5)和 f(3,7,2)视为黑盒，处理起来非常简单，明显降低了做事件事情的复杂程度。进一步思考会发现，不管计算什么样的图形面积之和，只要图形有求面积的公式，都可以按照黑盒思维，将它分解为两件事情来：第一件事，计算图形的面积这之和；第二件事，使用求面积的公式计算各种图形的面积。黑盒思维是一种基本的思维方式，被广泛应用于解决各种实际问题。",
    "5.2 计算机函数 ": "在实际生活中经常需要求梯形面积，因此可将梯形面积的公式定义为一个函数，并使用这个函数计算多个梯形面积之和。如使用函数计算两个梯形面积之和，代码如例 5.1 所示。【例 5.1】使用函数计算两梯形面积之和。#include <iostream>using namespace std;//将梯形面积公式定义为计算机函数double  f(double a, double b, double h) //数学函数 f(a,b,h){return (a + b) / 2 * h;// 梯形面积公式}int main(){int s;s = f(2, 4, 5) + f(3, 7, 2);//求两个梯形的面积之和cout << s;return 0;}例 5.1 中，定义了 main( )和 f( )两个计算机函数。计算机函数 f( )使用梯形面积公式计算一个梯形的面积，其代码为：double  f(double a,double b,double h) //数学函数f(a,b,h){return (a + b) / 2 * h;// 梯形面积公式}其中，double f(double a,double b,double h) 表示定义一个计算机函数，(a + b) / 2 * h 是梯形的面积公式改写的表达式，return 表示(a + b) / 2 * h 的值作为函数返回(return)。计算机从 main( )函数开始执行例 5.1 所示的程序，在 main( )函数中通过表达式 s=f (2,4, 5) + f (3, 7, 2)调用(使用)计算机函数 f( )，总共调用两次，每次调用计算一个梯形的面积。内部资料 严禁外传145在表达方面，double f(double a,double b,double h)与数学函数 f(a,b,h)非常相似，计算机函数中，只增加了变量的数据类型 double。计算机函数与数学函数在表达上的对比，如图 5.9 所示。s   =f  (           a,            b,            h)double  f  (double a,double b,double h)数学函数计算机函数图 5.9 计算机函数与数学函数在表达上的对比在数学中，用函数解决实际问题时，分为定义函数和使用函数两个步骤，同样，计算机语言中，也分为定义函数和调用函数两个步骤。5.2.1 定义函数计算机语言中，定义函数的语法如下：返回类型 函数名(数据类型 参数1，数据类型 参数2，……，数据类型 参数n) //函数头{//函数体}函数定义包括函数头和函数体两个部分。函数体包含实现函数功能的代码，在调用函数时执行这些代码。函数头的语法，除了增加数据类型的表述外，与数学函数的记法非常类似。数学函数与计算机函数的对应关系，如图 5.10 所示。y   =        f      (                  x1      ,                        x2    ,     ,                       xn   )返回类型 函数名(数据类型 参数1，数据类型 参数2， ，数据类型 参数n)图 5.10 数学函数与计算机函数的对应关系函数名是一个标识符，用于区分不同的函数。数学中的 f 、f1 这类符号，抽象程度太高，在编程中，一般不适用类似符号命名函数。函数名一定要“见名知意”，通过函数名就能知道函数的功能，如，将取两个数中最大数的函数命名为 max，将取两个数中最小数的函数命名为 min。函数参数可以有多个，用逗号分隔，形成一个参数列表。每个参数由数据类型和参数名构成，参数名用于区分函数中的参数，一般不用比较长的名称而用比较简短的名称，必须明确指定每个参数的数据类型。在定义函数和调用函数时都涉及参数，为了便于交流，一般将定义时的参数称为形参，调用时的参数值称为实参。参数这个术语源于数学中的函数，在定义函数时，参数的作用是为了表示参数的位置，即占位，与使用什么名称没有多大关系，是形式上的，因此，称为形参，在调用函数时，要将参数的实际值传递给函数，参与实际计算，因此，将它称为实参。函数的数据类型指函数值的数据类型，可以是前面学习的各种基本数据类型，如 int、float 或 double，如果不返回函数值，则用 void 表示，语义是函数值的数据类型为 void。下面以幂函数为例，更直观地讨论定义函数的方法。内部资料 严禁外传146power(x,n)=xn定义一个计算机函数实现数学中的幂函数，其代码结构如图 5.11 所示。double power(double x, int n){double result = 1;if (n >= 0){for (int i = 1; i <= n; i++)result *= x;}else if (n < 0){for (int i = 1; i <= n; i++)result /= x;}return result;}函数体函数名返回值的类型参数列表返回值图 5.11 幂函数的代码结构如图 5.11 所示，幂函数的代码包括函数头和函数体两个部分。函数头中规定，函数名为 power，函数值的数据类型为 double，有两个参数 x 和 n，其数据类型分别为 double 和int。函数体中，包含了计算 xn 的代码，以及返回计算结果的 return 语句。 计算 xn 的代码，是根据如下的分段函数编写的。power(, ) =  = { ≥ 01 < 05.2.2 函数的调用计算机语言中都提供了函数调用的功能，C/C++中，函数调用被当作一种运算。函数调用的语法语义，如表 5.1 所示。表 5.1 函数调用的语法语义运算符名称结合性语法 语义或运算序列( )函数调用Functioncall从左到右expf(exp1,exp2,…expn)调用进入：调用(略)执行函数体：从函数体中第一行语句开始执行函数体；通过retun语句将返回值赋值给临时变量R，并跳转到函数返回。退出返回：(略)内部资料 严禁外传147执行完包含函数调用的语句时，回收临时变量R。函数调用的语法为expf(exp1,exp2,…expn)其中，expf 为函数名，括号中的表达式 exp1, exp2 ,…expn 组成了实参列表。 函数调用包含进入函数调用、执行函数体和退出返回三个步骤，并规定每个步骤的语义，比较复杂，先以求两个数的最大值为例，介绍函数调用的三个步骤，如图 5.12 所示。执行程序时，不是按照源程序中定义函数的前后顺序执行的，无论函数定义的前后顺序怎样，程序总是从 main( )函数开始执行。int main(){int x, y;cout << max(x, y);}顺序执行进入函数退出返回顺序执行程序入口结束运行int max(int a, int b){int rt;if (a > b)rt = a;elsert = b;return rt;}图 5.12 函数调用中的三个步骤如图 5.12 所示，main( )函数使用 cout << max(x, y)调用 max( )函数。当执行到 cout <<max(x, y)时，先调用 max( )函数，再执行<<运算。cout << max(x, y) 的执行顺序，按照图 5.13 所示。调用 max( )函数时，先将变量 x 和 y 中的值传递给变量 a 和 b，然后执行函数体中的语句，最后执行 return 语句返回 a 和 b 中的最大值。函数调用执行结束后，继续执行 cout << max(x, y)中的<<运算，输出 max(x, y)函数返回的值。cout << max(x, y)coutR①②图 5.13 cout << max(x, y)的计算顺序执行程序时，操作系统(OS)将程序装入内存，并调用 main( )函数，执行 main( )函数中的代码；当执行到 cout << max(x, y)时，调用 max( )函数，进入函数调用并传递参数，执行max( )函数中的代码，退出 max( )并返回函数值，继续执行 cout << max(x, y)中的<<运算，输出 max(x, y)函数返回的值；退出 main( )函数，返回到操作系统。运行程序时的调用过程，如图 5.14 所示。内部资料 严禁外传148OSmainmax运行max(2,3)33cout << max(x, y)图 5.14 运行程序时的函数调用过程函数调用的过程是按照数学中的计算方法设计的，但在计算机中需要解决的主要问题，是怎样实现参数的“代入”，怎样将计算结果返回给调用语句？函数调用的三个步骤中，进入函数和退出返回是计算机自动实现的，除了在执行函数体中使用 return 退出并返回函数值外，程序员不需要做什么事情。5.2.3 函数调用的内部机制在计算机中使用一种称为“栈”的机制实现函数调用的语法和语义，“栈”的工作原理就像在子弹匣中压子弹一样，最先压入的子弹最后才飞射出去，最后压入的子弹则首先飞射出去。下面仍然以求两个数的最大值为例，讨论函数调用的内部机制，完整代码如例 5.2 所示。【例 5.2】求两个数的最大值。#include <iostream>using namespace std;int max(int a, int b){int rt;if (a > b)rt = a;elsert = b;return rt;}void main(){int x = 2, y = 3;cout << max(x, y);}内部资料 严禁外传1491. 执行 main( )函数中代码Main( )函数中只有两条语句，第 1 条语句 int x=2, y=3，在“栈”中为变量 x 和 y 分配存储空间，并进行了初始化。调用 max( )前的内存状态，如图 5.15 所示。int y23int x执行int x = 2, y = 3后进入main函数时图 5.15 调用 max 前的内存状态第 2 条语句 cout << max(x, y)是表达式语句，表达式中包含了<<和函数调用两个运算，执行顺序为先调用 max(x, y)再执行<<。2. 调用 max( )函数按照函数调用的语义，调用 max(x, y)分为进入函数、执行函数体、退出返回三个阶段。第 1 阶段，进入 max( )函数调用“{” 执行 max( )函数中的语句前，需要做一些准备工作，可理解为，执行 max( )函数的“{”。为返回分配存储空间。为 int max(int a,int b)函数的返回值预先分配 int 类型的存储空间，这个存储空间是系统自动管理的，不需要程序员来管理，但为交流方便，给它取一个名称 R，并称它为临时变量 R。如图 5.16 (a)所示。保护现场。存储一些系统数据，以便函数调用后能够返回去执行语句 cout << max(x, y)中的<<运算。在内存图中用带阴影的内存块示意，如图 5.16 (b)所示，依次传递参数。依次为 int max(int a,int b)中的形参 a 和 b 分配存储空间，并将 max(x,y)中实参 x 和 y 的值依次赋值给形参 a 和 b。传递参数过程，如图 5.16 (c)(d)所示。int y23int xint Rint y23int xint Rint y23int x2int aint Rint yint b23int x23int aint R(a)为返回值分配内存(b)保护现场(c)为形参a分配内存及传值 (d)为形参b分配内存及传值图 5.16 调用进入 max 的内存变化过程调用进入 max( )函数后的内存状态如图 5.16 (d)所示，为执行函数体做好了准备。 第 2 阶段：执行 max( )函数体 依次执行函数体中语句， 其中， return rt 是一条 return 语句。return 语句的语法为内部资料 严禁外传150return exp;其语义为，计算 exp 并将计算的值存入临时变量 R，并跳转到函数返回阶段，可理解为，跳转到函数的”}”。语句 return rt 的语义为，从变量 rt 中取出值 3，并存入临时内存空间 R，以便将函数值3 返回到函数 main( )，然后跳转到函数的”}”，进入调用返回阶段。将 max( )的函数值 3 返回到函数 main( )的过程，如图 5.17 所示。int b23323int a3int rtmainmaxint yint xint Rreturn rt图 5.17 将 max 的函数值 3 返回到函数 main 的过程在程序实际运行时，函数调用一般是先分配返回值的内存，再分配形参的内存，最后再保护现场，考虑到函数调用是自动实现的，对程序员透明，因此在图 5.17 所示的内存状态中特意交换了分配形参内存和保护现场的顺序，以便调用函数的逻辑更清晰，更容易理解。第 3 阶段：退出 max( )返回 main( )函数“}”  按照退出返回的语义，先回收 max( )中的变量 b，然后回收变量 a，最后恢复现场，退出 max( )返回到 main( )函数中的调用点，去执行 cout << max(x, y)中的<<。从 max( )返回 main( )函数的过程中的内存变化情况，如图 5.18 所示。2332233233int yint b23int x323int aint Rint yint xint Rint yint xint Rint yint xint Rint aint yint b23int x323int aint R3int rt图 5.18 从 max 返回 main 函数的过程中的内存变化情况其中，存储 max( )函数返回值的临时变量 R 没有回收，这样就能够在 main( )函数中访问临时变量 R 中的值，保证了返回值从 max( )函数返回到 main( )函数。3. 继续执行 main( )函数中的代码调用 max(x, y)结束后，继续执行 cout << max(x, y)中的<<。 继续执行 cout << max(x, y)中的插入运算<<时，max(x, y)的计算结果为临时变量 R，相当于执行 cout <<R，输出 R 中的值 3。按照 C++的规定，变量 R 是 cout << max(x, y)语句中的临时变量，只能在这条语句中使用，因此，执行 cout << max(x, y)语句后，才回收存储 max( )函数返回值的临时变量 R。回收临时变量 R 后，内存的状态应与该调用 max( )前的内存状态完全一样。内部资料 严禁外传151退出 main( )函数前，与定义变量相反的顺序回收 main( )函数的变量 y 和 x，清空“栈”中所有的变量。4. 管理变量的“栈”机制在函数调用过程中，计算机内部使用“栈”机制管理内存中的变量。按照定义变量的顺序，在“栈”中“自底向上”为变量分配内存，退出返回时，按照相反的顺序在“栈”中“自顶向下”回收变量内存，并保证了函数调用前后“栈”中的变量相同。管理变量的“栈”机制，如图 5.19 所示。int b23323int a3int rtmainmaxint yint xint R分配内存回收内存图 5.19 管理变量的“栈”机制从逻辑上讲，“栈”采用的是“先进后出”的策略。根据管理变量的“栈”机制，函数调用三个步骤的语义为：进入函数调用：为返回值创建 type 类型长度的临时存储空间 R；保护现场，将返回地址等重要参数压入栈中保存；传递参数，在栈区依次为形参(变量)s1、s2... sn 分配指定类型的存储空间，并将实参 exp1、exp2…expn 的计算结果分别传递给形参…。执行函数体： 从函数体中第一行语句开始执行函数体；通过 retun 语句将返回值赋值给临时变量 R，并跳转到退出返回。退出返回：按照分配时的相反顺序回收形参(变量)，即先回收形参 sn，最后回收形参s1；恢复现场，重新读取被保存的返回地址等参数，回收这部分内存空间，并返回到调用点继续执行。返回到调用函数后，从调用点继续执行，即从临时变量 R 中取出函数的返回值，继续执行完包含函数调用的语句，执行完这条语句后，再回收临时变量 R。5.2.4 函数的原型数学函数的表示形式 = (1, 2, … , )非常重要。如 max 函数，无论在 max 函数的定义还是在调用中，都涉及函数的表示形式，并据此写出如下的代码int max(int a,int b)；这段代码的语义说明了三件事情，第 1，函数的函数名为 max，第 2，有 a,b 两个参数，参数的数据类型都为 int，第 3，函数返回一个 int 类型的值。内部资料 严禁外传152无论在定义 max 函数时，还是在调用 max 函数时，都必须符合 int max(int a,int b)规定的语义，因此，就将 int max(int a,int b)称为 max 函数的原型，简称 max 的函数原型。在 C/C++语言中，提供了一条语句来声明函数的原型，其语法为 返回类型 函数名(参数表)； 这个语法与定义函数时函数头的语法完全相同，但可以省略形参名，如下面两条语句声明的是同一个函数的原型。int max(int a,int b)；int max(int ,int )；为什么可以省略形参名称？这是因为在函数调用时不需要形参的名称，只需知道每个参数的位置及数据类型，因此，在声明函数原型时可以省略形参名称。计算机语言具有声明函数原型的能力后，就可以将定义函数和使用函数分离，一些程序员负责定义函数，如，开发语言的专业公司负责编写 sin、cos 等计算机语言函数库中的函数，而一些程序员则负责使用这些函数解决实际问题，如应用工程师直接调用计算语言中的库函数。标准库函数的函数原型以头文件的方式提供，在程序中，用#include 命令引入头文件后就可以调用头文件中声明函数。计算机语言中的函数，对数学函数进行了扩展，不仅能表示数学中的函数，而且可以没有输入参数，也可以没有返回值。例如：没有返回值void delay(long a){for (int i = 1; i <= a; i++);//延迟一个小的时间片}其中，void 是一种数据类型，其含义是“没有”，也称为“空”,这里表示 delay 不需要用 return 语句返回任何值，如果在 delay 函数体内增加 return 语句，也只能是不返回值的“return”形式，不能是“return  exp”形式。例如：没有输入参数int geti()//从键盘上获取一个整型数{int x;cout << \"please input a integer:\\n\";cin >> x;return x;}例如：没有参数也不返回值void message()//在屏幕上显示一条消息{cout << \"This is a message.\\n\";}在 C/C++语言中，需要区分“声明”和“定义”两个术语，它们的含义不完全相同。“定义”包含了创建、分配等含义，如，定义一个变量 a，表示需要在内存中创建变量 a，要为这个变量分配内存，再如，定义一个函数 f，编译器需要为函数 f 生成目标代码，在代码段为生成的目标代码分配内存，而“声明”只表示“有”什么，如，声明函数 f，表示有这个 f 函数，可以调用它，但不会生成目标代码，也不会分配内存。“定义”的含义包含内部资料 严禁外传153了“声明”的含义，反过来就不(一定)正确。",
    "5.3 变量管理 ": "在一个程序运行时，操作系统为程序分配了代码区、全局数据区、栈区和堆区 4 个内存区域，用于存储代码、全局数据、局部数据和动态数据。程序的内存区域如图 5.20 所示。程序的 4 个内存区是分开的，并采用不同的管理方式。代码区存储程序的可执行代码，受到操作系统监控，不允许修改，以提高程序的安全性。全局数据区存储全局变量和字符串常量等全局数据。栈区存储程序的局部数据，使用栈来管理其中的数据。前面 3 个内存区都是由系统自动管理的，但堆区比较特别，它是为程序员准备的内存区域，由程序员根据需要动态管理。int main(){int x, y;cin >> x >> y;cout << max(x,y);}……代码区\"我是全局数据区\"\"静态变量\"3.1415926\"我是字符串常量\"全局数据区23int xint y323int aint bint Rmainmax栈区\"我是堆区\"23.1415926\"程序员要自己管理\"堆区图 5.20 程序的内存区域5.3.1 局部变量、全局变量在计算机言语中，主要有全局变量、局部变量，局部变量又分为动态局部变量和静态局部变量两种变量，在编程中的作用也不一样，使用场景也有所不同。全局变量指在函数外定义的变量，存在全局数据区。当一个程序运行时，系统已为这类变量分配了存储空间，理论上程序中的所有函数都能使用这些变量，当程序运行结束后，系统回收这类变量。局部变量指函数中定义的变量，其中动态局部变量存放在栈区。系统采用栈机制管理函数内定义的动态局部变量。每次调用一个函数，都要先给动态局部变量分配存储空间，然后才能使用这些变量，结束函数调用后，系统会回收这些变量的存储空间，回收后不能再使用。在局部变量前加上“static”关键字，就成了静态局部变量。静态局部变量存储在全局数内部资料 严禁外传154据区，并采用与全局变量相同的方法来管理，这与全局变量相似，但只能在定义它的函数中可以使用，这点与局部变量非常相似。静态局部变量的初始化与全局变量类似，如果没有初始化，则 C/C++语言自动为其初始化为 0。但是，以显式的方式初始化所有的变量是一个良好的编程习惯。 实际编程中，动态局部变量使用非常频繁，常常将其简称为局部变量。 下面通过示例介绍变量管理的机制，代码如例 5.3 所示。 【例 5.3】变量管理的机制#include <iostream>using namespace std;void func();int n = 1;    //全局变量void main(){static int a;    // 静态局部变量int b = -10;      // 局部变量cout << \"a:\" << a<< \"  b:\" << b<< \"  n:\" << n << endl;b += 4;func();cout << \"a:\" << a<< \"  b:\" << b<< \"  n:\" << n << endl;n += 10;func();}void func(){static int a = 2;    // 静态局部变量int b = 5;           // 局部变量a += 2;n += 12;b += 5;cout << \"a:\" << a<< \"  b:\" << b<< \"  n:\" << n << endl;}执行 main( )函数的第 1 条语句前，操作系统已经为全局变量、静态局部变量、字符串常量等全局数据区中的变量分配了存储空间，并进行了初始化。在以后程序运行过程中，不会再对这些变量分配存储空间，也不会初始化。例 5.3 中，定义了一个全局变量 n，两个名为 a 的静态局部变量，这三个变量都存储在全局数据区。换句话说，全局数据区有一个全局变量 n 和两个名为 a 的静态局部变量， main( )和 func( )两个函数中都可以访问全局变量 n，但 main( )函数中只能访问 main( )函数内定义的静态局部变量 a，func( )函数中只能访问 func( )函数内定义的静态局部变量 a，不能交叉访问。main( )函数中第 1 次输出时的内存状态和输出结果，如图 5.21 所示。内部资料 严禁外传155语句“static int a”的语义为，定义一个 int 类型的静态局部变量 a，编译器在全局数据区为它规划了存储空间，并在程序运行前，操作系统已为它分配了内存并进行了初化，因此，这条语句不再执行。语句“int b = -10”定义一个局部变量，在栈中为它分配存储空间，并初始化为-10。-10int b\"a:\"\"  b:\"\"  n:\"1int n0main:int a2func:int aa:0b:-10n:1_图 5.21 main 函数中第 1 次输出输出变量 a。在栈中没有找到变量 a，然后在 main( )函数的静态变量中找到变量 a，因此，输出静态变量 a 的值 0。输出变量 b。在栈中找到变量 b，因此，输出它的值-10。 输出变量 n。在栈中没有找到变量 n，然后在 main( )函数的静态变量中也没有找到变量 n，最后在全局变量中找到变量 n，因此，输出全局变量 n 的值 1。同样，b += 4 中的变量 b 也是栈中的变量 b，加 4 后变成-6。 func( )函数中第 1 次输出时内存状态和输出结果，如图 5.22 所示。 func( )函数体中，语句“static int a = 2”，已执行，不再重复执行。 语句 int b = 5 定义一个局部变量 b，在栈中为其分配存储空间，并初始化为 5，这个变量虽然与 main( )函数中的变量 b 同名，但它是 func( )的局部变量，不会出现二义性，因此，这样的语句符合语法。在图 5.22 中，两个变量 b 被保护现场的斜纹矩形分开，斜纹矩形下面的是 main( )函数的变量 b，上面的是 func( )函数的变量 b。语句 b += 5 中，从上到下在栈中找变量 b，找到的就是 func( )的变量 b。需要注意的是，在栈中找变量时，不会跨越保护现场的斜纹矩形，只会在从上到下第1 个斜纹矩形的上面找局部变量，如果没有找到，就认为局部变量中没有这个变量。这就是内存图中将为函数参数分配内存与保护现场进行交换的原因。语句“a += 2”修改 func( )的静态变量 a，语句 n += 12 修改的是全局变量 n。-10 -6int b5int b\"a:\"\"  b:\"\"  n:\"1 13int n0main:int a2 4func:int aa:0b:-10n:1a:4b:10n:13_图 5.22 func 函数中第 1 次输出读者可按照上面的方法，画出 main( )函数中第 1 次输出和 func( )函数中第 2 次输出时内存图，并得到下面的输出结果。a:0b:-10n:1内部资料 严禁外传156a:4b:10n:13a:0b:-6n:13a:6b:10n:35_对比两次调用函数 func( )时函数的输出结果，可以发现，局部变量 b 的输出相同，而静态局部变量 a 的输出不同。这是因为局部变量的内存空间分配在栈中，每次调用结束后该部分内存会被回收，所以每次调用函数，局部变量值的变化过程相同，输出结果当然也相同，而静态变量的内存空间分配在全局数据区，再次调用时会沿用上次退出时保存的值，所以每次调用函数时，该变量的值自然和上次调用时不同，输出结果也就不同。局部变量一般用于存储函数中处理的数据，使用最频繁，也最安全。全局变量一般用于存储有关程序全局性的公共数据，并可以实现函数之间的数据传递，也最不安全。静态局部变量一般用于存储调用函数中的公共数据，并可以在不同调用之间传递数据，安全性在局部变量和全局变量之间。例如在函数中声明一个静态变量，用于计数：void nextInteger(){static int count = 1;cout << count++ << endl;}这个函数在显示静态变量 count 的当前值后，递增它的值。第一次调用函数时，该变量显示值 1。第二次调用时，则显示值 2。每次调用函数时，都会显示一个比上一次调用大1 的值。建议在没有充分理由的情况不要使用全局变量。静态变量使用场景相对多些，但也不能滥用。5.3.2 复合语句的语义复合语句的作用是，在语法上将多条语句视为一条语句，语法如下：{       //开始标志语句列表；}       //回收变量除了语法上的作用外，还有实际语义。在退出语句块时，需要回收语句块中定义的变量。回收变量有两种含义，针对局部变量，回收存储空间，针对静态局部变量，虽然不回收存储空间，但不能访问这个变量，从逻辑上讲，这个变量就不存在了，相当于逻辑上回收了这个变量。下面通过示例来演示介绍复合语句中的变量管理，代码如例 5.4 所示。【例 5.4】复合语句中的变量管理。#include <iostream>using namespace std;void main(){int i;char ch;i = 3;内部资料 严禁外传157//复合语句{double i; //定义 double 变量 ii = 3.0e3;  //访问 double i，不能访问 int ich = 'A';   //可访问 char ch}               //回收 dounle ii += 1;         //可访问 int i}在复合语句中，定义了 double 类型变量 i，结束复合语句时，系统会回收复合语句中定义的变量 i。复合语句结束前和结束后栈中的变量，如图 5.23 所示。3'A'int ichar chdouble i3.0e33'A'int ichar ch(a)结束复合语句前                                                       (b) 结合复合语句后图 5.23 复合语句结束前和结束后栈中的变量在栈中按照从上到下的顺序查找同名的变量，找到第 1 个变量，就访问这个变量。在语句“i = 3.0e3”时，栈中有两个名为 i 的变量，按照从上到下的顺序，找到的第 1 个变量是最近刚定义的 double 变量 i，因此，就对这个变量 i 赋值。下面的代码，在 for 语句中定义了循环变量 i，同样的，结束 for 语句后，系统会回收变量 i，回收后就变量不存在，不能再访问。int s = 0, n;cin >> n;for (int i = 1; i <= n; i++)s = s + i;cout << i;//变量i已回收，不能访问变量icout << s;上面这个代码在一些编译器中仍然可能编译通过，这是因为，这些编译器为了提高程序的运行效率，没有严格按照语义回收变量。但在实际应用中，应该严格按照规定的语义编写程序，否则，会出现只能在一个编译器上编译通过，其他编译器或其他版本都不能通过编译的情况，这是非常严重的事件，会严重损害程序的可移植性和健壮性。理解计算机中管理内存的原理，并画出其内存图，是学习编程的有效方法，有助于理解计算机语言中的变量生命周期、作用域和可见性等概念。其实，在画出内存图的情况下，可不必了解这些概念。5.3.3 访问变量的规则编译器在编译变量时，首先找同名的局部变量，然后找同名的静态变量，最后找同名内部资料 严禁外传158的全局变量，具体步骤是：第 1 步，在当前函数定义的变量中查找同名的局部变量。 第 2 步，在当前函数定义的变量中查找同名的静态变量。 第 3 步，在当前源文件中查找同名的全局变量。 下面通过示例介绍访问变量的规则，代码如例 5.5 所示。 【例 5.5】访问变量的规则。#include <iostream>using namespace std;int n = 10;//全局变量void f(){n++;//全局变量加 1cout << \"    全局变量 n=\" << n << endl;static int n = 2;//静态局部变量cout << \"    静态局部变量 n:\" << n << endl;n++; //静态局部变量 n 加 1cout << \"    静态局部变量 n 加 1 后 n:\" << n << endl;}void main(){n++; //全局变量加 1cout << \"全局变量 n=\" << n << endl;int n = 0;cout << \"局部变量 n=\" << n << endl;cout << \"第 1 次调用 f\" << endl;f();cout << \"第 2 次调用 f\" << endl;cout << \"局部变量 n=\" << n << endl;f();cout << \"全局变量 n=\" << ::n << endl;}上面的程序中，用注释标注了访问的是哪个变量。 例 5.5 程序的内存状态和输出结果为：0int nf()\"    全局变量n=\"\"    静态局部变量n:\"\"    静态局部变量n加1后n:\"\"全局变量n=\"\"局部变量n=\"\"第1次调用f\"\"第2次调用f\"\"全局变量n=\"10 11 12 13int n2 3全局变量n=11局部变量n=0第1次调用f全局变量n=12静态局部变量n:2静态局部变量n加1后n:3第2次调用f内部资料 严禁外传159局部变量n=0全局变量n=13静态局部变量n:3静态局部变量n加1后n:4全局变量n=13_本节中的程序，是为了演示怎样分配变量和访问变量，不能作为实际编程的参考。",
    "5.4 复合函数与分层的思想 ": "复合函数是分解问题的理论基础，分层是组织程序的基本方法，在编程中有很重要的指导意义。5.4.1 复合函数在导航系统中，常常需要在直角坐标系和极坐标系之间转换，从极坐标系转换为直角坐标系的公式为x=rcosθy=rsinθ上述公式中，包含了两个三角函数，在实际应用中，绝不是仅仅求出如 30。、45。几个特殊值就能解决问题，而需要对θ任意一个值求出相应的三角函数值，计算这两项三角函数太复杂，很难求出，可将计算三角函数和其他运算分开，分成两步来计算，如x=3cos1.2第 1 步、计算 1.2的值。 第 2 步、再根据计算出的值，计算3。 第 2 步的计算非常简单，第 1 步中的计算非常复杂，可以委托专门人员进行计算。理想的情况是，应用专家专注构建并计算第 2 步中的公式，专注于应用，计算专家专注于第1 步中的计算，以支持应用专家解决实际问题。支持这种分工模式的理论就是数学中的复合函数，复合函数的定义为： 实数集 X、Y、Z 上分别有两个函数y=φ(x)z=f ( y )如果函数 y=φ(x)的值域与 z=f ( y )的定义域相等，则函数 y=φ(x)和 z=f ( y )构成一个复合函数，记为z=f ( φ(x) )复合函数的映射关系，如下图 5.24 所示。内部资料 严禁外传160x1x2x4x3x5x6y1y2y3y4y5…………集合X:定义域fy6y7集合YZ1Z2Z3Z4Z5……集合Zφ图 5.24 复合函数的映射关系复合函数的定义中，函数 y=φ(x)的值域与 z=f ( y )的定义域相等，换句话说是，对复合函数 f ( φ(x) )定义域中的每个数都能计算出唯一的值，保证了计算的唯一性。复合函数 z=f ( φ(x) ) ，先将 x 映射到 y，再将 y 映射到 z，经过这两次映射，完成了将x 映射到 z 映射。在计算时，也要通过如图 5.25 所示的两步骤来完成，第 1 步，计算y=φ(x),第 2 步，计算 z=f ( y )。复合函数 z=f ( φ(x) )的计算步骤如图 5.25(a)所示。φxyfzφxyfzx(a). 复合函数 (b). 复合函数变型图 5.25 复合函数 z=f ( φ(x) )的分层在计算复合函数 z=f ( φ(x) )时，如果要得到 z 的值，不仅要计算函数 f，还必须计算φ，具有“要计算函数 f，先计算函数 φ”的逻辑，这不同于求两个梯形的面积之和。为了表示出这个差异，将图 5.25(a)变形为图 5.25(b)。计算复合函数 z=f ( φ(x) )的过程包含了计算 f ( φ(x) )和 φ(x)函数，但它们又是不同的函数，对于这种情况，通常称函数 f 包含了函数 φ，在画图时，习惯将函数 f 画在上面，函数φ 画在下面。5.4.2 数学公式中的复合函数按照复合函数的定义，可将公式 =   视为一个函数x=fx(r,θ)=rcosθ令 t=cosθ， 得 到 一 个 复 合 函 数fx ’(r,t)=rt根 据 复 合 函 数 的 定 义 ， 其计算步骤如图 5.26a 所示。复合函数的计算过程，如图5.26 所示。内部资料 严禁外传161costfxxr,θθcostfxx1.2, 31.2(a). x 坐标的计算步骤 (b). 计算 x 坐标图 5.26 复合函数的计算过程图 5.26 所示的两个函数，分别为t=cosθfx ’(r,t)=rt计算 = 3  1.2，需要分别计算t=cos1.2 fx ’(r,t)=3t其中，由于 cos1.2 的值很难由人工计算，就交给计算机计算，在这时用符号 t 代替具体的计算值。前面几章中，经常提到“数学公式”，如，推导数学公式，将数学公式改写为表达式，使用递推公式构造循环等。现在的问题是，“数学公式”是什么？以函数的观点，本教材中的“数学公式”其实就是函数，在分析和推导过程中，使用了复合函数的思想。如 4.4 节中，设计计算阶乘累加和的算法时使用了复合函数的思想，定义了相应的函数，然后再将定义的函数复合成起来。1 + 2! + 3! +  n!设计算法时， 在公式s = ∑ ∏ ==中，令 = ∏ =1实际上，是定义了一个函数()() = ∏ =将一个自然数 i 映射为一个整数，而公式内部资料 严禁外传162() = ∑ =将一个自然数 k 映射为一个整数，其中的 ti，是数列{ti}中的第 i 个元素，不是函数的自变量。将函数 t(i)和 s(i)复合成一个函数() = ∑ ()=按照上述复合函数，设计出嵌套循环方式的算法，分别计算 t(i)和 s(i)，然后再复合规则将它复合起来，最终计算出阶乘累加和。深入思考才能做事简单。 强烈建议读者，以函数的观点，重新理解前几章的内容。5.4.3 分层思想复合函数提供了分解问题的基本方法，在实际应用中，往往会按照复合函数的思想，对需要解决的实际问题进行多次分析，形成一个分层结构。下面以计算 x= rcosθ 为 例 讨 论 分 解 问 题 时 的 层 次 关 系 。 可 使用复合函数思想设计出计算 x= rcosθ 的 程 序 ， 代 码 如 例 5.6 所 示 。【 例 5.6】 求 x= rcosθ。#include <iostream>#include <math.h>using namespace std;double fx(double r, double rt);void main(){double x, y;cin >> x >> y;cout << fx(x, y);}double fx(double r, double rt){return r*cos(rt);}例 5.6 中 ， 定义了 main( )和 fx( )两个函数，调用了 cos( )函数。fx( )是数学函数fx(r,θ)=rcosθ， 但将 fx 换为 fx，将 θ 换为 rt，cos( )为数学中的 cos(x)函数。程序中，main( )函数调用 fx( )函数，fx( )又调用了 cos( )函数，构成三个层次。求 x=r cosθ 程序中的三个层次，如图 5.27 所示。内部资料 严禁外传163cosfxmain图 5.27  =   中的三个层次如图 5.27 所示，main 函数处于第一层次，主要关注于使用转换出的直角坐标解决实际问题，fx 函数处于第二层次，主要关注于怎样将极坐标转换为直角坐标，cos(x)函数处于第三层次，主要关注于怎样计算 cos(x)等常用数学函数。按照分层的思想，库函数中提供了大量的常用函数，供程序员使用。cos()函数是其中之一，在 math.h 头文件中声明了其函数原型，使用时需要通过语句“#include <math.h>”引入该头文件。例 5.6 中 只 有 三 个 函 数 ， 复 合 关 系 也 比 较 简 单 ， 但 实 际 应 用 中 ， 函 数 之间 的 关 系 往 往 更 复 杂 。 需要考虑更一般的情况。如复合函数y = f1 ( f11( f111(x1) , f112 (x2) ) , f12( f121(f1211 (x3))) , f13 (x4) )其中涉及 8 个函数，复合关系比较复杂，但可分为 4 个层次构成的层次如图 5.28 所示。f1f11f111f112f12f121f1211f13图 5.28 复合函数的层次显然，图 5.28 就是常见的层次图，因此，应根据复合函数的思想设计和理解层次图。",
    "5.5 函数的嵌套调用 ": "按照复合函数的思路，一个函数可以调用另一个函数，这种方式称为函数的嵌套调用。例如，下面的代码在主函数中调用一个函数，该函数又调用了另一个函数。int funcA(int, int);int  funcB(int);int main()内部资料 严禁外传164{int a = 6, b = 12, c;c = funcA(a,b);}int funcA(int aa, int bb){int n = 5;//...return funcB(n*aa*bb);}int funcB(int s){int x = 10;//...return s / x;}main( )函数调用 funcA( )函数，funcA( )函数调用 funcB( )函数，函数之间的调用关系如图 5.29(a)所示。主函数调用 funcA( )函数时，将变量 a、b 的值 6、12 分别传递给 funcA( )函数，funcA( )函数调用 funcB( )函数时，将表达式 n*aa*bb 的值 360 传递给 funcB( )函数， funcB( ) 函数执行完毕后返回 funcA( ) 函数时，返回函数值 36， funcA( ) 函数执行完毕后返回 main( ) 函数时，返回函数值 36。函数嵌套调用过程如图 5.29(b)所示，调用过程的内部实现如图 5.30 所示。mainfunAfunBfunBfunA6,12main3603636(a)函数的调用关系  (b)参数传递和函数值返回的过程图 5.29 函数嵌套调用过程内部资料 严禁外传165int a6int bint cint Rint aaint bbint nmain()12funcA()6125int a6int bint cmain()12int a6int bint cmain()1236int a6int bint cint Rint aaint bbint nint Rint smain()12funcA()6125int xfuncB()10360int a6int bint cint Rint aaint bbint nmain()12funcA()612536main()调用funcA()funcA()调用funcB()funcB()返回funcA()funcA()返回main()36图 5.30 调用过程的内部实现调用过程如下。 main( ) 函数中使用 funcA(a,b) 调用 funcA( )函数为返回值创建一个临时变量 R；保护现场；先为形参 aa 分配内存，并将实参 a 的值 6 赋值给形参 aa，然后为形参 bb 分配内存，并将实参 b 的值 12 赋值给 bb。funcA( )函数中，使用 funcB(n*aa*bb)调用 funcB( )函数为返回值创建一个临时变量R；保护现场；先为形参 s 分配内存空间，并将表达式 n*aa*bb 的值 360 作为实参赋值给形参 s。返回过程如下。 funcB( ) 函数中，使用 return s / x 返回到 funcA( ) 函数。先将表达式 s / x 的值 36 赋值给 funcA( ) 函数中的临时变量 R；然后依次回收局部变量 x 和形参变量 s 的内存；恢复现场；最后返回到 funcA( ) 函数继续执行。funcA( ) 函数中，使用 return funcB(n*aa*bb)返回到 main( ) 函数：先将存储在 R 中的funcB(n*aa*bb)函数值 36 赋值给 main( ) 函数中的临时变量 R；然后依次回收 funcA( ) 函数中的临时变量 R、局部变量 x 和形参 bb、aa 的内存；恢复现场；最后返回到 funcA( ) 函数继续执行。返回到 main( ) 函数，执行语句 c = funcA(a,b)中的赋值运算，从临时变量 R 中读取返回值 36，并赋值给变量 c。执行语句 c = funcA(a,b)结束后，回收存储 funcA( )返回值的临时变量 R。从图 5.30 可以看出，调用函数时，每调用一个函数，栈内存空间就减少一部分，如果一层层地调用下去，最后可能导致栈空间枯竭而引起程序运行出错。另外值得说明的是，所谓内存回收，指的是释放该内存的使用权，使其可以被其他函数重新分配使用，而内存中的数据不一定会被抹去。",
    "5.6 递归函数 ": "递归思维与递推思维是互逆的思维过程，它是通过不断将一个问题分解为同类的子问内部资料 严禁外传166题来解决问题，经常被用于解决复杂的问题。递归方法在计算机中广泛应用，是最重要也是最基本的方法。5.6.1 数学归纳法中的递归i. 数学归纳法证明分为下面两步。 证明当 n= 1 时命题成立。ii. 假设 n=k 时命题成立，那么证明 n=k+1 时命题也成立。其中的第 ii 条包含“n=k 时命题成立”和“n=k+1 时命题成立”，如果先证明“n=k 时命题成立”，再证明“n=k+1 时命题成立”，这种逻辑就是递推的逻辑。如果将构造证明过程的逻辑改成，要证明“n=k+1 时命题成立”，先证明“n=k 时命题成立”，按照这个逻辑构造出的证明过程称为递归。数学归纳法的递归，如图 5.31 所示。i.已证明当n= 1时命题成立要证明n=k时命题也成立k=?k减1先证明n=k-1时命题也成立k-11>1ii.要证明n=k时命题也成立，先证明n=k-1时命题也成立图 5.31 数学归纳法的递归如图 5.31 所示，递归中包含“递”和“归”两个过程，实线表示“递”的过程，虚线表示“归”的过程。“递”中的步骤与递推刚好相反，“归”的步骤与递推完全相同，“递”和“归”是两个相反的过程。“递”的证明过程为：要证明“n 时命题成立”，先证明“n-1 时命题成立”；要证明“n-1 时命题成立，先证明“n-2 时命题成立”；以此类推，最后落脚到第 i 条“n= 1 时命题成立”。“归”的证明过程与“递”的证明过程刚好相反，但与递推过程完全相同，详见 4.1.2节。递归是一种思维方式，其特点是，从问题出发，去解决问题，目标非常明确。从需要解决的问题出发，寻找解决问题的路径，找到路径后，再从解决问题的基础开始，沿着相反的路径逐个解决问题，最后将问题全部解决。递归在计算机中广泛应用，如按照“递”来分析表达式的计算顺序，运行时按照“归”来计算表达式的值，详见第 2 章。我们针对表达式设计的计算顺序图，充分体现了递归，也准确抽象了计算机处理表达式的原理和过程。使用计算顺序图分析计算表达式中，所使用的方法就是递归方法，经过前期的训练，相信读者已经对递归有了初步的认识，培养一定的递归思维。内部资料 严禁外传1675.6.2 递归函数举例递归函数指自己调用自己的函数，即在函数体内部直接或间接地自己调用自己，如下面的分段函数。! = {1 = 0,1 × (  1)! > 1这个函数中，有两条，第 1 条，当 n=0 或者 n=1 时，n！=1，第 2 条，当 n>1 时，n!=n×(n-1)!，在求 n!时，使用了(n-1)!。将它换成函数的形式，有() = {1 = 0,1 × (  1) > 1显然，在求()时，调用了函数(  1)，因此，( )就是递归函数。 使用递归函数 fact( )，可编写出求阶乘的程序，代码如例 5.7 所示。 【例 5.7】使用递归函数求阶乘。#include <iostream>using namespace std;long fact(int n){if (n == 0 || n == 1)//递归结束条件return 1;return fact(n - 1)*n;//函数自调用}void main(){int x = 5;cout << fact(x);}语句“return fact(n - 1)*n”中，计算fact(n)时调用fact(n-1)，自己调用自己，但要注意的是，在调用时对n的值将减了1，否则，会一直调用下去，程序不会结束。fact(5)递归调用过程，如图 5.32所示，总共调用fact函数5次，调用fact 函数时实参依次为5、4、3、2、1。当实参为1时，直接返回1，不再继续调用fact函数，而是退出本次调用，逐级返回到上级调用，返回值依次为1、2、6、24、120，最后返回到main函数，输出120。内部资料 严禁外传168factfactfactfactfact4120132126245图 5.32 fact(5)递归调用过程从本质上讲，递归是自顶向下，并且不断重复自己。递归函数中通过自己调用自己的方式体现不断重复自己，实参是自顶向下传递的，体现了自顶向下的思维方式。5.6.3 递归调用过程的内部实现递归调用分为函数调用(call)过程和函数返回(return)两个过程，前面可以理解“递”，后面理解为“归”。1. “递”过程的内部实现main5int x5int xint Rint n55int xint Rint n5int n4int R5int xint Rint n5int n4int Rint n3int R5int xint Rint n5int n4int Rint n3int Rint n2int R5int xint Rint n5int n4int Rint n3int Rint n2int Rint n1int Rfact(5)fact(4)fact(3)fact(2)fact(1)图 5.33 fact(5)函数调用过程main()函数调用 fact(5)，fact(5)调用 fact(4)，总共调用 fact() 5 次，每次都要为形参 n分配内存并传递实参的值，并为返回值分配内存。fact(5)函数调用过程如图 5.33 所示的。2. “归”过程的内部实现函数调用 fact(5)函数返回过程中，依次从 fact(1)返回 fact(2)、fact(3)、fact(4)、内部资料 严禁外传169fact(5)，每次返回都要返回计算的值，并回收内存，其返回过程如图 5.34 所示。5int xint Rint n5int n4int Rint n3int Rint n2int Rint n11int Rfact(1)5int xint Rint n5int n4int Rint n3int Rint n22int Rfact(2)5int xint Rint n5int n4int Rint n63int Rfact(3)5int xint Rint n5int n244int Rfact(4)5int xint Rint n1205fact(5)5int xmain图 5.34 fact(5)函数返回过程从递归调用的实现中不难发现，使用递归调用实现 fact(5)的效率比使用循环低，但编写出的代码更加简洁。5.6.4 编写递归函数的方法使用数学归纳法编写递归函数时，将其中的两条改为： i  当 n= 1 时，计算 n= 1 时的值并返回结果。 ii 计算 n=k 时的值中调用自己计算 n=k-1 时的值。  只需按照上面两条编写递归函数。 例如，斐波那契(Fibonacci)数列0,1,1,2,3,5,8,13,21,…中，每个数都是前面两个数之和，可使用递推公式定义为F0=0,F1=1Fn+2=Fn+1+Fn也可将斐波那契数中数视为 n 的函数 F(n)，其定义如下() = {0 = 01 = 1(  1) + (  2) > 1在这个函数定义中，当 n>1 时，用(  1) + (  2)计算 ()的值，这是一个递归函数。根据这个递归函数，可编写出计算斐波那契数列中任意元素的函数，代码如例 5.8所示。内部资料 严禁外传170【例 5.8】使用递归计算 Fibonacci 数列的元素。long fib(int x){cout << x << endl;//用于观察调用过程//第 i 条,结束递归条件if (x == 0)return 0;else if (x == 1)return 1;//第 ii 条return fib(x - 1) + fib(x - 2);  //直接递归}按照数学归纳法中两条编写程序时，其顺序不能交换，每条计算结果后都要返回计算结果。return fib(x - 1) + fib(x - 2)中，调用了自己两次，计算过程比调用一次复杂一些。总共调用自己 15 次，构成一个树形结构。计算 Fib(5)的调用过程，如图 5.35 所示。fibfib545fib3fib2fib1fib0fib1fibfib1fib023011120130fibfib2fib1fib0fib101112图 5.35 计算 F(5)的调用过程这个递归函数的时间复杂度很高，达到 O(2n)，使用内存也很多，因此，执行效率比较低。这也是递归函数存在的问题。可根据斐波那契数列的递推公式 Fn+2=Fn+1+Fn 设计计算 Fibonacci 数列中任意元素的递推算法，再定义一个函数出计算 Fibonacci 数列的元素如图 5.36 所示，代码如例 5.9 所示。【例 5.9】使用递推计算 Fibonacci 数列的元素。int fib1(int n){//第 i 条 F0=0,F1=1if (n == 0)return 0;else if (n ==  1)return 1;//第 ii 条 Fn+2=Fn+1+Fn内部资料 严禁外传171int x = 0, y = 1, t;for (int i = 2; i <= n; i++){t = y;y = x + y;x = t;}return y;}例 5.9 的时间复杂度为 O(n)，显然比递归方法快得多，当然，程序也要复杂一些。i++真假int x = 0, y = 1, tt = yy = x + yx = ti≤n真//第i条 F1 0=0,F2 =1图 5.36 计算 Fibonacci 数列递推算法使用递归函数来构造循环，是一个重要方法：  相对递归函数中的“=”，递归是从左到右思考，递推是从右到左计算。 使用递归函数编写的程序，概念清晰，逻辑简明，易于人们理解，但多重函数调用明显增加了系统开销，程序的时间复杂度和空间复杂度都很高，因此，很少用在实际应用，而更多应用于编程的思维层面，用于描述问题和分析问题，用于描述解决问题的方法(算法)，实际应用时再改为递推方式实现。如 4.6 节中，设计阶乘累加和的算法时，用到了递归函数的思想，并设计出了递推算法。根据阶乘累加和公式推导出s = ∑ !=1= ∑ !1=1+ (  1)! ×  = s1 + (  1)! × 令1 = (  1)!时，实际上是为了定义如下两个递归函数() = (  1) × 内部资料 严禁外传172() = (  1) + 1 × 其中，1是数列{ti}中的第 k-1 个元素。然后再这两递归函数复合成一个递归函数() = (  1) + ()最后按照复合函数中的复合规则，设计出递推公式tk = tk1 × k，s = s1 + 最终设计出了高效的递推算法。",
    "5.7 重载函数与默认参数 ": "编写出简洁的代码，是程序员追求的目标，而代码重用是减少代码冗余的重要方法，重载函数和默认参数是实现代码重用的一种有效途径。5.7.1 重载函数在编写程序中，一般使用函数名来反映函数的功能，同时，也用函数名来区分函数，要求函数名必须唯一。当程序比较小时，这不是一个问题，但当程序很大、函数很多时，取名就成了一个大问题。例如，求一个数的绝对值。在数学中是一个函数，但程序中需要针对不同的数据类型编写不同的函数，需要定义求绝对值的多个函数。如，为 int、float、double 分别定义求绝对值函数，然后根据实参的数据类型人工确定调用哪个函数，代码如例 5.10 所示。【例 5.10】人工选择调用哪个求绝对值的函数。int iabs(int x);float fabs(float x);double dabs(double x);void main(){int a = -1;float b = 2.0;double c = -3.0, e;e = iabs(a) + fabs(b) + dabs(c); //根据数据类型选择调用哪个函数cout << e << endl;}为 int、float 、double 分别定义了三个求绝对值的函数，程序员在编写调用函数的表达式中时，需要根据实参的数据类型选择调用哪个函数，增加了程序员的工作负担，如图 5.37 所示。mainiabsafabsdabsbc图 5.37 人工确定调用函数第 2 章中，详细讨论加减乘除四则运算中的加法运算，在编写表达式时，只考虑了运算的功能，而不用考虑操作数的数据类型，如：//整数加法内部资料 严禁外传173int a, b, c;c = a + b;//实数加法float a, b, c;c = a + b;其中，有两个表达式 c = a + b，一个进行整数运算，一个进行实数运算，但编写的代码是一样的。在编译时，编译器根据 a、b、c 的数据类型，自动选择整数加法还是实数加法，这样，就减轻了程序员负担，代码也更加简洁。按照上面的思路，希望在求绝对值时程序员不需考虑数据的类型，将表达式e = iabs(a) + fabs(b) + dabs(c)写成e = abs(a) + abs(b) + abs(c)然后，由编译器根据实参的数据类型，选择调用求绝对值的那个函数。 函数的重载技术就为了满足程序员的上述期望而专门设计的。使用重载技术编写函数，称为函数的重载。例如，针对不同数据类型定义不同的 abs 函数。int abs(int x);float abs(float x);double abs(double x);其中，三个函数的名称都是 abs，但参数的数据类型不同。编译器根据实参的数据类型选择调用哪个 abs( )函数，示例代码如下int a=-1;float b=2.0;double c=-3.0,e;abs(a);//调用int abs(int x)abs(b);//调用float abs(float x)abs(c);//调用double abs(double x)函数的重载技术能够减少程序员的工作负担，也能让代码更加简洁。5.7.2 匹配重载函数的步骤在编译时，编译器通过函数名和参数类型来选择调用的函数，具体步骤为： 第 1 步，按照函数名查找函数 编译器是按照书写的前后顺序编译源程序，当编译到一个函数调用时，就在已声明的函数(函数原型)中查找同名的函数，如果找到，再做第 2 步，如果没有找到，则报编译错误，并结束编译。第 2 步，匹配函数的参数及数据类型 在找到的同名函数中，按照函数参数定义的顺序逐个匹配参数及类型，如果有唯一一个函数的参数及参数类型完全匹配，则调用这个函数，如果没有函数匹配或有多个函数都能匹配，则报编译错误，并结束编译。编译器匹配一个函数的流程，如图 5.38 所示。内部资料 严禁外传174匹配参数及数据类型假按照函数名查找函数没找到函数真匹配成功数为1真假报错，结束编译匹配成功，继续编译图 5.38 编译器匹配一个函数的流程编译器通过上述两步来确定要调用的函数，找到的函数必须是唯一，否则编译不通过。另外，在确定调用哪个函数时，没有用到返回类型，也就是说，同名函数的返回类型可以不同，但必须符合逻辑。如函数 abs 的返回类型分别为 int、float 和 double，这是因为，绝对值不能改变其数据类型，这个逻辑决定了函数 abs 返回值的数据类型。例如，重载函数print()的匹配void print(double);void print(int);void func(){print(1);  //匹配void print(int);print(1.0);  //匹配void print(double);print('a');  //匹配void print(int);print(3.1415f); //匹配void print(double);}编译器在匹配时，常常涉及数据类型的转换，以提高编程的方便性和程序的简洁，但也导致可能调用了程序员不期望的函数。为了保证调用程序员希望调用的函数，在匹配参数及参数类型时，编译器往往对数据类型进行比较严格的匹配。实参 1 和'a'是整数，1.0 和 3.1415f 是实数，界线很清楚，编译器将它们分别识别为 int和 double 类型，匹配函数 print 的参数，分别调用 void print(int)和 void print(double)。但有时也会出现界线不明确的情况，编译时不通过。例如，对于重载函数 print()声明，其下面的函数调用将引起错误：void print(long);void print(double);void func(int a){print(a);  //error：因为有二义性}在 vs2013 上编译，出现如下错误：1 IntelliSense: more than one instance of overloaded function \"print\" matches the argument list:内部资料 严禁外传175function \"print(long)\"function \"print(double)\"argument types are: (int)编译器在编译时，对 int 进行了隐式的数据类型转换，int 可转换到 long 或 double，匹配到 print(long)和 print(double)两个函数，出现了二义性，因此，报编译错误。解决的办法，是增加显式的数据类型转换，如 print((long)a)。 函数重载的目的是增加调用函数时的方便性，这是重载函数的出发点。在使用时，需要时刻记住，函数的名称体现函数的功能，在一个程序中不要使用同一个函数名来标识不同功能的函数，这种情况属于滥用语法。滥用语法是严重违反程序规范的行为，在实际编程经验不足的程序员中经常发生，要特别注意。5.7.3 默认参数值函数重载就是使用一个函数名来命名多个功能相同的函数，降低了命名函数的难度，增加了调用的简洁性，让程序员少考虑参数的类型而更关注函数的功能。除这种方法外，还有一种“默认参数值”方法，也能够减少程序员编写和调用函数时的工作量。下面通过一个示例来演示默认参数值的作用，代码如例 5.11 所示。【例 5.11】默认参数值的作用。#include <iostream>using namespace std;void delay(int loops);          //函数声明void delay(int loops = 10000) // 参数 loops 的默认值为 10000{if (loops == 0)return;for (int i = 0; i < loops; i++);}void main(){delay(2000);delay();//实际调用 delay(10000)}在定义函数时，给参数 loops 指定了默认值 10000。 当使用 delay()调用函数时，编译器首先查找没有参数 delay 函数，没有找到后，再根据 void delay(int loops=10000)，将 delay()转换为 delay(10000)，再重新查找到带 delay(int)，并按照 delay(10000)调用函数。实际上，使用函数默认参数值，是将一些事情委托编译器承担，但编译器在承担这些事情时，也提出了相应的要求，第 1、不能在函数原型和定义中同时指定默认参数值，以避免出现不一致的情况，第 2、必须从后面开始依次设置默认参数值，以保证编译器知道省略的是哪个实参。例如：void f(int a, int b = 20, int c = 30, int d = 40); 在调用函数时，编译器按照从左到右的顺序用实参匹配形参，如果实参匹配完后就用默认参数值作为实参匹配，因此，其合法的调用方式有下面 4 种：f(1);  //f(1,20,30,40)f(1, 2); //f(1,2,30,40)内部资料 严禁外传176f(1, 2, 3); //f(1,2,3,40)f(1, 2, 3, 4); //f(1,2,3,4)不允许定义为void f(int a=10, int b , int c = 30, int d = 40)因为，通过 f(1,2)调用函数时，产生了二义性，编译器不知道按照 f(1,2,30,40)还是f(10,1,2,40)调用函数。使用默认参数，可以减少定义的函数数量，增加代码的重用。 例如：只使用函数重载，不使用默认参数值，需要定义多个函数。void f(int a, int b, int c, int d){//函数体};void f(int a){int b = 20, c = 30, d = 40;f(a, b, c, d);};void f(int a, int b){int c = 30, d = 40;f(a, b, c, d);}void f(int a, int b, int c){int  d = 40;f(a, b, c, d);}使用重载技术和默认参数值，能够提高代码的重用性，但应避免出现二义性。",
    "5.8 函数模板 ": "增加代码的重用性，是编程中不断追求的目标，最理想的情况是，相同功能的代码在整个程序中只出现一次。例如，求一个数的绝对值，可以使用重载技术，定义多个函数。int abs(int x){if (x < 0) return -x;return x;}long abs(long x){if (x < 0) return -x;return x;};double abs(double x){if (x < 0) return -x;return x;};在上述三个函数中，函数体的代码是完全一样的，为了减少程序代码的冗余，在C/C++语言等语言中，增加了函数模板(function template)技术，能够消除其中的代码冗余，内部资料 严禁外传177提高代码的重用性。函数模板不是实际的函数，而是一个函数的“模板”，编译器根据“模板”生成一个或多个实际的函数。例如：声明计算绝对值的函数模板template< class T> T abs(T x){if (x < 0) return -x;return x;}声明一个名为 abs 的函数模板，其中，关键字 template 表示要声明一个函数模板，<class T>声明函数模板的一个参数 T，后面的代码声明 abs( )函数，其参数 x 的数据类型为T，返回值的数据类型也为 T。可用一个具体的数据类型替换函数模板 abs 中的模板参数 T，生成一个实际的函数。例如：int a = -1;cout<<abs(a);//调用函数的原型为int abs(int)语句“cout<<abs(a) ”中调用 abs( )函数，编译器会根据实参 a 的数据类型 int，按照原型 int abs(int x)调用函数，并将函数模板 abs( )中的模板参数 T 替换为 int，自动生成一个实际 abs( )函数。int abs(int x){if (x < 0) return -x;return x;}根据函数模板生成的函数被称为函数模板的实例(function template instantiation)，一个实例就是一个实际的函数，也称为模板函数。如函数 int abs(int x)就有函数模板 abs 的一个实例，也是一个实际的函数，可编译为目标代码，连接到可执行程序中。根据实参的数据类型，可生成多个模板函数。使用函数模板求绝对值代码如例 5.12 所示。【例 5.12】使用函数模板求绝对值。#include <iostream>template< class T> T abs(T x){if (x < 0) return -x;return x;}void main(){int a=-1;float b=2.0;double c=-3.0,e;//根据实参的数据类型生成相应的 abs 函数e = abs(a) + abs(b) + abs(c);cout <<e << endl;}abs(a) + abs(b) + abs(c)中，调用 abs( )函数三次，其实参的数据类型分别为 int、float 和double，编译器针对这三种类型，函数模板 abs( )实例化出三个 abs( ) 函数，如图 5.39 所内部资料 严禁外传178示。mainint abs(int)abcfloat abs(float)double abs(double)图 5.39 函数模板 abs( )实例化出三个 abs( )函数如图 5.39 所示，例 5.12 中函数模板 abs( )实例化出三个 abs( ) 函数，其代码如下。int abs(int x){if (x < 0) return -x;return x;}float abs(float x){if (x < 0) return -x;return x;};double abs(double x){if (x < 0) return -x;return x;};然后将三个函数 abs 编译为目标代码，并连接到可执行文件。 随着计算机应用的深入，编译器的智能化程序也越来越高，能够按照程序员的意图生成大量代码，让程序员从细节中解脱出来，有更多精力关注程序的逻辑，关注程序的功能，编程效率明显提高，因此，作为一个合格的程序员，应该更深入理解编译的基本原理和基本方法，并熟练使用至少一个集成开发环境(IDE)，逐步将关注重点聚集到程序的逻辑。",
    "5.9 应用举例 ": "递归思维是计算思维的主要特征之一，递归函数是构建算法的基本方式。下面学习两个经典的递归算法。5.9.1 求最大公约数欧几里得算法提供了求解最大公约数的方法，即辗转相除法，计算两个非负整数 m 和n 的最大公约数：如果 n 为 0，则最大公约数为 m；否则，m 除以 n 得到余数为 r，m 和 n 的最大公约数就是 n 和 r 的最大公约数。可用如下的递归函数描述为：(, ) = { = 0 (,   ) ≠ 0内部资料 严禁外传179用递归函数描述算法，简洁清楚。下面使用递归和循环两种方式编程实现欧几里得算法。1. 使用递归求最大公约数按照 5.6 节中的方法，很容易编写出如下函数。int gcd1(int m, int n){if (n == 0) //n=0return m;elsereturn (gcd1(n, m%n));}调用(gcd1(n, m%n))时，参数位置进行了交换，其中，后面一个参数 m%n 使用模运算(相除后取余数)，所以形象地称为辗转相除法。读者可参照如图 5.32 所示 fact(5)的调用过程，画出上面代码的递归过程，有助于理解欧几里得算法。2. 使用循环求最大公约数在递归函数中，当 n≠0 时，gcd(m,n) =gcd(n,m mod n)，这是递归的核心。等号=两边都是函数，对比这两个函数会发现，将 gcd(n,m mod n)中的“m mod n”代入了 gcd(m,n)中的自变量 n，将 gcd(n,m mod n)中的 n 代入了 gcd(m,n)中的自变量 m，因此，可用赋值运算表示这个代入关系，即，r=n，n=m mod n，m=r。将 n≠0 作为递推条件，将“r=n，n=m mod n，m=r”作为递推公式构造循环，流程如图 5.40 所示。递推公式“r=n，n=m mod n，m=r”中，为了交换两个变量的值，增加了一个中间变量 r。i++假r=n，n=m mod n，m=rn ≠ 0真图 5.40 使用循环求最大公约数按照如图 5.40 所示的流程，可编写出如下代码。int gcd2(int m, int n){int r;while (n != 0) {内部资料 严禁外传180r = n;n = m % n;m = r;}return m;}其中，循环条件 n != 0 是来自 m mod n≠0，如果 n 为 0，m 就是最大公约数，因此，结束循环，直接返回 m 的值，否则，继续循环，m 除以 n 得到余数为 r，再求 n 和 r 的最大公约数。在 main( )函数中调用数求最大公约数的递归函，代码如例 5.13 所示。 【例 5.13】递归函数求最大公约数。#include <iostream>using namespace std;int gcd1(int m, int n);int main(){int m, n;int result;cout << \"Please enter two number:\" << endl;cin >> m >> n;result = gcd1(m, n);cout << \"Result is: \" << result;return 0;}如果调用使用循环求最大公约数的函数，只需将例 5.13 中的函数名 gcd1 替换 gcd2。 递归算法和递推算法都可根据递归函数设计。在设计递归算法时，“从左到右”理解递归函数的定义，先按照左边的函数形式定义函数，然后再按照右边的函数形式调用函数。在设计递推算法时，按相反的顺序“从右到左”理解递归函数的定义，通过右边函数的值计算左边函数的值，并设计出递推公式。上面介绍了使用递归函数设计递推算法和递归算法的方法，这个方法仅仅对递归函数定义进行了形式上的变换，非常简单，不仅如此，这个方法还可以推广到非递归函数的定义上，如复合函数，成为构造循环的一种通用方法。5.9.2 汉诺塔(Hanoi)问题相传在古印度圣庙中，有一种被称为汉诺塔(Hanoi)的游戏。该游戏是在一块铜板装置上，有三根杆(编号 A、B、C)，在 A 杆自下而上、由大到小按顺序放置 64 个金盘。汉诺塔(Hanoi)问题，如图 5.41 所示。内部资料 严禁外传181ABC图 5.41 汉诺塔(Hanoi)问题游戏的目标：把 A 杆上的金盘全部移到 C 杆上，并仍保持原有顺序叠好。 操作规则：每次只能移动一个盘子，并且在移动过程中三根杆上始终保持大盘在下，小盘在上，操作过程中盘子可以置于 A、B、C 任一杆上。对于这样一个问题，任何人都很难按照递推方法直接写出移动盘子的步骤，但利用递归算法很容易解决。设移动盘子数为 n，为了将这 n 个盘子从 A 杆移动到 C 杆，可以做以下三步： (1)以 B 盘为中介，将 1 至 n-1 号盘了从 A 杆移至 B 杆； (2)将 A 杆中剩下的第 n 号盘子移至 C 杆； (3)以 A 杆为中介，将 1 至 n-1 号盘子从 B 杆移至 C 杆 当只有一个盘子时，就可将盘子直接移至 C 杆，结束递归。 按照上面的递归算法，编写求解汉诺塔(Hanoi)问题的程序，代码如例 5.14 所示。 【例 5.14】汉诺塔(Hanoi)问题求解int i = 1;                        //移动盘子的顺序号void moveOne(int num, char from, char to); //将编号为 N 的盘子由 from 塔转移到 to 塔//汉诺塔递归函数，参数依次为:盘子数、起始塔、中转塔、目标塔void Hanoi(int n, char A, char B, char C){if (n == 1)moveOne(n, A, C);      //只有一个盘子else{Hanoi(n - 1, A, C,B );//以 C 盘为中介，将 1 至 n - 1 号盘了从 A 杆移至 B 杆moveOne(n, A, C);      //将 A 杆中剩下的第 n 号盘子移至 C 杆Hanoi(n - 1, B, A, C);//以 A 杆为中介，将 1 至 n - 1 号盘子从 B 杆移至 C 杆}}void moveOne(int num, char from, char to){cout << \"第\"<<i++<<\"步：将\"<<num <<\"号盘子\"<< \":\"<< from << \"-->\" << to << endl;}建议读者编写一个主函数，调试程序，分别观察 1 到 10 个盘子时盘子的移动顺序，并按照输出的移动顺序人工移动盘子，总结出移动的规律，再思考循环方式实现的算法。内部资料 严禁外传182",
    "5.10 函数的调试与维护 ": "按照结构化程序设计思想，函数实现了一个相对独立的功能，是构成程序的基本单元，也是软件设计的最小单位。在函数的调试与维护过程中涉及一些单元测试的技术。调试和维护函数主要是基于白盒测试，发现函数内部可能存在的各种错误，并改正发现的错误。白盒测试是单元测试(Unit Testing)的基础。5.10.1 白盒测试和黑盒测试白盒测试是一种测试用例设计方法，在这里盒子指的是被测试的软件，白盒，顾名思义，盒子是可视的，可以清楚盒子内部的东西以及里面是如何运作的，因此白盒测试需要对系统内部的结构和工作原理有一个清楚的了解，并且基于这个知识来设计测试用例。白盒测试技术一般可被分为静态分析和动态分析两类技术。静态分析主要有控制流分析技术、数据流分析技术、信息流分析技术。动态分析主要有逻辑覆盖率测试(分支测试、路径测试等)，以及程序插桩。白盒测试优点。迫使测试人员去仔细的思考软件的实现流程；可以检测代码中的每条分支和路径；揭示隐藏在代码中的错误；对代码的测试比较彻底。白盒测试缺点。昂贵；无法检测代码中遗漏的路径和数据敏感性错误；不验证规格的正确性。黑盒测试又叫功能测试，这是因为在黑盒测试中主要关注被测软件的功能实现，而不是内部逻辑。在黑盒测试中，被测对象的内部结构，运作情况对测试人员是不可见的，测试人员对被测产品的验证主要是根据其规格，验证其与规格的一致性。最常见的测试有：功能性测试、容量测试、安全性测试、负载测试、恢复性测试、标杆测试、稳定性测试、可靠性测试等。灰盒测试是介于白盒测试和黑盒测试之间的测试。白盒测试和黑盒测试往往不是绝对分开的，一般在白盒测试中交叉使用黑盒测试的方法，在黑盒测试中交叉使用白盒测试的方法。5.10.2 测试用例和白盒测试技术测试用例(Test Case)是为某个特定目标而编制的一组测试输入、执行条件以及预期结果，以便测试某个执行路径或核实是否满足某个特定需求。测试用例构成了设计和制定测试过程的基础。测试的“深度”与测试用例的数量成比例。由于每个测试用例反映不同的场景、条件，因而，随着测试用例数量的增加，对程序质量也就越有信心。测试工作量与测试用例的数量成比例。最佳方案是为每个测试需求至少编制两个测试用例。一个测试用例用于证明该需求已经满足，通常称作正面测试用例。另一个测试用例反映某个无法接受、反常或意外的条件或数据，用于论证只有在所需条件下才能够满足该需求，这个测试用例称作负面测试用例。白盒测试是结构测试，以程序的内部逻辑为基础设计测试用例，白盒测试的测试用例设计一般采用逻辑覆盖法和路径覆盖法。逻辑覆盖依据程序内部的逻辑结构，要求测试人员对程序的逻辑结构有清楚的理解，内部资料 严禁外传183可分为语句覆盖、判定覆盖、条件覆盖、判定条件覆盖。语句覆盖：在测试时，首先设计若干个测试用例，然后运行被测程序，使程序中的每条可执行语句至少执行一次。判定覆盖：在测试时，首先设计若干个测试用例，然后运行被测程序，使得程序中的每个判断的取真分支和取假分支至少经历一次，即判断的每个分支都要被测试。条件覆盖：在测试时，首先设计若干个测试用例，然后运行被测程序，要使每个判断中每个条件的可能取值至少满足一次。判定条件覆盖：在测试时，首先设计若干个测试用例，然后运行被测程序，使得判断中每个条件的所有可能至少出现一次，并且每个判断本身的判定结果至少出现一次。语句覆盖在语句层次上对测试提出了基本要求，程序员需要分析代码中每条语句的语义以及语句之间的逻辑关系。程序中使用最多的语句是表达式语句，分析和理解表达式的计算顺序和运算序列，是测试表达式语句的基础，也是测试整个程序的基础。判定覆盖主要针对分支语中的“分支”提出的，要求分支语句中的真假两个分支都必须至少执行一次，而条件覆盖要求程序员还要分析分支语句中作为条件的表达式，分析出条件的所有可能取值，针对每个可能取值都要至少执行一次。判定条件覆盖将判定覆盖和条件覆盖的要求组合起来，要求程序员需要综合分析多条分支语句及条件，每个判断每个条件的可能取值都应该至少执行一次。判定覆盖、条件覆盖、判定条件覆盖都针对分支中的判断及判断条件对测试提出了要求，而且要求越来越高，测试的“深度”越来越深，发现的“bug”也会越来越多，程序的正确性也会越来越高，但测试工作量也会越来越大。这就是在编程过程中大部分时间都是在调试代码的原因，也要求在编写代码时，应选择适当的分支模式使得分支结构的代码简洁、结构清晰。从本质上讲，循环结构中也包含了分支、判断及条件，因此，前面的测试方法也适用于测试循环结构的代码，但将这些测试方法直接用于测试循环结构的代码，常常会导致测试的工作量巨大，甚至出现不能完成的情况，因此，按照另外的思路提出了一种测试方法，即路径覆盖。路径覆盖是以流程为基础的测试用例设计技术，希望设计出的一组测试用例能够覆盖程序中所有可能的路径。常用的方法有基本路径覆盖和循环路径测试。基本路径覆盖法：在流程图的基础上，通过分析控制结构的环路复杂性，导出基本可执行路径集合，然后设计测试用例。该方法把覆盖的路径数压缩到一定限度内，程序中的循环体最多执行一次。设计出的测试用例要保证在测试中，程序的每一条可执行语句至少执行一次。循环路径测试：基本路径覆盖法将循环限制在最多一次，这样虽然大大降低了需要覆盖的路径的条数，但对循环的测试却不充分了，因此还需要对循环路径进行测试。循环路径测试包含简单循环的测试和嵌套循环的测试。每一种覆盖方法都有其优缺点。通常在设计测试用例时应该根据代码的复杂度，选择覆盖方法。代码的复杂度与测试用例设计的复杂度成正比，因此，从测试角度，希望一个函数的功能单一、代码简单，这样可明显降低设计测试用例的难度，提高测试用例的覆盖程度。建议读者从测试角度，重新理解前面几章的编程方法，调试其中的例程代码。内部资料 严禁外传184",
    "5.11 本章小结 ": "本章主要学习了函数的基本知识，学习了使用“栈”机制管理变量和实现函数调用的原理，学习了定义和调用函数的方法，深入学习了使用数学递归函数编写计算机递归函数和构造循环的方法，最后介绍了调试和维护函数的步骤和基本方法。学习了局部变量、全局变量和静态局部变量等基本知识，学习了计算机管理变量的知识，深入学习了使用“栈”机制管理局部变量的原理，需要掌握变量的使用方法。从数学函数引入了函数的概念，学习了黑盒和分层的思想，学习了计算机函数的基本知识，举例说明了定义和调用函数的方法，学习了使用“栈”机制实现函数调用的原理，深入学习了使用“栈”机制分析函数内部执行过程的方法，学习了描述函数调用关系的方法，需要掌握根据数学函数定义编写计算机函数的方法，需要理解函数调用过程中参数传递的过程。从数学归纳法引入递归的概念，学习了按照数学归纳中的递归思想编写递归函数和构造循环的方法，学习了递归函数的实现机制，培养了编程所需的递归思维，需要掌握根据数学递归函数编写计算机递归函数和构造循环的方法。以代码重用为目标，学习了函数模板以及重载函数技术，以及使用这两种技术编写函数的方法，需要掌握重载函数技术的使用方法。最后介绍了白盒测试等基本的测试技术。",
    "5.12 习题 ": "1． 分析下列程序，画出程序的内存图，并写出输出结果。#include <iostream>void func();int n = 1;int main(){static int x = 5;int y;y = n;cout << \" Main -- x = \" << x<< \"， y = \" << y<< \"， n = \" << n << endl;func();cout << \" Main -- x = \" << x<< \"， y = \" << y<< \"， n = \" << n << endl;func();}void func(){static int x = 4;int y = 10;内部资料 严禁外传185x += 2;n += 10;y += n;cout << \" Func -- x = \" << x<< \"， y =\" << y<< \"， n = \" << n << endl;}2． 编写打印乘法九九表的程序，然后再将程序改用函数调用的形式，并定义三个函数，各个函数按照不同格式输出九九乘法表。3． 编写程序，其中包含三个重载的display()函数。第一个函数输出一个double值，前面用字符串“A double:”引导；第二个函数输出一个int值，前面用字符串“A int:”引导；第三个函数输出一个char字符，前面用字符串“A char:”引导。在主函数中，分别用double，float，int，char 和short 型变量去调用display()函数，并对结果做简要说明。4． 以下函数poly是用递归方法计算x的n阶勒让德多项式的值。已有调用语句\" p(n，x); \"，先采用递归方式编写poly函数，然后再改写为循环方式。递归公式如下：polyn(x) = 1  当 n=0 时；polyn(x) = x  当 n=1 时；polyn( x) = ((2n - 1) * x * polyn - 1(x) – (n - 1) * polyn – 2(x)) / n  当 n>1 时.5．写一个程序，计算并输出斐波那契(Fibonacci)数列中一系列的相邻项之比。确定一个范围，观察输出的结果，你能够得到什么结论。(这个比的序列可能有极限吗?极限是什么?)请查阅有关资料，了解有关的理论结果。6．辗转相减法求最大公约数，它的基本原理是：大数减小数，直到两数相等时，即为最大公约数，可用下面的公式表示gcd(m, n) = { = gcd (,   ) < gcd (  , ) > 使用递归和循环方式各编写一个求最大公约数的函数。 7．按照下面的公式编写一个求 sin 近似值的函数，以每项的绝对值小于 10-6 作为结束条件，sin() = ∑(1)2+1(2 + 1)!∞=1编写一个主函数，输入 x 的值，并调用编写的函数求 sin(x)的近似值。 8．探讨求素数的算法，要求如下： (1)将4.6.4和4.6.1中判断素数的程序改为函数。 (2)通过网络查找判断素数的算法，并编写为函数。 (3)使用这些函数编写程序，分别求1000内的所有素数，并比较它们的运行时间。内部资料 严禁外传186"
  }
}
def printNers(ners, fw):
    ners = list(set(ners))
    res = [t[0] for t in ners if t[1] in ["术语类", "术语类_术语类型", "术语类_符号指标类"]]
    if len(res) != 0:
        fw.write(str(res))  # 输出上一节的实体
    fw.write('\n')
'''
 title: 为标题
 ners：为该标题下的知识点
'''

def addNodes(ners,title,titles):
    ners = list(set(ners))
    res = [t[0] for t in ners if t[1] in ["术语类", "术语类_术语类型", "术语类_符号指标类"]]
    nodes_num = len(nodes_data)
    links_num = len(links_data)
    title_id = 'n{}'.format(nodes_num)
    titles.append(title_id)
    #先添加标题节点
    nodes_data.append({
        'id': title_id,
        'name': title,
        'semantic_type': '小节',
        'description': ''
    })
    nodes_num = nodes_num + 1
    #再添加剩余的知识点以及关系
    flag = 0
    for i, item in enumerate(res):
        if flag == 5:
            break
        node_id = 'n{}'.format(i + nodes_num)
        node_name = item
        node_type = '知识点'
        node_description = ''
        nodes_data.append({
            'id': node_id,
            'name': node_name,
            'semantic_type': node_type,
            'description': node_description
        })
        # {'id': 'l1', 'name': '包含', 'relation': '包含了', 'source': 'n3', 'target': 'n1'}
        link_id = 'l{}'.format(i+links_num)
        link_name = '包含'
        link_relation = '包含了'
        link_source = title_id
        link_target = node_id
        links_data.append({
            'id': link_id,
            'name': link_name,
            'relation': link_relation,
            'source': link_source,
            'target': link_target
        })
        flag = flag + 1
def extractKnowledge(dic):
    titles = []
    for i, chapter_name in enumerate(dic):
        print(chapter_name) #取出章节标题
        # 加入 章节 节点
        nodes_num = len(nodes_data)
        chapter_id = 'n{}'.format(nodes_num)
        chapter_ids.append(chapter_id)
        node_name = chapter_name
        node_type = '章节'
        node_description = ''
        nodes_data.append({
            'id': chapter_id,
            'name': node_name,
            'semantic_type': node_type,
            'description': node_description
        })
        chapter = dic[chapter_name]
        for j, section_name in enumerate(chapter):
            print(section_name)
            ners = ner(chapter[section_name])
            addNodes(ners,section_name,titles)
            # print(dic[chapter_name][section_name])
            # 最后再将 titles 与 chapter 关联
            links_num = len(links_data)
            for title_id in titles:
                link_id = 'l{}'.format(i + links_num)
                link_name = '包含'
                link_relation = '包含了'
                link_source = chapter_id
                link_target = title_id
                links_data.append({
                    'id': link_id,
                    'name': link_name,
                    'relation': link_relation,
                    'source': link_source,
                    'target': link_target
                })
            titles = []
    a = 1
    return chapter_ids,nodes_data,links_data

# print(nodes_data)
# print("==================links=====================")
# print(links_data)
# print(chapter_ids)
extractKnowledge(dic)   